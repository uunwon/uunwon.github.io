<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.6.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-06-07T20:08:58+09:00</updated><id>http://localhost:4000/</id><title>UUNWON</title><subtitle>Student at Korea Polytechnic University</subtitle><entry><title>[BoostCourse] Android 5th Project</title><link href="http://localhost:4000/BoostCourse-Android5-Project/" rel="alternate" type="text/html" title="[BoostCourse] Android 5th Project" /><published>2021-06-07T00:00:00+09:00</published><updated>2021-06-07T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-Android5-Project</id><content type="html" xml:base="http://localhost:4000/BoostCourse-Android5-Project/">&lt;h2 id=&quot;project-e-note&quot;&gt;Project-E note&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt; API를 통해 서버에서 데이터를 조회한 후 화면에 표시하도록 합니다.&lt;br /&gt;
http://boostcourse-appapi.connect.or.kr:10000/&lt;/p&gt;

&lt;h3 id=&quot;-과제-요구사항&quot;&gt;🌟 과제 요구사항&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;제공되는 영화API를 보고 서버에 요청하고 응답받는 방법을 파악&lt;/li&gt;
  &lt;li&gt;서버에 영화목록 데이터를 요청하고 응답을 받아 영화목록 화면에 표시&lt;/li&gt;
  &lt;li&gt;서버에 영화상세 데이터를 요청하고 응답을 받아 영화상세 화면에 표시&lt;/li&gt;
  &lt;li&gt;서버에 한줄평 데이터를 요청하고 응답을 받아 한줄평 리스트가 보이는 부분에 표시&lt;/li&gt;
  &lt;li&gt;사용자가 한줄평을 작성했을 때 해당 데이터를 서버에 보내어 저장&lt;/li&gt;
  &lt;li&gt;서버에 올라가 있는 영화 이미지를 가져와 화면에 보여주기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Glide와 Universal Image Loader 라이브러리 사용 가능&lt;/li&gt;
  &lt;li&gt;Volley 라이브러리를 이용해 영화API 서버에 요청하고 응답받기&lt;/li&gt;
  &lt;li&gt;응답으로 받은 JSON 문자열을 Gson으로 자바 객체화하기&lt;/li&gt;
  &lt;li&gt;인터넷 접근 권한 설정&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-과제-수행&quot;&gt;⭐ 과제 수행&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;APM 이란?&lt;br /&gt;
https://velog.io/@jiyoonoh-dev/APM%EC%9D%B4%EB%9E%80&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>Project-E note
by boostcourse</summary></entry><entry><title>[Android] Android Event</title><link href="http://localhost:4000/Android-Event/" rel="alternate" type="text/html" title="[Android] Android Event" /><published>2021-05-24T00:00:00+09:00</published><updated>2021-05-24T00:00:00+09:00</updated><id>http://localhost:4000/Android-Event</id><content type="html" xml:base="http://localhost:4000/Android-Event/">&lt;h2 id=&quot;안드로이드-이벤트&quot;&gt;안드로이드 이벤트&lt;/h2&gt;

&lt;p&gt;　&lt;strong&gt;이벤트(event)&lt;/strong&gt;란 사용자와 애플리케이션 사이 또는 애플리케이션들 사이에 일어나는 어떤 일을 의미한다. 사용자가 프로그램을 사용하기 위해 화면을 터치하거나 키를 누르는 일 등이 이벤트에 해당된다. 사용자가 그러한 행위를 했을 때, 앱이 그에 대한 반응을 보이는 부분이 개발자가 해야 할 일이다. 이벤트 처리 방식은 크게 이벤트 구동 방식과 폴링 방식 2가지로 나뉜다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;이벤트-처리-방식&quot;&gt;이벤트 처리 방식&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;폴링(Polling) 방식&lt;br /&gt;
　폴링 방식은 어떤 상태인지를 주기적으로 확인하는 방식, 즉 사용자의 입력을 기다리는 방식이다. 예를 들면 우편물이 왔는지를 매번 내가 가서 보는 것이다. 이렇게 매번 오가는게 폴링이다. 주기적으로 알아보는 만큼 오지 않았을 때 나가보는 동안 비효율이 발생한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이벤트 구동(Event-driven) 방식&lt;br /&gt;
　이벤트 구동 방식은 어떤 상태가 되면 알려주는, 즉 입력 발생 시 이벤트를 발생시키고 처리되는 방식이다. 예를 들면 매번 가는 것이 아니라 우편물이 도착했을 때 문자를 보내는 것이다. 시스템 내에서는 대개 이벤트 방식으로 처리하게 된다. 이벤트가 발생되면 인터럽트와 같이 하던 일을 중단시키고 해당 이벤트가 원하는 일을 처리한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;[안드로이드] 이벤트(event)란?&lt;br /&gt;
https://m.blog.naver.com/netrance/110125232920&lt;br /&gt;
폴링 vs 이벤트&lt;br /&gt;
https://wikidocs.net/22376&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>안드로이드 이벤트</summary></entry><entry><title>[SQLD] Chapter</title><link href="http://localhost:4000/SQLD/" rel="alternate" type="text/html" title="[SQLD] Chapter" /><published>2021-05-20T00:00:00+09:00</published><updated>2021-05-20T00:00:00+09:00</updated><id>http://localhost:4000/SQLD</id><content type="html" xml:base="http://localhost:4000/SQLD/">&lt;h2 id=&quot;sqld-sql-developer-chapter&quot;&gt;SQLD (SQL Developer) Chapter&lt;/h2&gt;

&lt;p&gt;₁/ 데이터 모델링의 이해&lt;br /&gt;
₂/ SQL 기본 및 활용&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;--데이터-모델링의-이해&quot;&gt;₁ / 데이터 모델링의 이해&lt;/h3&gt;

&lt;h4 id=&quot;1-1-데이터-모델링의-이해&quot;&gt;1-1. 데이터 모델링의 이해&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;모델링의 이해&lt;/li&gt;
  &lt;li&gt;엔티티ㆍ속성ㆍ관계ㆍ식별자의 개념&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1-2-데이터-모델의-성능&quot;&gt;1-2. 데이터 모델의 성능&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;성능 데이터 모델링의 개요&lt;/li&gt;
  &lt;li&gt;정규화ㆍ반정규화와 성능&lt;/li&gt;
  &lt;li&gt;대량 데이터에 따른 성능&lt;/li&gt;
  &lt;li&gt;데이터베이스 구조와 성능&lt;/li&gt;
  &lt;li&gt;분산 데이터베이스와 성능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;--sql-기본-및-활용&quot;&gt;₂ / SQL 기본 및 활용&lt;/h3&gt;

&lt;h4 id=&quot;2-1-sql-기본&quot;&gt;2-1. SQL 기본&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;관계형 데이터베이스 개요&lt;/li&gt;
  &lt;li&gt;DDLㆍDMLㆍTCL&lt;/li&gt;
  &lt;li&gt;WHERE 절&lt;/li&gt;
  &lt;li&gt;함수(Function)&lt;/li&gt;
  &lt;li&gt;GROUP BYㆍHAVING 절&lt;/li&gt;
  &lt;li&gt;ORDER BY 절&lt;/li&gt;
  &lt;li&gt;조인(Join)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-2-sql-활용&quot;&gt;2-2. SQL 활용&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;표준 조인&lt;/li&gt;
  &lt;li&gt;집합 연산자&lt;/li&gt;
  &lt;li&gt;계층형 질의ㆍ셀프 조인&lt;/li&gt;
  &lt;li&gt;서브 쿼리&lt;/li&gt;
  &lt;li&gt;그룹 함수ㆍ윈도우 함수&lt;/li&gt;
  &lt;li&gt;DCL&lt;/li&gt;
  &lt;li&gt;절차형 SQL&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-3-sql-최적화-기본-원리&quot;&gt;2-3. SQL 최적화 기본 원리&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;옵티마이저와 실행계획&lt;/li&gt;
  &lt;li&gt;인덱스 기본&lt;/li&gt;
  &lt;li&gt;조인 수행 원리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;데이터 온-에어 https://dataonair.or.kr/&lt;/p&gt;</content><category term="test" /><summary>SQLD (SQL Developer) Chapter</summary></entry><entry><title>[JAVA] Reflection n Refactorying</title><link href="http://localhost:4000/Reflection-Refactory/" rel="alternate" type="text/html" title="[JAVA] Reflection n Refactorying" /><published>2021-05-11T00:00:00+09:00</published><updated>2021-05-11T00:00:00+09:00</updated><id>http://localhost:4000/Reflection-Refactory</id><content type="html" xml:base="http://localhost:4000/Reflection-Refactory/">&lt;h2 id=&quot;reflection-n-refactory&quot;&gt;Reflection n Refactory&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Reflection&lt;/li&gt;
  &lt;li&gt;Refactorying &lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;reflection&quot;&gt;Reflection&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　Reflection이란 &lt;strong&gt;구체적인 클래스 타입을 알지 못해도&lt;/strong&gt;, 그 클래스의 메소드, 타입, 변수들을 접근할 수 있도록 해주는 &lt;code class=&quot;highlighter-rouge&quot;&gt;자바 API&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;　자바는 스크립트 언어가 아닌 컴파일 언이다. 원래 자바에서는 동적으로 객체를 생성하는 기술이 없었지만, 동적으로 인스턴스를 생성하는 Reflection이 그 역할을 대신한다. 즉, Reflection(투영, 반사)은 객체를 통해 클래스의 정보를 분석해내는 프로그램 기법이다.&lt;/p&gt;

&lt;p&gt;　자바 클래스 파일은 바이트 코트로 컴파일되어 Static 영역에 위치한다. 때문에 클래스 이름만 알고 있다면, 언제든 이 영역을 통해 클래스에 대한 정보를 가져올 수 있다. 아래는 가져올 수 있는 정보들이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ClassName &lt;br /&gt; Class Modifiers (public, private, synchronized 등) &lt;br /&gt; Package Info &lt;br /&gt; SuperClass &lt;br /&gt; Implemented Interfaces &lt;br /&gt; Constructors &lt;br /&gt; Methods Fields &lt;br /&gt; Annotations&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;refactorying&quot;&gt;Refactorying&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　Refactorying이란 &lt;strong&gt;외부 동작을 바꾸지 않으면서&lt;/strong&gt; 내부 구조를 개선하는 방법이다. 작은 단계로 나누어 프로그램을 변경하며, 코드가 작성된 후에 디자인을 개선하는 작업이다. 포인트는 리팩토링을 하면서 긴으을 추가하는 것이 아닌 기능 단위로 추가, 테스트 후 리팩토링을 진행해야 한다는 것이다.&lt;/p&gt;

&lt;p&gt;　이는 소프트웨어를 보다 이해하기 쉽고, 수정하기 쉽도록 만드는 것이다. 또한 겉으로 보이는 소프트웨어의 기능을 변경하지 않는 것에 그 목적이 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;Java Reflection 개념 및 사용법&lt;br /&gt;
https://gyrfalcon.tistory.com/entry/Java-Reflection&lt;br /&gt;
자바의 리플렉션&lt;br /&gt;
https://brunch.co.kr/@kd4/8&lt;br /&gt;
Refactorying 이란?&lt;br /&gt;
https://nesoy.github.io/articles/2018-05/Refactoring&lt;/p&gt;</content><category term="java" /><summary>Reflection n Refactory</summary></entry><entry><title>[CS] APM</title><link href="http://localhost:4000/APM/" rel="alternate" type="text/html" title="[CS] APM" /><published>2021-05-06T00:00:00+09:00</published><updated>2021-05-06T00:00:00+09:00</updated><id>http://localhost:4000/APM</id><content type="html" xml:base="http://localhost:4000/APM/">&lt;h2 id=&quot;apm&quot;&gt;APM&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Apache PHP MySQL&lt;/li&gt;
  &lt;li&gt;Application Performance Management&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;apache-php-mysql&quot;&gt;Apache PHP MySQL&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　&lt;strong&gt;A&lt;/strong&gt; pache : 웹 서버&lt;br /&gt;
　&lt;strong&gt;P&lt;/strong&gt; HP : 웹 프로그래밍 언어&lt;br /&gt;
　&lt;strong&gt;M&lt;/strong&gt; ySQL : 데이터베이스&lt;/p&gt;

&lt;p&gt;　APM 이란 위의 세가지가 연동되어 운영되도록 만든 환경을 말한다. Apache와 MySQL이 PHP와 호환성이 좋기 때문에, 주로 세 프로그램을 묶어 사용한다. APM 의 구동방식은 다음과 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;클라이언트가 웹브라우저에서 URL을 입력하면, 80번 포트를 통해 서버에 Request를 한다. 서버는 Response로 클라이언트에게 HTML, CSS 등의 웹사이트의 정보를 넘겨주게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;application-performance-management&quot;&gt;Application Performance Management&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　&lt;strong&gt;애플리케이션 (웹 애플리케이션) 의 성능을 관리&lt;/strong&gt; 하는 서비스로, 웹 서비스를 제공하는데 있어 안정적으로 운영할 수 있도록 지원하는 서비스다. 이같은 APM은 서비스 개발이 완료되고 테스트 단계부터 도입하여 운영하는 것이 효율적이다. APM은 웹 서비스의 동작 상태를 관찰하고 성능을 분석하며 특히 미들웨어(Weblogic, Tomcat, JBOSS 등)에서 일어나는 트랜잭션의 사용 시간을 분석해 각 단계별로 성능에 영향을 미치는 원인을 분석할 수 있다.&lt;/p&gt;

&lt;p&gt;　APM은 크게 &lt;strong&gt;Agent&lt;/strong&gt;, &lt;strong&gt;Repository Server&lt;/strong&gt;, &lt;strong&gt;Application Server&lt;/strong&gt; 3가지로 구성되어 있다. Agent는 웹 서버에 설치되어 데이터를 수집하며 Repository Server에 데이터를 전송한다. Application Server는 운영자가 애플리케이션 성능을 분석하려 할 때 Repository Server에서 데이터를 끌고와서 사용자에게 분석 데이터를 제공하는 역할을 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;APM 이란?&lt;br /&gt;
https://velog.io/@jiyoonoh-dev/APM%EC%9D%B4%EB%9E%80&lt;br /&gt;
Linux APM 정의 및 설치&lt;br /&gt;
https://m.blog.naver.com/PostView.nhn?blogId=jutlsgood&amp;amp;logNo=90133000463&amp;amp;proxyReferer=https:%2F%2Fwww.google.com%2F&lt;br /&gt;
APM 서비스란?&lt;br /&gt;
https://brunch.co.kr/@leedongins/38&lt;br /&gt;
APM에 대한 진지한 설명&lt;br /&gt;
https://www.whatap.io/ko/blog/19/&lt;/p&gt;</content><category term="test" /><summary>APM</summary></entry><entry><title>[CS] Software Attack</title><link href="http://localhost:4000/SW-ATTACK/" rel="alternate" type="text/html" title="[CS] Software Attack" /><published>2021-04-21T00:00:00+09:00</published><updated>2021-04-21T00:00:00+09:00</updated><id>http://localhost:4000/SW-ATTACK</id><content type="html" xml:base="http://localhost:4000/SW-ATTACK/">&lt;h2 id=&quot;sw-개발-보안을-위한-공격기법의-이해-by-수제비&quot;&gt;SW 개발 보안을 위한 공격기법의 이해 by 수제비&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;DoS 공격&lt;/li&gt;
  &lt;li&gt;DDoS 공격&lt;/li&gt;
  &lt;li&gt;자원 고갈 공격&lt;/li&gt;
  &lt;li&gt;애플리케이션 공격&lt;/li&gt;
  &lt;li&gt;네트워크 서비스 공격&lt;/li&gt;
  &lt;li&gt;취약점 공격
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;dos-공격&quot;&gt;DoS 공격&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　Denial of Service 란 시스템을 악의적으로 공격해 해당 시스템의 자원을 부족하게 하여 원래 의도된 용도로 사용하지 못하게 하는 공격이다. DoS 공격의 종류에는 지역 시스템 공격과 원격 네트워크 공격이 있다.&lt;/p&gt;

&lt;p&gt;　&lt;code class=&quot;highlighter-rouge&quot;&gt;지역 시스템 공격&lt;/code&gt;은 실제 대상 시스템에 접근하여 서버 하드웨어에 직접 과부하를 주는 공격이고, &lt;code class=&quot;highlighter-rouge&quot;&gt;원격 네트워크 공격&lt;/code&gt;은 공격자가 목표 시스템에 접근하지 않고 원격지에서 인터넷 등을 이용한 공격이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;ddos-공격&quot;&gt;DDoS 공격&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　DoS의 또 다른 형태로 여러 대의 공격자를 분산 배치하여 동시에 동작하게 함으로써 특정 사이트를 공격하는 기법이다. 해커들이 취약한 인터넷 시스템에 대한 액세스가 이뤄지면, 침입한 시스템에 소프트웨어를 설치하고 이를 실행시켜 원격에서 공격을 개시한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;자원-고갈-공격&quot;&gt;자원 고갈 공격&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　서버 간 핸드셰이크를 통해 통신이 연결되는 정상 트래픽과 달리 DoS 공격은 정상 접속을 시도하는 오픈된 소켓에 트래픽을 집중시킨다. 공격이 임계치에 도달하면 사용자들은 네트워크에 전혀 접속할 수 없게 된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SYN 플러딩&lt;/code&gt;&lt;br /&gt;
TCP 프로토콜의 구조적인 문제를 이용한 공격으로, 공격자는 ACK를 발송하지 않고 계속 새로운 연결 요청을 하게 되어 (SYN 패킷) 서버는 자원할당을 해지하지 않고 자원만 소비하여 자원이 고갈된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TCP 세션 하이재킹&lt;/code&gt;&lt;br /&gt;
TCP Sequence number의 보안상 문제점 때문에 발생하며 TCP의 세션 관리 취약점을 이용한 공격 기법이다. TCP 세션 하이재킹에 대응하기 위해서는 비동기화 상태 탐지, ACK 패킷 비율 모니터링, 특정 세션에서 패킷 유실 및 재전송이 증가되는 것을 탐지해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UDP 플러딩&lt;/code&gt;&lt;br /&gt;
대량의 UDP 패킷을 만들어 임의의 포트 번호로 전송하여 응답 메시지(ICMP)를 생성하게 하여 지속해서 자원을 고갈시키는 공격&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;스머프&lt;/code&gt;&lt;br /&gt;
출발지 주소를 공격 대상의 IP로 설정하여 네트워크 전체에게 ICMP Echo 패킷을 직접 브로드캐스팅하여 마비시키는 공격&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PoD(Ping of Death)&lt;/code&gt;&lt;br /&gt;
큰 사이즈의 패킷을 의도적으로 목표시스템으로 발생시켜 시스템이 서비스할 수 없는 상태로 만드는 공격&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;애플리케이션-공격&quot;&gt;애플리케이션 공격&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP GET 플러딩&lt;/code&gt;&lt;br /&gt;
Http 캐시 옵션을 조작하여 캐싱 서버가 아닌 웹서버가 직접 처리하도록 유도, 웹서버 자원을 소진시키는 서비스 거부 공격&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Slowloris&lt;/code&gt;&lt;br /&gt;
HTTP GET 메소드를 사용하여 헤더의 최종 끝을 알리는 개행 문자열인 \r\n\r\n을 전송하지 않고, \r\n만 전송하여 대상 웹서버와 연결상태를 장시간 지속시키고 연결 자원을 모두 소진시키는 서비스 거부 공격&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RUDY&lt;/code&gt;&lt;br /&gt;
요청 헤더의 Content-length를 비정상적으로 크게 설정하여 메시지 바디 부분을 매우 소량으로 보내 계속 연결 상태를 유지시키는 공격&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;네트워크-서비스-공격&quot;&gt;네트워크 서비스 공격&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;네트워크 스캐너, 스니퍼&lt;/code&gt;&lt;br /&gt;
네트워크 하드웨어 및 소프트웨어 구성의 취약점 파악을 위해 공격자가 사용하는 공격 도구&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;패스워드 크래킹&lt;/code&gt;&lt;br /&gt;
사전(Dictionary) 크래킹과 무차별(Brute Force) 크래킹 방법을 사용해 네트워크 패스워드를 탐색&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IP 스푸핑&lt;/code&gt;&lt;br /&gt;
서버에 대한 인증되지 않은 액세스 권한을 입수하는 데 사용하는 기법&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;트로이 목마&lt;/code&gt;&lt;br /&gt;
악성 루틴이 숨어 있는 프로그램으로서 겉보기에는 정상적인 프로그램처럼 보이지만 실행하면 악성 코드를 실행&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;취약점-공격&quot;&gt;취약점 공격&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;랜드 어택&lt;/code&gt;&lt;br /&gt;
출발지 IP와 목적지 IP를 같은 패킷 주소로 만들어 보냄으로써 수신자가 자기 자신에게 응답을 보내게 하여 시스템의 가용성을 침해하는 공격기법&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;봉크(Bonk)/보잉크(Boink)&lt;/code&gt;&lt;br /&gt;
프로토콜의 오류 제어를 이용한 공격기법으로서 시스템의 패킷 재전송과 재조립이 과부하를 유발&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;티어 드롭&lt;/code&gt;&lt;br /&gt;
IP 패킷의 재조합 과정에서 잘못된 Fragment Offset 정보로 인해 수신시스템이 문제를 발생하도록 만드는 DoS 공격&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><category term="test" /><summary>SW 개발 보안을 위한 공격기법의 이해 by 수제비</summary></entry><entry><title>[CS] SQL</title><link href="http://localhost:4000/SQL/" rel="alternate" type="text/html" title="[CS] SQL" /><published>2021-04-20T00:00:00+09:00</published><updated>2021-04-20T00:00:00+09:00</updated><id>http://localhost:4000/SQL</id><content type="html" xml:base="http://localhost:4000/SQL/">&lt;h2 id=&quot;sql-by-수제비&quot;&gt;SQL by 수제비&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;절차형 SQL&lt;/li&gt;
  &lt;li&gt;데이터 분석 함수&lt;/li&gt;
  &lt;li&gt;데이터베이스 기본 연산&lt;/li&gt;
  &lt;li&gt;데이터 제어어 (DCL) 명령문 
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;절차형-sql&quot;&gt;절차형 SQL&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;프로시저(Procedure)&lt;/code&gt;&lt;br /&gt;
　절차형 SQL을 활용하여 특정 기능을 수행할 수 있는 트랜잭션 언어이다. 프로시저 호출을 통해 실행되며, 이를 통해 일련의 SQL 작업을 포함하는 데이터 조작어를 수행한다.&lt;/p&gt;

&lt;p&gt;　실행부(TRANSACTION) 는 해당 프로시저에서 수행한 DML을 DBMS에 반영할지 복구할지를 결정하는 부분이다. &lt;strong&gt;COMMIT&lt;/strong&gt;은 하나의 트랜잭션이 성공적으로 끝나고, 데이터베이스가 일관성 있는 상태에 있을 때 하나의 트랜잭션이 끝냈을 때 사용하는 연산이다. &lt;strong&gt;ROLLBACK&lt;/strong&gt;은 하나의 트랜잭션이 비정상적으로 종료되어 트랜잭션 원자성이 깨질 경우 처음부터 다시 시작하거나, 부분적으로 연산을 취소하는 연산이다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
EXECUTE 프로시저_명 (파라미터_1, 파라미터_2, .. );
&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;사용자 정의함수&lt;/code&gt;&lt;br /&gt;
　절차형 SQL을 활용하여 일련의 SQL 처리를 수행하여, 수행 결과를 &lt;strong&gt;단일 값으로 반환&lt;/strong&gt;할 수 있는 절차형 SQL이다. DBMS에서 제공되는 공통적 함수 이외에 사용자가 직접 정의하고 작성한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
함수명 (파라미터1, 파라미터2, ...)
&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;트리거(Trigger)&lt;/code&gt;&lt;br /&gt;
　특정 테이블에 삽입, 수정, 삭제 등의 데이터 변경 이벤트가 발생하면 DBMS에서 자동적으로 실행되도록 구현된 프로그램이다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;행 트리거&lt;/strong&gt;는 데이터 변화가 생길 때마다 실행되며, &lt;strong&gt;문장 트리거&lt;/strong&gt;는 트리거에 의해 단 한번 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;데이터-분석-함수&quot;&gt;데이터 분석 함수&lt;/h3&gt;

&lt;p&gt;　데이터 분석 함수란 총합, 평균 등의 데이터 분석을 위해 &lt;strong&gt;복수 행 기준의 데이터를 모아서 처리&lt;/strong&gt;하는 것을 목적으로 하는 다중 행 함수이다. GROUP BY 구문을 활용해 복수 행을 그룹핑한다.&lt;/p&gt;

&lt;h4 id=&quot;-집계-함수&quot;&gt;📌 집계 함수&lt;/h4&gt;
&lt;p&gt;　여러 행 또는 테이블 전체 행으로부터 하나의 결괏값을 반환하는 함수이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt;&lt;br /&gt;
해당 구문 뒤에 테이블을 구분하는 컬럼을 기재하여 그룹화한다. 실제 구체적인 데이터 분석값을 보고자 하는 컬럼 단위를 선정할 때 사용되는 기준이 된다. (속성값을 그룹으로 분류하고자 할 때)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HAVING&lt;/code&gt;&lt;br /&gt;
해당 구문은 WHERE 구문 내에는 사용할 수 없는 집계 함수의 구문을 적용하여 복수 행의 계산 결과를 조건별로 적용하는 데 사용된다. 즉, GROUP BY 및 집계 함수에 대한 WHERE 구문이다. (그룹에 제하는 조건문을 작성할 수 있는 절)&lt;/p&gt;

&lt;h4 id=&quot;-그룹-함수&quot;&gt;📌 그룹 함수&lt;/h4&gt;
&lt;p&gt;　테이블의 전체 행을 하나 이상의 컬럼을 기준으로 컬럼 값에 따라 그룹화하여 그룹별로 결과를 출력하는 함수이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ROLLUP&lt;/code&gt;&lt;br /&gt;
해당 함수에 의해 지정된 컬럼은 중간 집계 값을 산출할 수 있는 그룹 함수로, 지정 컬럼의 수보다 하나 더 큰 레벨만큼의 중간 집계 값이 생성된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CUBE&lt;/code&gt;&lt;br /&gt;
결합 가능한 모든 값에 대해 다차원 집계를 생성하는 그룹 함수이다. 연산이 많아 시스템에 부담을 준다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GROUPING SETS&lt;/code&gt;&lt;br /&gt;
집계 대상 컬럼들에 대한 개별 집계를 구할 수 있으며, ROLLUP이나 CUBE와는 달리 컬럼 간 순서와 무관한 결과를 얻을 수 있는 그룹 함수이다.&lt;/p&gt;

&lt;h4 id=&quot;-윈도-함수&quot;&gt;📌 윈도 함수&lt;/h4&gt;
&lt;p&gt;　데이터베이스를 사용한 &lt;strong&gt;온라인 분석 처리&lt;/strong&gt; 용도로 사용하기 위해서 표준 SQL에 추가된 함수다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;순위 함수&lt;/code&gt;&lt;br /&gt;
레코드의 순위를 계산하는 함수&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;행순위 함수&lt;/code&gt;&lt;br /&gt;
레코드에서 가장 먼저 나오거나 가장 뒤에 나오는 값, 이전/이후의 값들을 출력하는 함수&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;그룹 내 비율 함수&lt;/code&gt;&lt;br /&gt;
백분율을 보여주거나 행의 순서별 백분율 등 비율과 관련된 통계를 보여주는 함수&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;데이터베이스-기본-연산&quot;&gt;데이터베이스 기본 연산&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 데이터의 내용을 조회할 때 사용하는 명령어&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
SELECT [ALL | DISTINCT | DISTINCTALL] 속성명1, 속성명2, .. &lt;br /&gt;
FROM 테이블명1, ... &lt;br /&gt;
[WHERE 조건] &lt;br /&gt;
[GROUP BY 속성명1, ..] &lt;br /&gt;
[HAVING 그룹조건] &lt;br /&gt;
[ORDER BY 속성 [ASC | DESC]];
&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;INSERT&lt;/code&gt; 데이터의 내용을 삽입할 때 사용하는 명령어&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
INSERT INTO 테이블명(속성명1, ..) VALUES(데이터1, ..);
&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 데이터의 내용을 변경할 때 사용하는 명령어&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
UPDATE 테이블명 SET 속성명 = 데이터, .. WHERE 조건;
&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DELETE&lt;/code&gt; 데이터의 내용을 삭제할 때 사용하는 명령어&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
DELETE FROM 테이블명 WHERE 조건;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;데이터-제어어-dcl-명령문&quot;&gt;데이터 제어어 (DCL) 명령문&lt;/h3&gt;

&lt;p&gt;　DCL은 데이터베이스 관리자가 데이터 보안, 무결성 유지, 병행 제어, 회복을 위해 관리자(DBA)가 사용하는 제어용 언어다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GRANT 권한 ON 테이블 TO 사용자&lt;/code&gt;&lt;br /&gt;
관리자가 사용자에게 데이터베이스에 대한 권한을 부여하는 명령어&lt;br /&gt;
(+ WITH GRANT OPTION)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;REVOKE 권한 ON 테이블 FROM 사용자&lt;/code&gt;&lt;br /&gt;
관리자가 사용자에게 부여했던 권한을 회수하기 위한 명령어&lt;br /&gt;
(+ CASCADE CONSTRAINTS)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;plus&quot;&gt;PLUS&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;&lt;strong&gt;뷰 생성&lt;/strong&gt;: CREATE VIEW 이름 AS (조건); &lt;br /&gt;
&lt;strong&gt;인덱스 생성&lt;/strong&gt;: CREATE INDEX 이름 ON 조건; &lt;br /&gt;
&lt;strong&gt;UNION&lt;/strong&gt;: 합집합이면서 중복 제거 &lt;br /&gt;
&lt;strong&gt;UNIONALL&lt;/strong&gt;: 합집합이면서 중복 허용&lt;/p&gt;</content><category term="test" /><summary>SQL by 수제비</summary></entry><entry><title>[CS] Protocol</title><link href="http://localhost:4000/Protocol/" rel="alternate" type="text/html" title="[CS] Protocol" /><published>2021-04-20T00:00:00+09:00</published><updated>2021-04-20T00:00:00+09:00</updated><id>http://localhost:4000/Protocol</id><content type="html" xml:base="http://localhost:4000/Protocol/">&lt;h2 id=&quot;protocol&quot;&gt;Protocol&lt;/h2&gt;

&lt;p&gt;　&lt;strong&gt;프로토콜&lt;/strong&gt;은 서로 다른 시스템이나 기기들 간의 데이터 교환을 원활히 하기 위해 표준화된 통신규약&lt;/p&gt;

&lt;h3 id=&quot;soap&quot;&gt;SOAP&lt;/h3&gt;
&lt;p&gt;Simple Object Access Protocol(SOAP) 은 HTTP, HTTPS, SMTP 등을 사용하여 XML 기반의 메시지를 네트워크 상태에서 교환하는 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ipsec&quot;&gt;IPsec&lt;/h3&gt;
&lt;p&gt;IP 계층(3계층) 에서 무결성과 인증을 보장하는 인증헤더(AH)와 기밀성을 보장하는 암호화(ESP)를 이용하여 양 종단 간 구간에 보안서비스를 제공하는 IP 계층 보안 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ike&quot;&gt;IKE&lt;/h3&gt;
&lt;p&gt;Internet Key Exchange 는 보안 관련 설정들을 생성, 협상 및 관리하는 프로토콜로 UDP 500번 포트를 사용하는 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ssh&quot;&gt;SSH&lt;/h3&gt;
&lt;p&gt;네트워크 보안도구 중 하나로 원격 접속을 안전하게 할 수 있게 해주는 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;tls&quot;&gt;TLS&lt;/h3&gt;
&lt;p&gt;SSH에서 발전된 프로토콜로 네트워크 통신보안을 위해 설계된 암호 규약으로 국제 표준 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ssl&quot;&gt;SSL&lt;/h3&gt;
&lt;p&gt;응용 계층과 TCP/IP 계층 사이에서 웹 데이터 암호화 및 전송 시 기밀성을 보장하는 공개키 기반의 보안 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ah&quot;&gt;AH&lt;/h3&gt;
&lt;p&gt;Authentication Header 는 기밀성(암호화)를 제외한 메시지 checksum을 활용한 데이터 인증과 비연결형 무결성을 보장해주는 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;esp&quot;&gt;ESP&lt;/h3&gt;
&lt;p&gt;Eucapsulating Security Payload 는 암호화 알고리즘을 활용한 캡슐화 기반 페이로드 기밀성을 제공하는 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ldap&quot;&gt;LDAP&lt;/h3&gt;
&lt;p&gt;TCP/IP 위에서 디렉토리 서비스를 조회하고 수정하는 응용 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ipv4&quot;&gt;IPv4&lt;/h3&gt;
&lt;p&gt;인터넷에서 사용되는 패킷 교환 네트워크 상에서 데이터를 교환하기 위한 32bit 주소체계를 갖는 네트워크 계층 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ipv6&quot;&gt;IPv6&lt;/h3&gt;
&lt;p&gt;현재 IPv4가 가지고 있는 주소 고갈, 보안성, 이동성 지원 등의 문제점을 해결하기 위해서 개발된 128bit 주소 체계를 갖는 차세대 인터넷 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ftp&quot;&gt;FTP&lt;/h3&gt;
&lt;p&gt;파일 전송 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;smtp&quot;&gt;SMTP&lt;/h3&gt;
&lt;p&gt;메일 전송 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;telnet&quot;&gt;telnet&lt;/h3&gt;
&lt;p&gt;원격 접속 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ip&quot;&gt;IP&lt;/h3&gt;
&lt;p&gt;Internet Protocol은 주소 지정 가능한 연결형 프로토콜, 송신/수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는 데 사용하는 통신규약&lt;/p&gt;

&lt;h3 id=&quot;icmp&quot;&gt;ICMP&lt;/h3&gt;
&lt;p&gt;Internet Control Message Protocol은 IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜로 수신지 도달 불가 메시지를 통해 수신지 또는 서비스에 도달할 수 없는 호스트를 통지하는 데 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;igmp&quot;&gt;IGMP&lt;/h3&gt;
&lt;p&gt;호스트 컴퓨터와 인접 라우터가 멀티캐스트 그룹 멤버십을 구성하는데 사용하는 통신 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;tcp&quot;&gt;TCP&lt;/h3&gt;
&lt;p&gt;전송 계층에 위치하면서 근거리 통신망이나 인트라넷, 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 옥텟을 안정적으로, 순서대로, 에러 없이 교환할 수 있게 해주는 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;udp&quot;&gt;UDP&lt;/h3&gt;
&lt;p&gt;비연결성이고, 신뢰성이 없고, 순서화되지 않은 데이터그램 서비스를 제공하는 전송(Transport, 4계층) 계층의 통신 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;x25&quot;&gt;X.25&lt;/h3&gt;
&lt;p&gt;통신을 원하는 두 단말장치가 패킷 교환망을 통해 패킷을 원활히 전달하기 위한 통신 프로토콜 (고정된 대역폭, 패킷 사용, 1~3계층 담당, 송수신 신뢰성, 성능 저하)&lt;/p&gt;

&lt;h3 id=&quot;프레임-릴레이&quot;&gt;프레임 릴레이&lt;/h3&gt;
&lt;p&gt;ISDN을 사용하기 위한 프로토콜 (유연한 대역폭, 기능 단순화, 1~2계층 담당, 저렴한 가격) (ISDN = 디지털 통신망을 이용해 음성ㆍ문자ㆍ영상 등의 통신을 종합적으로 할 수 있도록 하는 통신서비스)&lt;/p&gt;

&lt;h3 id=&quot;atm&quot;&gt;ATM&lt;/h3&gt;
&lt;p&gt;정보 전달의 기본단위를 53byte 셀 단위로 전달하는 비동기식 시분할 다중화 방식의 패킷형 전송 기술 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;arp&quot;&gt;ARP&lt;/h3&gt;
&lt;p&gt;IP 주소를 MAC 주소로 변환하는 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;라우팅-알고리즘&quot;&gt;라우팅 알고리즘&lt;/h3&gt;
&lt;p&gt;　데이터는 송신 측으로부터 수신 측까지 데이터를 전달하는 과정에서 다양한 물리적인 장치들을 거쳐 간다. &lt;strong&gt;목적지까지의 최적 경로를 산출&lt;/strong&gt;하기 위한 법칙이 라우팅 알고리즘이다. 라우팅 알고리즘에는 인접 라우터와 정보를 공유하여 목적지까지 거리와 방향을 결정하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;거리벡터 알고리즘&lt;/code&gt;과 링크 상태 정보를 모든 라우터에 전달하여 최단 경로 트리를 구성하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;링크상태 알고리즘&lt;/code&gt;이 있다.&lt;/p&gt;

&lt;h4 id=&quot;-rip&quot;&gt;📌 RIP&lt;/h4&gt;
&lt;p&gt;최초의 라우팅 프로토콜, 거리 벡터 알고리즘 활용하여 30초 주기로 전체 라우팅의 정보를 갱신, 변화 업데이트 시 많은 시간이 소요&lt;/p&gt;
&lt;h4 id=&quot;-igrp&quot;&gt;📌 IGRP&lt;/h4&gt;
&lt;p&gt;RIP의 문제점 개선, 네트워크 상태를 고려하여 라우팅&lt;/p&gt;
&lt;h4 id=&quot;-ospf&quot;&gt;📌 OSPF&lt;/h4&gt;
&lt;p&gt;링크 상태 알고리즘을 사용, 발생한 변경 정보에 대해 RIP 보다 빠른 업데이트&lt;/p&gt;
&lt;h4 id=&quot;-bgp&quot;&gt;📌 BGP&lt;/h4&gt;
&lt;p&gt;규모가 큰 네트워크의 상호 연결&lt;/p&gt;

&lt;h3 id=&quot;osi-7계층-프로토콜&quot;&gt;OSI 7계층 프로토콜&lt;/h3&gt;
&lt;p class=&quot;notice&quot;&gt;
응용 http ftp &lt;br /&gt;
표현 jpeg mpeg &lt;br /&gt;
세션 ssh tls ssl &lt;br /&gt;
전송 tcp udp &lt;br /&gt;
네트워크 ip icmp &lt;br /&gt;
데이터 이더넷 &lt;br /&gt;
물리 rs-232c
&lt;/p&gt;</content><category term="test" /><summary>Protocol</summary></entry><entry><title>[CS] Process</title><link href="http://localhost:4000/Process/" rel="alternate" type="text/html" title="[CS] Process" /><published>2021-04-19T00:00:00+09:00</published><updated>2021-04-19T00:00:00+09:00</updated><id>http://localhost:4000/Process</id><content type="html" xml:base="http://localhost:4000/Process/">&lt;h2 id=&quot;process-by-수제비&quot;&gt;Process by 수제비&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스&lt;/li&gt;
  &lt;li&gt;프로세스 상태 전이&lt;/li&gt;
  &lt;li&gt;프로세스 스케줄링 
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;프로세스&quot;&gt;프로세스&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　프로세스(Process)란 일반적으로 CPU에 의해 처리되는 프로그램으로 현재 실행 중인 프로그램을 말한다. 하나의 프로세스는 여러가지 이벤트에 의해 일련의 서로 구분되는 &lt;strong&gt;상태 변화&lt;/strong&gt;(생성 상태, 준비 상태, 실행 상태, 대기 상태, 완료 상태) 를 겪는다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스-상태-전이&quot;&gt;프로세스 상태 전이&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　프로세스의 상태 전이는 하나의 작업이 컴퓨터 시스템에 입력되어 완료되기까지 프로세스의 상태가 준비, 실행 및 대기 상태로 변하는 활동을 말한다. &lt;strong&gt;활동 상태&lt;/strong&gt;는 프로세스가 기억장치를 할당받은 상태이며, &lt;strong&gt;지연 상태&lt;/strong&gt;는 기억장치를 할당받지 못한 상태이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;img src=&quot;http://localhost:4000/images/process_state.png&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;디스패치&lt;/strong&gt;는 준비 상태에 있는 여러 프로세스(Ready list) 중 실행될 프로세스를 선정(Scheduling)하여 CPU를 할당(Dispatching)하는 것으로 문맥교환(Context switching)이 발생한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스-스케줄링&quot;&gt;프로세스 스케줄링&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　프로세스 스케줄링은 CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 작업이다. 하나의 프로세스가 CPU를 차지하고 있을 때, 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 방식인 &lt;code class=&quot;highlighter-rouge&quot;&gt;선점형 스케줄링&lt;/code&gt;과 한 프로세스가 CPU를 할당받으면 작업 종료 후 CPU 반환 시까지 다른 프로세스는 CPU 점유가 불가능한 &lt;code class=&quot;highlighter-rouge&quot;&gt;비선점형 스케줄링&lt;/code&gt; 방식이 있다.&lt;/p&gt;

&lt;h4 id=&quot;-선점형-스케줄링&quot;&gt;📌 선점형 스케줄링&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;라운드로빈(Round Robin)&lt;/code&gt;&lt;br /&gt;
프로세스는 같은 크기의 CPU 시간을 할당, 프로세스가 할당된 시간 내에 처리 완료를 목하면 준비 큐 리스트의 가장 뒤로 보내지고, CPU는 대기 중인 다음 프로세스로 넘어감&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SRT(Shortest Remaing Time)&lt;/code&gt;&lt;br /&gt;
가장 짧은 시간이 소요되는 프로세스를 먼저 수행하고, 남은 처리 시간이 더 짧다고 판단되는 프로세스가 준비 큐에 생시면 언제라도 프로세스가 선정됨&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;다단계 큐&lt;/code&gt;&lt;br /&gt;
작업들을 여러 종류의 그룹으로 분할, 여러 개의 큐를 이용하여 상위단계 작업에 의한 하위단계 작업이 선정 당함&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;다단계 피드백 큐&lt;/code&gt;&lt;br /&gt;
FCFS(FIFO)와 라운드로빈 스케줄링 혼합, 새로운 프로세스는 높은 우선순위를 가지며 프로세스의 실행 시간이 길어질수록 점점 낮은 우선순위 큐로 이동하며 마지막 단계는 RR을 적용함&lt;/p&gt;

&lt;h4 id=&quot;-비선점형-스케줄링&quot;&gt;📌 비선점형 스케줄링&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;우선순위&lt;/code&gt;&lt;br /&gt;
프로세스별로 우선순위가 주어지고, 우선순위에 따라 CPU를 할당함&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;기한부(Deadline)&lt;/code&gt;&lt;br /&gt;
작업들이 명시된 시간이나 기한 내에 완료되도록 계획&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FCFS&lt;/code&gt;&lt;br /&gt;
프로세스가 대기 큐에 도착한 순서에 따라 CPU를 할당함&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SJF(Shortest Job First)&lt;/code&gt;&lt;br /&gt;
프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료 시까지 자원 점유&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HRN(Highest Response Ratio Next)&lt;/code&gt;&lt;br /&gt;
대기 중인 프로세스 중 현재 응답률이 가장 높은 것을 선택, 기아현상 최소화 (= 대기시간+서비스시간 / 서비스시간)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;concept&quot;&gt;CONCEPT&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;&lt;strong&gt;문맥교환(Context switching)&lt;/strong&gt;: CPU가 현재 실행하고 있는 프로세스의 문맥 상태를 프로세스 제어블록(PCB)에 저장하고 다음 프로세스의 PCB로부터 문맥을 복원하는 작업 &lt;br /&gt;
&lt;strong&gt;기아현상(starvation)&lt;/strong&gt;: 시스템 부하가 많아 준비 큐에 있는 낮은 등급의 프로세스가 무한정 기다리는 현상 &lt;br /&gt;
&lt;strong&gt;에이징 기법(Aging)&lt;/strong&gt;: 프로세스가 자원을 기다리고 있는 시간에 비례하여 우선순위를 부여함으로써 무기한 대기하는 문제를 방지하는 기법&lt;/p&gt;</content><category term="test" /><summary>Process by 수제비</summary></entry><entry><title>[CS] Software Test</title><link href="http://localhost:4000/Software-Test/" rel="alternate" type="text/html" title="[CS] Software Test" /><published>2021-04-18T00:00:00+09:00</published><updated>2021-04-18T00:00:00+09:00</updated><id>http://localhost:4000/Software-Test</id><content type="html" xml:base="http://localhost:4000/Software-Test/">&lt;h2 id=&quot;software-test-by-수제비&quot;&gt;Software Test by 수제비&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;소프트웨어 테스트&lt;/li&gt;
  &lt;li&gt;프로그램 실행 여부에 따른 분류&lt;/li&gt;
  &lt;li&gt;테스트 기법에 따른 분류&lt;/li&gt;
  &lt;li&gt;테스트 시각에 따른 분류&lt;/li&gt;
  &lt;li&gt;테스트 목적에 따른 분류&lt;/li&gt;
  &lt;li&gt;테스트 오라클
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;소프트웨어-테스트&quot;&gt;소프트웨어 테스트&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　소프트웨어 테스트란 개발된 응용 애플리케이션이나 시스템이 사용자가 요구하는 기능과 성능, 사용성, 안정성 등을 만족하는지 확인하고, 노출되지 않은 숨어있는 소프트웨어의 결함을 찾아내는 활동이다.&lt;/p&gt;

&lt;p&gt;　위와 같은 테스트는 오류 발견 관점, 오류 예방 관점, 품질 향상 관점에서 필요하다.&lt;/p&gt;

&lt;h4 id=&quot;-소프트웨어-테스트-산출물&quot;&gt;📌 소프트웨어 테스트 산출물&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;
- &lt;b&gt;테스트 계획서&lt;/b&gt;: 테스트 수행을 계획한 문서&lt;br /&gt;
- &lt;b&gt;테스트 케이스&lt;/b&gt;: 테스트를 위한 설계 산출물로, 응용 소프트웨어가 사용자의 요구사항을 준수하는지 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과로 구성된 테스트 항목의 명세서&lt;br /&gt;
- &lt;b&gt;테스트 시나리오&lt;/b&gt;: 테스트 수행을 위한 여러 개의 테스트 케이스의 집합으로 테스트 케이스의 동작 순서를 기술한 문서&lt;br /&gt;
- &lt;b&gt;테스트 결과서&lt;/b&gt;: 테스트 결과를 정리한 문서
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로그램-실행-여부에-따른-분류&quot;&gt;프로그램 실행 여부에 따른 분류&lt;/h3&gt;

&lt;h4 id=&quot;정적-테스트&quot;&gt;정적 테스트&lt;/h4&gt;
&lt;p&gt;　프로그램의 실행 없이 &lt;strong&gt;구조를 분석&lt;/strong&gt;하여 논리성을 검증하는 테스트&lt;br /&gt;
　(ex) 동료 검토, 워크스루, 인스펙션&lt;/p&gt;

&lt;h4 id=&quot;동적-테스트&quot;&gt;동적 테스트&lt;/h4&gt;
&lt;p&gt;　프로그램 실행을 요구하는 테스트&lt;br /&gt;
　(ex) 화이트박스 테스트, 블랙박스 테스트&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-기법에-따른-분류&quot;&gt;테스트 기법에 따른 분류&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;화이트박스 테스트&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;제어구조 테스트&lt;/strong&gt;&lt;br /&gt;
소프트웨어의 논리적 복잡도 측정 후 수행 경로들의 집합을 정의하는 테스트&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;루프 테스트&lt;/strong&gt;&lt;br /&gt;
프로그램의 루프 구조에 국한해서 실시하는 테스트&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;블랙박스 테스트&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;동등분할 테스트&lt;/strong&gt;&lt;br /&gt;
입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 대표값 테스트 케이스를 도출하여 케이스를 도출하여 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;경계 값 분석 테스트&lt;/strong&gt;&lt;br /&gt;
등가분할 후 경계 값 부분에서 오류 발생 확률이 높기에 경계 값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;결정 테이블 테스트&lt;/strong&gt;&lt;br /&gt;
요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합하여 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;상태전이 테스트&lt;/strong&gt;&lt;br /&gt;
테스트 대상/시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;유스케이스 테스트&lt;/strong&gt;&lt;br /&gt;
시스템이 실제 사용되는 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화하여 수행하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;분류트리 테스트&lt;/strong&gt;&lt;br /&gt;
SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;페어와이즈 테스트&lt;/strong&gt;&lt;br /&gt;
Test data 값들 간에 최소한 한 번씩을 조합하는 방식이며, 이는 커버해야 할 기능적 범위를 모든 조합에 비해 상대적으로 적은 양의 테스트 세트를 구성하기 위한 테스트 기법&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-시각에-따른-분류&quot;&gt;테스트 시각에 따른 분류&lt;/h3&gt;

&lt;h4 id=&quot;검증verification&quot;&gt;검증(Verification)&lt;/h4&gt;
&lt;p&gt;　소프트웨어 과정을 테스트&lt;/p&gt;

&lt;h4 id=&quot;확인validation&quot;&gt;확인(Validation)&lt;/h4&gt;
&lt;p&gt;　소프트웨어 결과를 테스트&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-목적에-따른-분류&quot;&gt;테스트 목적에 따른 분류&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
ㆁ &lt;strong&gt;회복 테스트&lt;/strong&gt;&lt;br /&gt;
시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여부를 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;안전 테스트&lt;/strong&gt;&lt;br /&gt;
소스 코드 내의 보안적인 결함을 미리 점검하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;강도 테스트&lt;/strong&gt;&lt;br /&gt;
시스템 과부하 시에도 정상 작동되는지를 검증하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;성능 테스트&lt;/strong&gt;&lt;br /&gt;
이벤트에 응답하는 시간, 처리하는 업무량 등을 측정하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;구조 테스트&lt;/strong&gt;&lt;br /&gt;
시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;회귀 테스트&lt;/strong&gt;&lt;br /&gt;
오류를 제거하거나 수정한 시스템에서 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지 확인하는 일종의 반복 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;병행 테스트&lt;/strong&gt;&lt;br /&gt;
변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과를 비교하는 테스트 기법&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-오라클&quot;&gt;테스트 오라클&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참 값을 입력하여 비교하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;참 오라클&lt;/strong&gt;&lt;br /&gt;
모든 입력값에 대하여 기대하는 결과를 생성함으로써 발생된 오류를 모두 검출할 수 있는 오라클&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;샘플링 오라클&lt;/strong&gt;&lt;br /&gt;
특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;휴리스틱 오라클&lt;/strong&gt;&lt;br /&gt;
샘플링 오라클을 개선한 오라클로, 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;일관성 검사 오라클&lt;/strong&gt;&lt;br /&gt;
애플리케이션 변경이 있을 때, 수행 전과 후의 결괏값이 동일한지 확인하는 오라클&lt;/p&gt;</content><category term="test" /><summary>Software Test by 수제비</summary></entry></feed>
