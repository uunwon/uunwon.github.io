<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.6.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-09-16T14:07:32+09:00</updated><id>http://localhost:4000/</id><title>UUNWON</title><subtitle>Student at Korea Polytechnic University</subtitle><entry><title>[Jump to Java] Multiples of 3 and 5</title><link href="http://localhost:4000/Jump-to-Java2/" rel="alternate" type="text/html" title="[Jump to Java] Multiples of 3 and 5" /><published>2020-09-16T00:00:00+09:00</published><updated>2020-09-16T00:00:00+09:00</updated><id>http://localhost:4000/Jump-to-Java2</id><content type="html" xml:base="http://localhost:4000/Jump-to-Java2/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;multiples-of-3-and-5&quot;&gt;Multiples of 3 and 5&lt;/h2&gt;
&lt;h3 id=&quot;by-jump-to-java&quot;&gt;by Jump-to-Java&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;프로젝트 오일러에서 제공하는 첫번째 퀴즈,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;10 미만의 자연수에서 3과 5의 배수를 구하면 3, 5, 6, 9이다. 이들의 총합은 23이다. 1000미만의 자연수에서 3, 5의 배수의 총합을 구하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p class=&quot;notice&quot;&gt;
public class multiplesof3and5{ &lt;br /&gt;
　　int max; &lt;br /&gt;
    &lt;br /&gt;
　　public multiplesof3and5(int max){ &lt;br /&gt;
　　　　this.max = max; &lt;br /&gt;
　　} &lt;br /&gt;
　　&lt;br /&gt;
　　public int sum(){ &lt;br /&gt;
　　　　int sum = 0; &lt;br /&gt;
　　　　for(int i = 0;i &amp;lt; max;i++){ &lt;br /&gt;
　　　　　　if((i % 3 == 0) || (i % 5) == 0){ &lt;br /&gt;
　　　　　　　　sum += i; &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　} &lt;br /&gt;
　　　　return sum; &lt;br /&gt;
　　} &lt;br /&gt;
    &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　System.out.println(new multiplesof3and5(10).sum()); &lt;br /&gt;
　　　　System.out.println(new multiplesof3and5(1000).sum()); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://wikidocs.net/237, 점프 투 자바&lt;/p&gt;</content><category term="java" /><category term="code" /><summary></summary></entry><entry><title>[Jump to Java] Multiplication table</title><link href="http://localhost:4000/Jump-to-Java/" rel="alternate" type="text/html" title="[Jump to Java] Multiplication table" /><published>2020-09-15T00:00:00+09:00</published><updated>2020-09-15T00:00:00+09:00</updated><id>http://localhost:4000/Jump-to-Java</id><content type="html" xml:base="http://localhost:4000/Jump-to-Java/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;multiplication-table&quot;&gt;Multiplication table&lt;/h2&gt;
&lt;h3 id=&quot;by-jump-to-java&quot;&gt;by Jump-to-Java&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;구구단을 구현해보자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class multiplicationTable{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(Sysete.in); &lt;br /&gt;
　　　　int num; &lt;br /&gt;
&lt;br /&gt;
　　　　System.out.println(&quot;원하는 구구단은? &quot;); &lt;br /&gt;
　　　　num = sc.nextInt(); &lt;br /&gt;
&lt;br /&gt;
　　　　for(int i = 0;i &amp;lt; 9;i++){ &lt;br /&gt;
　　　　　　System.out.print((num * (i+1)) + &quot; &quot;); &lt;br /&gt;
　　　　} &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;　💌 사이트의 소스에서 &lt;strong&gt;toString()&lt;/strong&gt; 부분을 눈여겨보자. toString이 클래스 내에 선언되면 특별한 의미를 갖게 된다. new 키워드로 생성한 객체를 System.out.println 같은 걸로 출력했을 때 toString 메소드가 구현되어 있을 경우 toString) 메소드를 수행한 결과값을 리턴하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://wikidocs.net/236, 점프 투 자바&lt;/p&gt;</content><category term="java" /><category term="code" /><summary></summary></entry><entry><title>Android Layout</title><link href="http://localhost:4000/Android-Layout/" rel="alternate" type="text/html" title="Android Layout" /><published>2020-09-03T00:00:00+09:00</published><updated>2020-09-03T00:00:00+09:00</updated><id>http://localhost:4000/Android-Layout</id><content type="html" xml:base="http://localhost:4000/Android-Layout/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;안드로이드-레이아웃&quot;&gt;안드로이드 레이아웃&lt;/h2&gt;

&lt;p&gt;　안드로이드 UI 프로그램에서 화면 구성을 위한 뷰 클래스도 중요하지만, 해당 뷰들을 화면에 어떻게 배치할 것인가도 중요하다. 뷰를 적절하게 배치하는 데 사용하는 레이아웃 클래스를 살펴보자. 레이아웃 클래스는 화면에 출력되는 대상이지만, 자체 UI는 갖지 않는다. 레이아웃 클래스는 Button 같은 뷰들을 자신에게 포함(Add)하고 적절하게 배치해 화면에 한꺼번에 출력한다.&lt;/p&gt;

&lt;p&gt;　레이아웃 클래스마다 포함된 뷰의 정렬 규칙이 다른 것이지, 특정 화면을 특정 레이아웃으로만 구성할 수 있는 건 아니다. 화면을 작성할 때 무조건 특정 레이아웃을 사용해야 완성할 수 있는 경우도 있지만, 대부분 개발자의 선택에 따른다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;레이아웃-종류&quot;&gt;레이아웃 종류&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;LinearLayout&lt;/li&gt;
  &lt;li&gt;RelativeLayout&lt;/li&gt;
  &lt;li&gt;FrameLayout&lt;/li&gt;
  &lt;li&gt;TableLayout&lt;/li&gt;
  &lt;li&gt;GridLayout&lt;/li&gt;
  &lt;li&gt;ConstraintLayout&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-linearlayout&quot;&gt;📱 LinearLayout&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　가장 많이 이용되는 레이아웃 중 하나가 LinearLayout 이다. 이는 해당 레이아웃에 포함된 뷰를 순서대로 가로나 세로 방향으로 나열한다. 따라서 다른 레이아웃에서는 없는 방향을 지정하는 orientation 속성을 제공한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;기본적으로 레이아웃에서 뷰의 위치는 왼쪽 위이다. 뷰의 정렬과 관련된 속성은 &lt;strong&gt;gravity&lt;/strong&gt;(뷰의 내용을 뷰 영역 내 어디에 나타낼지)와 &lt;strong&gt;layout_gravity&lt;/strong&gt;(뷰를 LinearLayout 영역 내 어디에 나타낼지)로 다룰 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;weigh&lt;/strong&gt; 속성은 이용 빈도가 높은 속성이다. 여백과 관련이 있는 속성으로, 레이아웃에 뷰를 배치하다 보면 가로나 세로 방향으로 여백이 발생할 수 있다. 이 여백을 화면에 배치된 뷰들이 확장해서 차지하게 할 때 이용된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-relativelayout&quot;&gt;📲 RelativeLayout&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　RelativeLayout은 화면에 이미 배치된 뷰를 기준으로 다른 뷰의 위치를 지정하는 레이아웃이다. 예를 들어, RelativeLayout에 Button을 포함한 후 다른 Button을 포함하면, 이전 Button 위에 덮어쓰듯이 올라가게 된다. 이때 가로세로 방향의 orientation을 생각할 수 있는데, orientation 속성은 LinearLayout에만 지정할 수 있다. RelativeLatout에서 &lt;strong&gt;상대 위치를 지정하는 속성&lt;/strong&gt;은 다음 4가지가 있다. 이 4가지 속성값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;기준 뷰의 id&lt;/code&gt;이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;android:layout_above: 기준 뷰의 윗부분에 배치 &lt;br /&gt; android:layout_below: 기준 뷰의 아랫부분에 배치 &lt;br /&gt; android: layout_toLeftOf: 기준 뷰의 왼쪽에 배치 &lt;br /&gt; android: layout_toRightOf: 기준 뷰의 오른쪽에 배치&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　위와 같은 속성뿐 아니라, 기준이 되는 뷰와 왼쪽 변을 맞추거나 윗변을 맞추는 등의 작업도 중요하다. 이 부분을 지원하기 위한 속성이 align이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;android:layout_alignTop: 기준 뷰와 윗부분을 정렬 &lt;br /&gt; android:layout_alignBottom: 기준 뷰와 아랫부분을 정렬 &lt;br /&gt; android:layout_alignLeft: 기준 뷰와 왼쪽을 정렬 &lt;br /&gt; android:layout_alignRight: 기준 뷰와 오른쪽을 정렬 &lt;br /&gt; android:layout_alignBaseline: 기준 뷰와 텍스트 기준선을 정렬&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-framelayout&quot;&gt;📳 FrameLayout&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　FrameLayout은 레이아웃에 포함된 뷰들을 같은 영역에 겹쳐서 배치할 때 사용한다. 레이아웃 자체의 특별한 속성은 없다. 이를 이용하는 목적은 대부분 같은 영역에 여러 뷰를 겹치게 한 다음, 한 순간에 하나의 뷰만 보이기 위함이다. 이를 위해 visibility 속성으로 특정 순간에 뷰가 보이거나 보이지 않게 제어하면 된다.&lt;/p&gt;

&lt;p class=&quot;notice_info&quot;&gt;TabHost: 탭 화면은 화면 여러 개를 준비한 다음, 사용자가 버튼을 누를 때 버튼과 연결된 화면을 하나씩 보여주는 형태로 TabHost 클래스를 사용해 작업을 더 쉽게 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-tablelayout&quot;&gt;📴 TableLayout&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　TableLayout은 뷰를 테이블 구조로 나열하는 레이아웃이다. 레이아웃 내에 하나의 뷰가 여러 셀을 차지하게 할 수도 있으며, 여백이 발생할 경우 특정 열(column)을 확장할 수도 있고, 화면 크기를 벗어나는 순간 특정 열을 축소하는 등 다양하게 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-gridlayout&quot;&gt;📱 GridLayout&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　GridLayout은 뷰를 테이블 구조로 나열한다. 이는 뷰가 테이블 구조로 나열된다는 점에서 TableLayout과 유사하고, 뷰가 레이아웃에 포함된 순서대로 가로나 세로 방향으로 나열된다는 점에서 LinearLayout과도 유사하다. 또한, LinearLayout에는 없는 자동 개행 능력도 있어 화면에는 TableLayout처럼 보이기도 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TableLayout이 있는데, GridLayout을 사용하는 이유? &lt;br /&gt; TableLayout은 각 행을 TalbeRow로 묶어주어야 하므로, 셀의 개수를 예상할 수 없거나 가변적일 때는 화면 구성이 복잡해진다. 하지만 GridLayout은 별도로 행을 표현하지 않아도 뷰를 순서대로 포함만 하면 알아서 개행하여 행이 자동으로 표현되므로 편리한 측면이 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;orientation: 뷰의 배치 방향을 지정. 기본값은 가로 방향 &lt;br /&gt; columnCount: 가로 방향일 때 한 줄에 몇 개의 뷰를 나열할 것인지 지정 &lt;br /&gt; rowCount: 세로 방향일 떄 한 줄에 몇 개의 뷰를 나열할 것인지 지정&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-constraintlayout&quot;&gt;📲 ConstraintLayout&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　ConstraintLayout은 안드로이드 2.3 버전부터는 XML 파일을 만들면 기본으로 지정되는 레이아웃이다. 이는 RelativeLayout과 상당히 유사하다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;상대적 위치 지정: app: layout_constraintLeft_toRightOf &lt;br /&gt; 여백(margin): android:layout_marginStart &lt;br /&gt; 가운데 맞춤과 치우침(bias): app: layout_constraintHorizontal_bias &lt;br /&gt; 비율(ratio): app: layout_constraintDimensionRatio&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;깡쌤의 안드로이드 프로그래밍, 루비페이퍼 &lt;br /&gt;
RelativeLayout: https://recipes4dev.tistory.com/126&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary></summary></entry><entry><title>Android LifeCycle</title><link href="http://localhost:4000/Android-Lifecycle/" rel="alternate" type="text/html" title="Android LifeCycle" /><published>2020-08-28T00:00:00+09:00</published><updated>2020-08-28T00:00:00+09:00</updated><id>http://localhost:4000/Android-Lifecycle</id><content type="html" xml:base="http://localhost:4000/Android-Lifecycle/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;액티비티-생명주기&quot;&gt;액티비티 생명주기&lt;/h2&gt;

&lt;p&gt;　안드로이드에서 화면이 아닌 액티비티 자체가 어떤 원리로 수행되는지 살펴보자. 액티비티를 실행하는 주체는 안드로이드 시스템이므로 시스템에서 액티비티 생명주기 (life cycle) 을 어떻게 관리하며, 그때 개발자 코드에서 신경 써야 하는 부분은 무엇인지 알아본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;액티비티-상태&quot;&gt;액티비티 상태&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;활성 상태(activity running): 현재 액티비티가 화면을 점유하여 출력되고 있으며 사용자 이벤트 처리가 정상으로 처리되는 상태&lt;/li&gt;
  &lt;li&gt;일시 정지 상태(pause): 현재 액티비티가 일시적으로 사용이 불가능한 상태&lt;/li&gt;
  &lt;li&gt;비활성 상태(stop): 현재 액티비티가 다른 액티비티로 인해 화면이 완벽하게 가려진 상태&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-활성-상태&quot;&gt;👋🏻 활성 상태&lt;/h3&gt;

&lt;p&gt;　액티비티가 사용자 화면에 보이고 있으며 포커스를 가지고 있어 사용자 이벤트에 반응할 수 있는 상태이다. 생성된 액티비티는 onCreate() -&amp;gt; onStart() -&amp;gt; onResume() 함수가 호출되면서 활성 상태가 된다. 일반적으로 setContentView() 함수를 이용해 액티비티 화면을 출력한다고 하지만, 정확하게는 setContentView() 함수가 호출되는 시점이 화면 출력 순간이 아니라, &lt;strong&gt;onResume() 함수까지 실행하고, setContentView() 함수에서 출력한 내용이 화면에 나오는 구조이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　따라서 onResume() 함수가 실행되기까지 setContentView() 함수를 onCreate(), onStart(), onResume() 등 어디선가 호출해 주면 화면에 잘 나온다. 반대로 onResume() 함수가 호출될 때까지 setContentView() 함수가 한 번도 호출되지 않는다면, 화면에 아무것도 나오지 않는다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;-일시-정지-상태&quot;&gt;🤏🏻 일시 정지 상태&lt;/h3&gt;

&lt;p&gt;　일시 정지 상태는 액티비티가 여전히 화면에 보이지만, 포커스를 잃은 상태이다. 대표적인 예시로 다른 액티비티가 화면 전체를 가리지 않고 실행된 때이다. 다른 액티비티가 반투명하게 실행되거나 다이얼로그 스타일로 실행되어 여전히 자신이 화면에 보이지만, 포커스를 잃은 상태이다. 이때, onPause() 함수가 자동으로 호출된다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;-비활성-상태&quot;&gt;👊🏻 비활성 상태&lt;/h3&gt;

&lt;p&gt;　비활성 상태는 다른 액티비티로 인해 화면이 완전히 가려진 상태이다. 보통 다른 액티비티로 화면이 전환되어 안 보이는 경우다. 이때는 onPause() -&amp;gt; onStop() 함수까지 호출된다.&lt;/p&gt;

&lt;p&gt;　화면을 가렸던 액티비티가 뒤로가기 비활성 상태에서 뒤로가기 버튼 등으로 화면을 가렸던 액티비티가 사라지면 다시 활성 상태로 전환되는데, 이때는 onRestart() -&amp;gt; onStart() -&amp;gt; onResume() 함수가 차례로 호출된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;액티비티-상태-저장&quot;&gt;액티비티 상태 저장&lt;/h2&gt;

&lt;p&gt;　액티비티의 상태 관리를 위해 데이터를 저장했다가 복원하는 데 사용되는 함수는 onCreate(), onRestoreInstanceState(), onSaveInstanceState() 이다. 우선 액티비티가 종료되는 상항에 대비해 액티비티의 데이터를 저장해야 한다면 &lt;strong&gt;onSaveInstanceState()&lt;/strong&gt; 함수를 사용한다. 이는 onPause() 함수 호출 후 자동으로 호출되며, 이 함수에서 액티비티의 데이터를 저장한다.&lt;/p&gt;

&lt;p&gt;　저장하는 방법은 매개변수로 전달되는 Bundle을 이용하면 된다. Bundle은 컴포넌트의 데이터를 저장하기 위한 일종의 Map 객체이며, 이 객체에 데이터를 key-value로 담아주면 내부적으로 파일로 저장해줌으로써 액티비티가 종료되더라도 데이터는 유실되지 않는다. 이렇게 저장한 데이터를 액티비티가 다시 시작되는 시점에 가져와서 이용할 수 있다. 이 작업에는 onCreate()와 onRestoreInstanceState() 함수를 이용한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;깡쌤의 안드로이드 프로그래밍, 루비페이퍼 &lt;br /&gt;&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary></summary></entry><entry><title>Android Post List</title><link href="http://localhost:4000/Android-List/" rel="alternate" type="text/html" title="Android Post List" /><published>2020-08-27T00:00:00+09:00</published><updated>2020-08-27T00:00:00+09:00</updated><id>http://localhost:4000/Android-List</id><content type="html" xml:base="http://localhost:4000/Android-List/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;리스트&quot;&gt;리스트&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;기초 뷰 활용 p114&lt;/li&gt;
  &lt;li&gt;레이아웃 종류 p136&lt;/li&gt;
  &lt;li&gt;스마트폰 크기 호환성 p234&lt;/li&gt;
  &lt;li&gt;데이터 영속화 SQLite p257&lt;/li&gt;
  &lt;li&gt;WebView p346&lt;/li&gt;
  &lt;li&gt;인텐트 p437&lt;/li&gt;
  &lt;li&gt;액티비티 생명주기 p477&lt;/li&gt;
  &lt;li&gt;Fragment p553&lt;/li&gt;
  &lt;li&gt;RecyclerView p589&lt;/li&gt;
  &lt;li&gt;위치 정보 LocationManager p777&lt;/li&gt;
  &lt;li&gt;HTTP 통신 - Java Volley API, Retrofit2 p859&lt;/li&gt;
  &lt;li&gt;코틀린 p1049&lt;/li&gt;
&lt;/ul&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary></summary></entry><entry><title>Start Android</title><link href="http://localhost:4000/Android/" rel="alternate" type="text/html" title="Start Android" /><published>2020-08-23T00:00:00+09:00</published><updated>2020-08-23T00:00:00+09:00</updated><id>http://localhost:4000/Android</id><content type="html" xml:base="http://localhost:4000/Android/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;안드로이드&quot;&gt;안드로이드&lt;/h2&gt;

&lt;p&gt;안드로이드는 휴대 전화를 비롯한 휴대용 장치를 위한 운영 체제와 미들웨어, 사용자 인터페이스 그리고 표준 응용 프로그램, 웹 브라우저, 이메일 클라이언트, 단문 메시지 서비스(SMS), MMS 등을 포함하고 있는 소프트웨어 스택이자 모바일 운영 체제이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;안드로이드-특징&quot;&gt;안드로이드 특징&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;안드로이드는 공개 운영체제인 리눅스 기반이다.&lt;/li&gt;
  &lt;li&gt;안드로이드 앱 개발은 자바 및 코틀린을 이용해 개발한다.&lt;/li&gt;
  &lt;li&gt;운영체제의 핵심 코드, 라이브러리 코드, 스마트폰에 기본으로 탑재된 구글에서 만든 앱 코드 등 대부분 코드가 오픈되어 있다.&lt;/li&gt;
  &lt;li&gt;안드로이드 플랫폼 기반의 스마트폰을 여러 제조업체에서 만들 수 있다.&lt;/li&gt;
  &lt;li&gt;개발자가 만든 앱은 구글 Play 스토어뿐만 아니라 다양한 방법으로 사용자에게 배포할 수 있다.&lt;/li&gt;
  &lt;li&gt;안드로이드 기반의 모든 애플리케이션은 평등하다는 사상으로 스마트폰에 기본 탑재된 앱과 개발자들이 만드는 앱이 같은 환경에서 같은 API를 이용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;컴포넌트-기반-개발&quot;&gt;컴포넌트 기반 개발&lt;/h2&gt;

&lt;p&gt;안드로이드 앱의 아키텍처에서 가장 큰 특징은 컴포넌트 기반이라는 것이다. 컴포넌트는 앱의 구성 단위이다. 즉, 안드로이드 앱을 작성한다는 건 컴포넌트를 작성한다는 것이고, 개발자가 작성한 여러 컴포넌트를 조합하여 하나의 앱을 완성한다.&lt;/p&gt;

&lt;p&gt;안드로이드 컴포넌트는 4가지 종류가 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;액티비티&lt;/strong&gt; : UI를 구성하기 위한 컴포넌트&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;서비스&lt;/strong&gt; : UI 없이 백그라운드에서 장시간 수행되는 컴포넌트&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;콘텐츠 프로바이더&lt;/strong&gt; : 애플리케이션 간 데이터를 공유하기 위한 컴포넌트&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;브로드캐스트 리시버&lt;/strong&gt; : 이벤트 모델로 수행되는 컴포넌트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;깡쌤의 안드로이드 프로그래밍, 루비페이퍼 &lt;br /&gt;&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary></summary></entry><entry><title>Linux and Unix</title><link href="http://localhost:4000/Linux-Unix/" rel="alternate" type="text/html" title="Linux and Unix" /><published>2020-08-10T00:00:00+09:00</published><updated>2020-08-10T00:00:00+09:00</updated><id>http://localhost:4000/Linux-Unix</id><content type="html" xml:base="http://localhost:4000/Linux-Unix/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;os&quot;&gt;OS&lt;/h2&gt;

&lt;p&gt;　운영체제(OS: Operating System)은 컴퓨터의 주기억장치 내에 상주하면서 사용자와 컴퓨터 시스템 사이의 인터페이스를 담당하여 컴퓨터 시스템의 전반적인 동작을 제어하고 조정하며, 사용자에게 편리성을 제공하고 한정된 시스템 자원을 효율적으로 사용할 수 있도록 관리하는 여러 시스템 프로그램들의 집합을 말한다. 즉 운영체제를 구성하는 프로그램들은 하드웨어와 응용프로그램 간의 인터페이스 역할을 하면서 중앙처리장치(CPU), 주기억장치, 입출력장치, 파일 시스템 등의 컴퓨터 자원을 관리한다.&lt;/p&gt;

&lt;p&gt;　운영체제의 종류는 매우 다양한데 컴퓨터의 용량에 따라 구분하여 개인용 컴퓨터와 중대형 컴퓨터로 그 종류를 살펴볼 수 있다. 개인용 컴퓨터에 이용하는 대표적인 운영체제로는 마이크로소프트의 윈도우 계열의 운영체제와 리눅스(Linux) 등이 있다. 중대형 컴퓨터에서 사용하는 운영체제는 유닉스(Unix) 계열의 운영체제가 주종을 이루고 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;linux&quot;&gt;Linux&lt;/h2&gt;

&lt;p&gt;　리눅스(Linux)는 핀란드의 리누스 토발즈(Linus Torvalds)에 의하여 개발된 유닉스(Unix) 기반의 운영체제이다. 이는 개인용 컴퓨터에 적합한 적합한 공개용 운영체제다. 리누스 토발즈는 소스 코드를 인터넷에 공개해 모든 사람이 자유롭게 사용할 수 있도록 하고 일반인들이 직접 리눅스의 개선에도 참여할 수 있도록 하였다.&lt;/p&gt;

&lt;p&gt;　리눅스는 무료 소프트웨어라는 장점과 유닉스에 기반한 매우 안정적인 운영체제라는 점에 급속히 확산되었다. 이는 인터넷 프로토콜인 TCP/IP를 강력하게 지원하는 등 네트워크 기능이 강화되었고, 다중 사용자, 다중 프로그래밍 방식을 지원하는 안정성 있는 운영체제이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;unix&quot;&gt;Unix&lt;/h2&gt;

&lt;p&gt;　유닉스(Unix)는 벨 연구소의 멀틱스 운영체제 팀에서 개발한 운영체제이다. 1973년 새로 개발한 언어 C를 이용하여 시스템 PDP=11을 위해 만들어졌다. 이는 다른 시스템에도 쉽게 적용하여 운영할 수 있는 이식성이 좋은 운영체제로 유명하다.&lt;/p&gt;

&lt;p&gt;　유닉스 운영체제를 구성하는 주요 요소로 커널(Kernel)과 쉘(Shell)이 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;커널&lt;/code&gt;은 운영체제의 가장 핵심이 되는 모듈로 CPU와 주기억장치를 관리하고 시스템 호출을 처리하며 주변장치를 관리하는 기능을 포함한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;쉘&lt;/code&gt;은 표준 UNIX 명령 인터프리터로서 사용자가 입력한 명령을 해석하여 그에 맞는 다른 프로그램을 실행시키는 유틸리티 프로그램이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;모바일 시대의 컴퓨터개론, INFINITY BOOKS&lt;/p&gt;</content><category term="computer" /><category term="linux" /><category term="unix" /><summary></summary></entry><entry><title>DBMS(DataBase Management System)</title><link href="http://localhost:4000/DBMS/" rel="alternate" type="text/html" title="DBMS(DataBase Management System)" /><published>2020-08-10T00:00:00+09:00</published><updated>2020-08-10T00:00:00+09:00</updated><id>http://localhost:4000/DBMS</id><content type="html" xml:base="http://localhost:4000/DBMS/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;database&quot;&gt;Database&lt;/h2&gt;

&lt;p&gt;　데이터베이스(Database)는 간단히 ‘관련 있는 데이터의 저장소’라고 볼 수 있다. 자세히 말해, 데이터베이스는 여러 사람이나 응용시스템에 의해 참조 가능하도록 서로 논리적으로 연관되어 통합 관리되는 데이터의 모임이다. 데이터베이스에 저장된 자료는 데이터를 추가하고, 공유하고, 찾고, 정렬하는 등의 여러 조작을 통하여 정보로 활용될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;dbms&quot;&gt;DBMS&lt;/h2&gt;

&lt;p&gt;　데이터베이스 관리시스템(DBMS: DataBase Management System)은 사용자가 데이터베이스를 만들고, 유지 관리할 수 있도록 돕는 프로그램을 말한다. 데이터와 응용 프로그램 사이에서 중재자 역할을 하며 모든 프로그램들이 데이터베이스를 유용하여 활용할 수 있도록 관리해 주는 소프트웨어이다. DBMS의 종류를 살펴보면 Oracle, DB2, Sybase, Ingres, Postgres, mSQL, MySql, SQL Server 등 매우 다양하다.&lt;/p&gt;

&lt;p&gt;　즉, 데이터베이스는 ‘관련 있는 데이터의 저장소’이고, 데이터베이스 관리시스템은 ‘데이터베이스를 관리하는 소프트웨어’이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-mysql&quot;&gt;🗄 MySQL&lt;/h2&gt;

&lt;p&gt;　MySQL은 대표적인 오픈 소스 DBMS 제품으로 데이터베이스 시스템을 공부하는 학생들에게 아주 인기가 좋은 DBMS이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;내부 구성 및 이식성: C 및 C++로 기술되었고, 다양한 플랫폼에서 동작한다.&lt;/li&gt;
  &lt;li&gt;보안: 매우 유연하고 안전한 특권 및 패스워드 시스템이다.&lt;/li&gt;
  &lt;li&gt;확장성과 범위: 대규모 데이터베이스를 처리한다.&lt;/li&gt;
  &lt;li&gt;접속성: 클라이언트는 모든 플랫폼에서 TCP/IP 소켓을 사용해 MySQL 서버에 접속할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-oracle&quot;&gt;🗄 Oracle&lt;/h2&gt;

&lt;p&gt;　오라클 사에서 개발한 오라클은 관계 데이터베이스 관계 시스템(RDBMS)의 이름으로, 유닉스 환경에서 사용되는 RDBMS로는 가장 널리 사용되는 대표적인 제품 중 하나이다. 검색ㆍ갱신용 언어로는 국제 표준화 기구(ISO)에서 표준화한 구조화 조회 언어(SQL)가 표준이 되어 있다. 오라클은 인터넷의 성장과 함께 기업용 대규모 데이터베이스 시스템의 DBMS로 자리잡았다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-sqlite&quot;&gt;🗄 SQLite&lt;/h2&gt;

&lt;p&gt;　스마트폰, 태블릿과 같은 다양한 모바일 기기의 보금에 따라 모바일 기기에 기본적으로 탑재되는 작지만 빠른 개인용 임베디드 데이터베이스 엔진이 많이 활용되고 있다. 대표적인 데이터베이스 엔진이 SQLite 이다. 이는 데이터베이스 엔진을 위한 소프트웨어 라이브러리로, iOS와 안드로이드 등 모바일 환경에 많이 내장되어 사용되고 있다.&lt;/p&gt;

&lt;p&gt;　SQLite는 리차드 힙(Richard Hipp)이 DBMS를 사용하지 않고 활용할 수 있는 데이터베이스 엔진으로 개발하였으며, C로 구현되어 용량이 작고 가벼우면서도 안정적이며, 서버가 따로 필요하지 않아 시스템의 임베디드 데이터베이스로 많이 활용되고 있다.&lt;/p&gt;

&lt;h3 id=&quot;-android-sqlite&quot;&gt;* Android SQLite&lt;/h3&gt;

&lt;p&gt;　안드로이드에서는 어플리케이션의 효과적인 데이터 관리를 위하여 구조화된 내부 SQL Database인 SQLite Database를 지원하고 있습니다. 어플리케이션 사용 과정에서 발생하는 용량이 크지 않은 데이터들은 굳이 서버에 접속하는 수고를 들이지 않고 내부 데이터베이스를 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;모바일 시대의 컴퓨터개론, INFINITY BOOKS &lt;br /&gt;
모바일 SQLite: https://m.blog.naver.com/nife0719/221035148567&lt;/p&gt;</content><category term="computer" /><category term="database" /><summary></summary></entry><entry><title>Object Oriented Programming</title><link href="http://localhost:4000/Object-Oriented-Programming/" rel="alternate" type="text/html" title="Object Oriented Programming" /><published>2020-08-07T00:00:00+09:00</published><updated>2020-08-07T00:00:00+09:00</updated><id>http://localhost:4000/Object-Oriented-Programming</id><content type="html" xml:base="http://localhost:4000/Object-Oriented-Programming/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;객체지향-프로그래밍&quot;&gt;객체지향 프로그래밍&lt;/h2&gt;

&lt;p&gt;　고급 언어 중에서 프로그램 방식으로 언어를 분류하면 주로 절차지향(procedural) 언어와 객체지향(object oriented) 언어로 나뉜다. 절차지향이 동사 중심이라면 객체 지향은 명사 중심의 프로그래밍 방식이다. 절차지향 언어는 문제를 여러 개의 작은 함수로 나누어 그 문제를 해결하는 반면에 객체지향 언어는 문제를 구성하는 객체를 만들어 이 객체들 간의 메시지 교환으로 그 문제를 해결한다.&lt;/p&gt;

&lt;p&gt;　객체(object)란 현실 세계의 사물이나 개념을 시스템에서 이용하기 위해 현실 세계를 자연스럽게 표현하여 손쉽게 이용할 수 있도록 만든 소프트웨어 모델이다. 객체는 속성(attributes, properties)과 행동(messages, behaviors)으로 구성된다. 속성은 객체의 특성을 표현하는 정적인 성질이며, 행동은 객체 내부의 일을 처리하거나 객체들 간에 서로 영향을 주고받는 동적인 일을 처리하는 단위이다.&lt;/p&gt;

&lt;p&gt;　객체는 시스템에서 이용되는 공학적인 규칙을 가질 수 있으나 그 규칙은 일상 생활의 모델링에서 나온 규칙이므로 누구나 손쉽게 이해할 수 있는 요소를 갖는다. 이 모델링 과정에서 객체지향 특징인 추상화(abstraction), 상속성(inheritance), 캡슐화(encapsulation), 다형성(polymorphism)을 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;절차지향&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;객체지향&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;프로그래밍방식&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;동사&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;명사&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;모듈단위&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;함수 또는 프로시저&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;속성과 행동을 표현한 객체&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;언어&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;FORTRAN, BASIC, COBOL, PASCAL, C 등&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Object Pascal, Visual Basic, C#, C++, Java 등&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;자바&quot;&gt;자바&lt;/h2&gt;

&lt;p&gt;　자바의 시초는 가전제품들을 제어하기 위해 고안한 언어에서부터 비롯되었기에, 작은 메모리와 느린 CPU와는 상관없이 효율적으로 작동하여야 했고 그 결과 운영체제나 CPU와는 독립적으로 실행 가능한 프로그래밍 언어가 개발되었다. 1995년 공식 발표되었으며 프로그래밍 언어 C++을 기반으로 한 객체지향 프로그래밍 언어이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인터넷 응용 시스템 개발을 위한 이상적인 프로그래밍 언어&lt;/li&gt;
  &lt;li&gt;C++ 기반으로 만들어진 배우기 쉽고, 이용하기 간편한 객체지향 언어&lt;/li&gt;
  &lt;li&gt;플랫폼에 독립적인 언어 - 자바 프로그램의 실행은 운영체제의 자바 가상 머신 위에서 인터프리터 방식으로 동작하므로 프로그램의 속도가 떨어진다는 단점이 있다. 이 자바 가상 기계가 각종 플랫폼에 소프트웨어나 하드웨어로 존재하여 그 플랫폼에서 바이트코드가 실행될 수 있도록 하는 역할을 담당한다.&lt;/li&gt;
  &lt;li&gt;이식성이 높고, 다중 스레드를 지원한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice&quot;&gt;
package jump2java; &lt;br /&gt;
&lt;br /&gt;
public class HelloWorld{ &lt;br /&gt;
　　publice static void main(String[] args){ &lt;br /&gt;
　　　　System.out.println(&quot;Hello, world!&quot;); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;c&quot;&gt;C#&lt;/h2&gt;

&lt;p&gt;　C#은 모든 것을 객체로 취급하는 컴포넌트 프로그래밍 언어이다. 이는 자바와 C++에 기본을 둔 언어로 자바와 매우 비슷하다. 또한 웹을 통해 정보와 서비스를 교환하고, 개발자들이 이식성 높은 응용프로그램들을 만들어낼 수 있게 고안되었다. C#으로 작성한 코드가 컴파일되면 중간 언어인 MSIL이 되고, 이 중간 언어가 인터프리터인 CLR에 의해 실행되므로 C#은 시스템에 독립적인 프로그램 개발이 가능하다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
using System; &lt;br /&gt;
&lt;br /&gt;
class HelloWorld{ &lt;br /&gt;
　　static void Main(string[] args){ &lt;br /&gt;
　　　　Console.WriteLine(&quot;Hello, world!&quot;); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;파이썬&quot;&gt;파이썬&lt;/h2&gt;

&lt;p&gt;　파이썬 언어는 현재 대학에서 컴퓨터 기초과목으로 가장 많이 가르치는 프로그래밍 중 하나이다. 파이썬은 간단하면서 효과적으로 객체지향을 적용할 수 있는 강력한 프로그래밍 언어이며, 인터프리터 언어로 간단한 문법구조를 가진 대화형 언어이다. 또한 동적 자료형을 제공하여, 변수를 선언하지 않고 사용할 수 있으며 여러 플랫폼에서 사용되는 다양한 영역에 활용될 수 있는 프로그램을 쉽고 빠르게 개발할 수 있다는 장점이 있다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
print(&quot;Hello World!&quot;);
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;모바일 시대의 컴퓨터개론, INFINITY BOOKS&lt;/p&gt;</content><category term="computer" /><category term="java" /><category term="c#" /><category term="python" /><summary></summary></entry><entry><title>High Level Programming Language</title><link href="http://localhost:4000/High-Level-Programming-Language/" rel="alternate" type="text/html" title="High Level Programming Language" /><published>2020-08-07T00:00:00+09:00</published><updated>2020-08-07T00:00:00+09:00</updated><id>http://localhost:4000/High-Level-Programming-Language</id><content type="html" xml:base="http://localhost:4000/High-Level-Programming-Language/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;고급-프로그래밍-언어&quot;&gt;고급 프로그래밍 언어&lt;/h2&gt;

&lt;p&gt;　고급 프로그래밍 언어란 사람이 이해하기 쉽게 작성된 프로그래밍 언어로서, 저급 프로그래밍 언어보다 가독성이 높고 다루기 간단하다는 장점이 있다. 컴파일러나 인터프리터에 의해 저급 프로그래밍 언어로 번역되어 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;포트란&quot;&gt;포트란&lt;/h2&gt;

&lt;p&gt;　포트란(FORTRAN)은 FoRmula TRANslating system(수식 번역 시스템)의 약자로서 과학과 공학 및 수학적 문제들을 해결하기 위해 1950년대 중반에 IBM 704 컴퓨터 시스템에 이용할 목적으로 고안한 3세대 프로그래밍 언어이다. 기본적인 수리 자료 처리와 계산을 위주로 만들어졌기 때문에 매우 간결하여 배우기가 용이하다. 그러나 배우기는 쉽지만 문법이 엄격하다는 애로 사항이 있다. 이는 가장 오래된 언어 중의 하나이지만 언어 구조가 단순해 지금도 기술 계산 분야 등에서는 사용되고 있다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
program HelloWorldF90 &lt;br /&gt;
　　write(*,*) &quot;Hello, Fortran!&quot; &lt;br /&gt;
end program HelloWorldF90 &lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;코볼&quot;&gt;코볼&lt;/h2&gt;

&lt;p&gt;　코볼은 포트란에 이어 두 번째로 개발된 고급 언어이며 기업의 사무 처리에 적합한 프로그래밍 언어로 개발되었다. 기업에서 다루는 데이터의 특성상 일정한 형식이 존재하므로 이러한 형식을 지원하므로써 대량의 데이터를 효율적으로 입력, 출력 및 처리할 수 있다. 사무처리에 목적이 있는 만큼 다른 프로그래밍 언어에 비하여 파일의 순차적인 처리 등이 효율적이다. 영어 구문과 비슷한 문장구조를 갖고 있으므로 쉽게 이해할 수 있도록 프로그램 작성이 가능하다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
000100 IDENTIFICATION DIVISION. &lt;br /&gt;
000200 PROGRAM-ID.　HELLOWORLD. &lt;br /&gt;
000300 &lt;br /&gt;
000400*
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;베이직&quot;&gt;베이직&lt;/h2&gt;

&lt;p&gt;　베이직(BASIC)은 초보자도 쉽게 배울 수 있도록 만들어진 대화형 프로그래밍 언어이다. 대화형의 영어 단어를 바탕으로 약 200여 개의 명령어들로 구성된 가장 쉬운 대화형 프로그래밍 언어여서 문장의 종류가 많지 않고 문법이 간단하며, 배우고 쓰기가 간단하고 쉽다. 인터프리터를 사용하므로 프로그램 작성 시 프로그램상의 문제점을 쉽게 파악할 수 있다. 그러나 인터프리터를 거쳐야 하므로 실행속도가 느리다는 단점이 있다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
10 PRINT &quot;Hello World!&quot;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;파스칼&quot;&gt;파스칼&lt;/h2&gt;

&lt;p&gt;　파스칼은 프랑스의 수학자인 파스칼(Pascal)의 이름에서 따온 언어로서 프로그램을 작성하는 방법인 알고리즘 학습에 적합하도록 개발된 프로그래밍 언어이다. 교육용으로 제작된 프로그래밍 언어이기 때문에 알고리즘의 실험이나 프로그램을 연습할 수 있는 모든 명령어가 갖추어져 있다. 또한 비교적 자유로운 구조를 가질 수 있는 다른 프로그래밍 언어와는 달리 구조적인 프로그래밍이 가능하도록 설계되어 있다. 1980년에서 1990년대까지 대부분의 대학에서 프로그래밍 언어의 교과과정으로 채택되었으며, 파스칼 기반의 통합개발환경인 델파이를 출시해 현재까지도 널리 이용하고 있다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
program HelloWorld; &lt;br /&gt;

begin &lt;br /&gt;
　　writeln('Hello World!'); &lt;br /&gt;
end.
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;c&quot;&gt;C&lt;/h2&gt;

&lt;p&gt;　C 언어는 운영체제 유닉스(Unix)를 개발하기 위한 시스템 프로그래밍 언어로 벨 연구소의 데니스 리치가 개발하였다. C언어는 프로그램을 기계어 명령에 가까운 형태로 작성할 수 있으므로 다른 고급 언어에 비해 하드웨어에 대한 보다 확실한 통제가 가능하다. 특정 컴퓨터 기종에 의존하지 않으므로 프로그램 이식성도 높으며, 풍부한 연산자와 데이터 형을 갖고 있기 때문에 범용 프로그램 언어로서 널리 보급되었으며 응용 소프트웨어의 개발에 널리 이용되고 있다. 현재 이용되고 있는 운영체제, 컴파일러, 통합개발환경 등이 대부분 C 언어로 개발되었다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
#include &quot;stdio.h&quot; &lt;br /&gt;
int main(void){ &lt;br /&gt;
　　printf(&quot;Hello, World!&quot;); &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;c-1&quot;&gt;C++&lt;/h2&gt;

&lt;p&gt;　1972년 개발된 C 언어는 1983년에는 프로그램 언어 C++로 발전하였다. C++는 객체지향 프로그래밍(OOP: Object Oriented Programming)을 지원하기 위해 C 언어가 가지는 장점을 그대로 계승하면서 객체의 상속성 등의 개념을 추가한 효과적인 언어이다. C++는 C 언어의 확장이라고 볼 수 있으므로 기존의 C 언어로 개발된 모든 프로그램들을 수정 없이 그대로 사용할 수 있다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
#include &quot;iostream.h&quot; &lt;br /&gt;
int main(int argc, char* argv[]){ &lt;br /&gt;
　　std:cout &amp;lt;&amp;lt; &quot;Hello World&quot; &amp;lt;&amp;lt; std::endl; &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스크래치&quot;&gt;스크래치&lt;/h2&gt;

&lt;p&gt;　스크래치(scratch)는 MIT 대학의 미디어랩에서 개발한 비주얼 프로그래밍 개발 도구이다. 이는 브라우저에서 직접 개발하는 환경으로 커뮤니티 기반 웹 인터페이스로 구성되어 있다. 즉 스크래치는 컴퓨터에 대한 지식이 전혀 없는 일반인과 청소년 또는 지금 바로 프로그래밍에 입문한 학생들을 대상으로 컴퓨터 프로그래밍의 개념을 이해할 수 있도록 도와주는 교육용 프로그래밍 언어이다. 다양한 이미지나 사운드를 제공하여 쉽게 사용할 수 있으며, 코딩에 의한 프로그램 방식이 아닌 직관적으로 누구나 쉽게 이해할 수 있는 블록을 끼워 맞춰 프로그램을 작성하도록 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;모바일 시대의 컴퓨터개론, INFINITY BOOKS&lt;/p&gt;</content><category term="computer" /><category term="c" /><category term="c++" /><summary></summary></entry></feed>
