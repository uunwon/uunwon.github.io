<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.6.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-01-04T20:56:02+09:00</updated><id>http://localhost:4000/</id><title>UUNWON</title><subtitle>Student at Korea Polytechnic University</subtitle><entry><title>[BoostCourse] Android Programming 04</title><link href="http://localhost:4000/BoostCourse-Android4/" rel="alternate" type="text/html" title="[BoostCourse] Android Programming 04" /><published>2021-01-03T00:00:00+09:00</published><updated>2021-01-03T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-Android4</id><content type="html" xml:base="http://localhost:4000/BoostCourse-Android4/">&lt;h2 id=&quot;화면-내비게이션&quot;&gt;화면 내비게이션&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프래그먼트 이해하기&lt;/li&gt;
  &lt;li&gt;프래그먼트 사용하기&lt;/li&gt;
  &lt;li&gt;액션바 사용하기&lt;/li&gt;
  &lt;li&gt;탭 만들기&lt;/li&gt;
  &lt;li&gt;뷰페이저 사용하기&lt;/li&gt;
  &lt;li&gt;바로가기 메뉴 만들기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-프래그먼트-이해하기&quot;&gt;🔑 프래그먼트 이해하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　안드로이드에서 화면은 액티비티로 만들어진다. 화면 제작 중에 부분 화면을 제작해야 하는 상황이 발생할 수 있다. 부분 화면을 액티비티(뷰)로 반복해 만들어 간다면, 코드를 지속적으로 새로 작성해야 하는 불편함뿐만 아니라 액티비티를 관리하는 시스템에 부담이 커진다. 시스템이 액티비티를 관리하는 것처럼 부분 화면을 독립적으로 제작하는 방식을 통해 만들어진 것이 ‘프래그먼트’ 이다. 프래그먼트는 &lt;strong&gt;액티비티가 시스템의 역할&lt;/strong&gt;을 대신하기 때문에, 액티비티보다 가볍게 화면을 전환할 수 있다. 
&lt;br /&gt;
　액티비티의 수명 주기에서 onAttach와 onDetach가 추가된다. onAttach는 onCreate보다 먼저 호출되면 프래그먼트가 액티비티 위에 올라감을 의미한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
**MainActivity.java** &lt;br /&gt;
MainFragment fragment = new MainFragment(); &lt;br /&gt;
getSupportFragmentManager().beginTransaction().add(R.id.container, fragment).commit(); &lt;br /&gt;
&lt;br /&gt;
**MainFragment.java** &lt;br /&gt;
ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_main, container, false); &lt;br /&gt;
return rootView; &lt;br /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;R.id.container 는 프래그먼트를 담을 공간 &lt;br /&gt; add 대신 replace 메소드 사용 시 기존 프래그먼트를 대체함&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-프래그먼트-사용하기&quot;&gt;🪓 프래그먼트 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　액티비티와 프래그먼트는 메소드와 인터페이스를 사용하여 소통할 수 있다. 프래그먼트는 인터페이스가 구현된 상위 액티비티의 메소드로 데이터를 전달하고, 액티비티는 인스턴스로 가지고 있는 프래그먼트의 메소드로 데이터를 전달할 수 있다. 즉 프래그먼트에서 액티비티로 데이터를 전달할 때에는 인터페이스가 필요하지만, 액티비티에서 프래그먼트로 데이터를 전달할 때는 단순한 메소드 호출로 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-액션바-사용하기&quot;&gt;🔨 액션바 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　액션바는 상단 타이틀을 말하며, 현재는 툴바의 기능 또한 가지고 있다.
&lt;br /&gt;
　메뉴는 옵션 메뉴(액션바에 통합됨)와 컨텍스트 메뉴(팝업)으로 나뉜다. onCreateOptionsMenu 를 통해 옵션 메뉴를 생성할 수 있으며, getMenuInflater.inflate() 를 이용해 인플레이션 작업을 해야 한다. onOptionsItemSelected는 옵션 메뉴 아이템을 클릭했을 때 호출하는 메서드이다. 메서드 내부에서 item.getItemId()를 사용해 아이템을 선택할 수 있다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
**menu 태그 내부** &lt;br /&gt;
&amp;lt;item id, title, icon, app:showAsAction, app:actionLayout&amp;gt; &lt;br /&gt;
showAsAction = &quot;always&quot; &quot;ifRoom&quot; &quot;withText&quot; &quot;never&quot; &lt;br /&gt;
actionLayout = &quot;@layout/search_layout&quot; //이런식으로 부분화면 레이아웃 추가가능 &lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-탭-사용하기&quot;&gt;⛏ 탭 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　탭은 하나의 화면에 여러 가지 서브화면들을 넣어둘 수 있는 장점이 있어 자주 사용된다. 몇 개의 탭 버튼이 상단이나 하단에 있고 그 탭 버튼을 누르면 화면이 전환되는 방식이다.
&lt;br /&gt;
　CoordinatorLayout을 사용하면 상단에 액션바 추가 시에 액션바와 아래 화면이 겹치지 않도록 생성해줄 수 있다. 강의는 해당 레이아웃 내에 액션바와 하단 탭 버튼을 추가하는 예제를 진행한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
CoordinatorLayout-AppBarLayout-Toolbar-/AppBarLayout-TabLayout/-/Coor-&amp;gt; FrameLayout &lt;br /&gt;
app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; //FrameLayout이 원래 레이아웃 화면 부분이며, 상단은 액션바 영역임을 구분함 &lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-뷰페이저-사용하기&quot;&gt;⚒ 뷰페이저 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　뷰페이저란 좌우 스크롤을 통해 하나의 뷰페이저 안에 들어가있는 화면이 넘어가는 기능을 제공한다. 일반적으로 뷰페이지 안에 여러 개의 부분 화면인 프래그먼트가 들어간다. 여러 개의 아이템 중 하나를 선택하는 ‘선택 위젯’이므로 어댑터를 사용한다. 즉 어댑터가 실제 데이터를 관리하고 뷰페이저는 껍데기를 역할을 하게 된다.
&lt;br /&gt;
　뷰페이저의 화면이 몇개이고, 몇번째 화면인지 알고 싶을 때는 타이틀스트립(PagerTitleStrip) 혹은 탭스트립(PagerTapStrip)을 사용한다. 예시로 타이틀스트립을 사용하는 경우에는, 프래그먼트 어댑터 내에 getPageTitle 메서드를 통해 페이지마다 타이틀을 붙여 리턴하면 된다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
MainActivity extends FragmentStatePagerAdapter &lt;br /&gt;
ArrayList Fragment items // 프래그먼트 아이템 관리 &lt;br /&gt;
viewpager.setOffscreenPageLimit(3) // 몇 개의 화면을 보여줄지 &lt;br /&gt;
viewpager.setAdapter(adpater); &lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-바로가기-메뉴-만들기&quot;&gt;🛠 바로가기 메뉴 만들기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　타이틀 왼쪽에 햄버거 모양의 아이콘을 바로가기 메뉴 화면이라고 부른다. 안드로이드에서는 NavigationDrawer라고 불리며 이는 기본적으로 제공된다. 해당 기능은 프래그먼트로 구성되기 때문에 프래그먼트의 동작원리를 정확히 이해하는 것이 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse 안드로이드 앱 프로그래밍, 4. 화면 내비게이션 &lt;br /&gt;
https://www.boostcourse.org/mo316/joinLectures/13161&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>화면 내비게이션</summary></entry><entry><title>[BaekJoon] 10828. Stack</title><link href="http://localhost:4000/Baekjoon10828/" rel="alternate" type="text/html" title="[BaekJoon] 10828. Stack" /><published>2020-09-24T00:00:00+09:00</published><updated>2020-09-24T00:00:00+09:00</updated><id>http://localhost:4000/Baekjoon10828</id><content type="html" xml:base="http://localhost:4000/Baekjoon10828/">&lt;h2 id=&quot;스택&quot;&gt;스택&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오. 명령은 총 다섯 가지이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;push X: 정수 X를 스택에 넣는 연산이다.&lt;/li&gt;
  &lt;li&gt;pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.&lt;/li&gt;
  &lt;li&gt;size: 스택에 들어있는 정수의 개수를 출력한다.&lt;/li&gt;
  &lt;li&gt;empty: 스택이 비어있으면 1, 아니면 0을 출력한다.&lt;/li&gt;
  &lt;li&gt;top: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class Main{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　int n = sc.nextInt(); &lt;br /&gt;
　　　　int[] arr = new int[n]; &lt;br /&gt;
　　　　int top = -1; &lt;br /&gt;
　　　　&lt;br /&gt;
　　　　for(int i = 1;i &amp;lt;= n;i++) { &lt;br /&gt;
　　　　　　String txt = sc.nextLine(); &lt;br /&gt;
　　　　　　String txt2 = txt.split(&quot; &quot;)[0]; &lt;br /&gt;
&lt;br /&gt;
　　　　　　if(txt2.equals(&quot;push&quot;)) { &lt;br /&gt;
　　　　　　　　top++; &lt;br /&gt;
　　　　　　　　arr[top] = Integer.parseInt(txt.split(&quot; &quot;)[1]); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
&lt;br /&gt;
　　　　　　else if(txt2.equals(&quot;pop&quot;)) { &lt;br /&gt;
　　　　　　　　if(top == -1) &lt;br /&gt;
　　　　　　　　　　System.out.println(-1); &lt;br /&gt;
　　　　　　　　else { &lt;br /&gt;
　　　　　　　　　　System.out.println(arr[top]); &lt;br /&gt;
　　　　　　　　　　top--; &lt;br /&gt;
　　　　　　　　} &lt;br /&gt;
　　　　　　} &lt;br /&gt;
&lt;br /&gt;
　　　　　　else if(txt2.equals(&quot;size&quot;)) { &lt;br /&gt;
　　　　　　　　System.out.println(top+1); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
&lt;br /&gt;
　　　　　　else if(txt2.equals(&quot;empty&quot;)) { &lt;br /&gt;
　　　　　　　　if(top == -1) &lt;br /&gt;
　　　　　　　　　　System.out.println(1); &lt;br /&gt;
　　　　　　　　else &lt;br /&gt;
　　　　　　　　　　System.out.println(0); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
&lt;br /&gt;
　　　　　　else if(txt2.equals(&quot;top&quot;)) { &lt;br /&gt;
　　　　　　　　if(top == -1) &lt;br /&gt;
　　　　　　　　　　System.out.println(-1); &lt;br /&gt;
　　　　　　　　else &lt;br /&gt;
　　　　　　　　　　System.out.println(arr[top]); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　} &lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/10828, 백준 &lt;br /&gt;
https://thiago6.tistory.com/88?category=827161, 시간초과 오류 &lt;br /&gt;
https://hoho325.tistory.com/139?category=780777, 성공 답안&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>스택
by BaekJoon</summary></entry><entry><title>[BaekJoon] 2442. Drawing star</title><link href="http://localhost:4000/Baekjoon2442/" rel="alternate" type="text/html" title="[BaekJoon] 2442. Drawing star" /><published>2020-09-21T00:00:00+09:00</published><updated>2020-09-21T00:00:00+09:00</updated><id>http://localhost:4000/Baekjoon2442</id><content type="html" xml:base="http://localhost:4000/Baekjoon2442/">&lt;h2 id=&quot;별-찍기---5&quot;&gt;별 찍기 - 5&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　첫째 줄에는 별 1개, 둘째 줄에는 별 3개, …, N번째 줄에는 별 2×N-1개를 찍는 문제. 별은 가운데를 기준으로 대칭이어야 한다.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class NewClass{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　int n = sc.nextInt(); &lt;br /&gt;
　　　　&lt;br /&gt;
　　　　for(int i = 1;i &amp;lt;= n;i++) { &lt;br /&gt;
　　　　　　for(int j = 0;j &amp;lt; n-i;j++) { &lt;br /&gt;
　　　　　　　　System.out.print(&quot; &quot;); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　　　for(int j = 0;j &amp;lt; i*2-1;j++) { &lt;br /&gt;
　　　　　　　　System.out.print(&quot;*&quot;); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　　　System.out.println(); &lt;br /&gt;
　　　　} &lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/2442, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>별 찍기 - 5
by BaekJoon</summary></entry><entry><title>[BaekJoon] 1924. 2007</title><link href="http://localhost:4000/Baekjoon1924/" rel="alternate" type="text/html" title="[BaekJoon] 1924. 2007" /><published>2020-09-18T00:00:00+09:00</published><updated>2020-09-18T00:00:00+09:00</updated><id>http://localhost:4000/Baekjoon1924</id><content type="html" xml:base="http://localhost:4000/Baekjoon1924/">&lt;h2 id=&quot;2007년&quot;&gt;2007년&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　오늘은 2007년 1월 1일 월요일이다. 그렇다면 2007년 x월 y일은 무슨 요일일까? 이를 알아내는 프로그램을 작성하시오.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 빈 칸을 사이에 두고 x(1&amp;lt;= x &amp;lt;=12)와 y(1&amp;lt;= y &amp;lt;=31)이 주어진다. 참고로 2007년에는 1, 3, 5, 7, 8, 10, 12월은 31일까지, 4,6,9,11월은 30일까지, 2월은 28일까지 있다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 x월 y일이 무슨 요일인지에 따라 SUN, MON, TUE, WED, THU, FRI, SAT중 하나를 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class NewClass { &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　int[] date = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; &lt;br /&gt;
　　　　String[] day = {&quot;SUN&quot;, &quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;}; &lt;br /&gt;
　　　　int result = 0; &lt;br /&gt;
&lt;br /&gt;
　　　　int x = sc.nextInt(); &lt;br /&gt;
　　　　int y = sc.nextInt(); &lt;br /&gt;
　　　　for(int i = 0;i &amp;lt; x - 1;i++) { &lt;br /&gt;
　　　　　　result += date[i]; &lt;br /&gt;
　　　　} result += y; &lt;br /&gt;
&lt;br /&gt;
　　　　int temp = result % day.length; &lt;br /&gt;
　　　　System.out.println(day[temp]); &lt;br /&gt;
&lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/1924, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>2007년
by BaekJoon</summary></entry><entry><title>[BaekJoon] 11721. Print by ten</title><link href="http://localhost:4000/Baekjoon11721/" rel="alternate" type="text/html" title="[BaekJoon] 11721. Print by ten" /><published>2020-09-18T00:00:00+09:00</published><updated>2020-09-18T00:00:00+09:00</updated><id>http://localhost:4000/Baekjoon11721</id><content type="html" xml:base="http://localhost:4000/Baekjoon11721/">&lt;h2 id=&quot;열-개씩-끊어-출력하기&quot;&gt;열 개씩 끊어 출력하기&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　알파벳 소문자와 대문자로만 이루어진 길이가 N인 단어가 주어진다. 한 줄에 10글자씩 끊어서 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 단어가 주어진다. 단어는 알파벳 소문자와 대문자로만 이루어져 있으며, 길이는 100을 넘지 않는다. 길이가 0인 단어는 주어지지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　입력으로 주어진 단어를 열 개씩 끊어서 한 줄에 하나씩 출력한다. 단어의 길이가 10의 배수가 아닌 경우에는 마지막 줄에는 10개 미만의 글자만 출력할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class NewClass{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　String word = sc.next(); &lt;br /&gt;
　　　　int len = word.length(); &lt;br /&gt;
&lt;br /&gt;
　　　　for(int i = 0;i &amp;lt; len;i++) { &lt;br /&gt;
　　　　　　if(i % 10 == 9) { &lt;br /&gt;
　　　　　　　　System.out.println(word.charAt(i)); &lt;br /&gt;
　　　　　　　　continue; &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　　　System.out.print(word.charAt(i)); &lt;br /&gt;
　　　　} &lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/11721, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>열 개씩 끊어 출력하기
by BaekJoon</summary></entry><entry><title>[BaekJoon] 11720. Sum of Number</title><link href="http://localhost:4000/Baekjoon11720/" rel="alternate" type="text/html" title="[BaekJoon] 11720. Sum of Number" /><published>2020-09-18T00:00:00+09:00</published><updated>2020-09-18T00:00:00+09:00</updated><id>http://localhost:4000/Baekjoon11720</id><content type="html" xml:base="http://localhost:4000/Baekjoon11720/">&lt;h2 id=&quot;숫자의-합&quot;&gt;숫자의 합&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　입력으로 주어진 숫자 N개의 합을 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class NewClass{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　int sum = 0; &lt;br /&gt;
　　　　&lt;br /&gt;
　　　　int count = sc.nextInt(); &lt;br /&gt;
　　　　String num = sc.next(); &lt;br /&gt;
        &lt;br /&gt;
　　　　if(num.length() == count) { &lt;br /&gt;
　　　　　　for(int i = 0;i &amp;lt; count;i++) { &lt;br /&gt;
　　　　　　　　sum += Integer.parseInt(num.substring(i, i+1)); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　　　System.out.println(sum); &lt;br /&gt;
　　　　} else { &lt;br /&gt;
　　　　　　System.out.println(&quot;out of index&quot;); &lt;br /&gt;
　　　　　　return; &lt;br /&gt;
　　　　} &lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;　💌 string.charAt(i) - ‘0’&lt;br /&gt;
　　: string의 i 위치 char를 아스키 코드를 활용해 int로 변경&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/11720, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>숫자의 합
by BaekJoon</summary></entry><entry><title>[BaekJoon] 2557. Hello World</title><link href="http://localhost:4000/BaekJoon2557/" rel="alternate" type="text/html" title="[BaekJoon] 2557. Hello World" /><published>2020-09-17T00:00:00+09:00</published><updated>2020-09-17T00:00:00+09:00</updated><id>http://localhost:4000/BaekJoon2557</id><content type="html" xml:base="http://localhost:4000/BaekJoon2557/">&lt;h2 id=&quot;hello-world&quot;&gt;Hello World&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　Hello World!를 출력하시오.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　없음&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　Hello World!를 출력하시오.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
public class NewClass{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　System.out.println(&quot;Hello World!&quot;); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/2557, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>Hello World
by BaekJoon</summary></entry><entry><title>[BaekJoon] 11718. Print intactly</title><link href="http://localhost:4000/BaekJoon11718/" rel="alternate" type="text/html" title="[BaekJoon] 11718. Print intactly" /><published>2020-09-17T00:00:00+09:00</published><updated>2020-09-17T00:00:00+09:00</updated><id>http://localhost:4000/BaekJoon11718</id><content type="html" xml:base="http://localhost:4000/BaekJoon11718/">&lt;h2 id=&quot;그대로-출력하기&quot;&gt;그대로 출력하기&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　입력 받은 대로 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　입력이 주어진다. 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. 각 줄은 100글자를 넘지 않으며, 빈 줄은 주어지지 않는다. 또, 각 줄은 공백으로 시작하지 않고, 공백으로 끝나지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　입력받은 그대로 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class NewClass{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　StringBuffer buffer = new StringBuffer(); &lt;br /&gt;
        &lt;br /&gt;
　　　　while(sc.hasNextLine()) { &lt;br /&gt;
　　　　　　buffer.append(sc.nextLine() + '\n'); &lt;br /&gt;
　　　　} &lt;br /&gt;
        &lt;br /&gt;
　　　　System.out.println(buffer); &lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/11718, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>그대로 출력하기
by BaekJoon</summary></entry><entry><title>[Jump to Java] Self Number</title><link href="http://localhost:4000/Jump-to-Java3/" rel="alternate" type="text/html" title="[Jump to Java] Self Number" /><published>2020-09-16T00:00:00+09:00</published><updated>2020-09-16T00:00:00+09:00</updated><id>http://localhost:4000/Jump-to-Java3</id><content type="html" xml:base="http://localhost:4000/Jump-to-Java3/">&lt;h2 id=&quot;self-number&quot;&gt;Self Number&lt;/h2&gt;
&lt;h4 id=&quot;by-jump-to-java&quot;&gt;by Jump-to-Java&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;넥슨의 입사 문제,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“어떤 자연수 n이 있을 때, d(n)을 n의 각 자릿수 숫자들과 n 자신을 더한 숫자라고 정의하자. 이때, n을 d(n)의 제네레이터라고 한다. 어떤 숫자들은 하나 이상의 제네레이터를 가지고 있는데, 101의 제네레이터는 91 뿐 아니라 100도 있다. 그런데 반대로 제네레이터가 없는 숫자들도 있으며, 이런 숫자를 인도의 수학자 Kaprekar가 셀프 넘버(self-number)라 이름 붙였다. 예를 들어 1, 3, 5, 7, 9, 20, 31은 셀프 넘버들이다. &lt;strong&gt;1 이상이고 5000보다 작은 모든 셀프 넘버들의 합을 구하라.&lt;/strong&gt;”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://wikidocs.net/238, 점프 투 자바&lt;/p&gt;</content><category term="java" /><category term="code" /><summary>Self Number
by Jump-to-Java</summary></entry><entry><title>[Jump to Java] Multiples of 3 and 5</title><link href="http://localhost:4000/Jump-to-Java2/" rel="alternate" type="text/html" title="[Jump to Java] Multiples of 3 and 5" /><published>2020-09-16T00:00:00+09:00</published><updated>2020-09-16T00:00:00+09:00</updated><id>http://localhost:4000/Jump-to-Java2</id><content type="html" xml:base="http://localhost:4000/Jump-to-Java2/">&lt;h2 id=&quot;multiples-of-3-and-5&quot;&gt;Multiples of 3 and 5&lt;/h2&gt;
&lt;h4 id=&quot;by-jump-to-java&quot;&gt;by Jump-to-Java&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;프로젝트 오일러에서 제공하는 첫번째 퀴즈,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;10 미만의 자연수에서 3과 5의 배수를 구하면 3, 5, 6, 9이다. 이들의 총합은 23이다. 1000미만의 자연수에서 3, 5의 배수의 총합을 구하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p class=&quot;notice&quot;&gt;
public class multiplesof3and5{ &lt;br /&gt;
　　int max; &lt;br /&gt;
    &lt;br /&gt;
　　public multiplesof3and5(int max){ &lt;br /&gt;
　　　　this.max = max; &lt;br /&gt;
　　} &lt;br /&gt;
　　&lt;br /&gt;
　　public int sum(){ &lt;br /&gt;
　　　　int sum = 0; &lt;br /&gt;
　　　　for(int i = 0;i &amp;lt; max;i++){ &lt;br /&gt;
　　　　　　if((i % 3 == 0) || (i % 5) == 0){ &lt;br /&gt;
　　　　　　　　sum += i; &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　} &lt;br /&gt;
　　　　return sum; &lt;br /&gt;
　　} &lt;br /&gt;
    &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　System.out.println(new multiplesof3and5(10).sum()); &lt;br /&gt;
　　　　System.out.println(new multiplesof3and5(1000).sum()); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://wikidocs.net/237, 점프 투 자바&lt;/p&gt;</content><category term="java" /><category term="code" /><summary>Multiples of 3 and 5
by Jump-to-Java</summary></entry></feed>
