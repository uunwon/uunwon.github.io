<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.6.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-01-18T22:22:07+09:00</updated><id>http://localhost:4000/</id><title>UUNWON</title><subtitle>Student at Korea Polytechnic University</subtitle><entry><title>[BoostCourse] Android Programming 05</title><link href="http://localhost:4000/BoostCourse-Android5/" rel="alternate" type="text/html" title="[BoostCourse] Android Programming 05" /><published>2021-01-06T00:00:00+09:00</published><updated>2021-01-06T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-Android5</id><content type="html" xml:base="http://localhost:4000/BoostCourse-Android5/">&lt;h2 id=&quot;네트워크&quot;&gt;네트워크&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;스레드 사용하기&lt;/li&gt;
  &lt;li&gt;소켓 사용하기&lt;/li&gt;
  &lt;li&gt;웹으로 요청하기&lt;/li&gt;
  &lt;li&gt;Volley 사용하기&lt;/li&gt;
  &lt;li&gt;JSON 이해하기&lt;/li&gt;
  &lt;li&gt;이미지 다운로드하기&lt;/li&gt;
  &lt;li&gt;영화API 사용하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-스레드-사용하기&quot;&gt;🔑 스레드 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　★★★★★★★ &lt;br /&gt;
　작성 必 &lt;br /&gt;
　★★★★★★★ &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-소켓-사용하기&quot;&gt;🪓 소켓 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　★★★★★★★ &lt;br /&gt;
　작성 必 &lt;br /&gt;
　★★★★★★★ &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-웹으로-요청하기&quot;&gt;🔨 웹으로 요청하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　소켓은 두개의 컴퓨터 간에 통로를 만들어주고 통로 간에 데이터를 주고받을 수 있게 만들어주는 방법이다. 최근엔 소켓보다 웹이 많이 사용되는데, 웹서버는 &lt;strong&gt;HTTP 요청&lt;/strong&gt;을 받아 처리할 수 있다. 데이터를 주고받는 HTTP 포맷은 어떤 것들이 들어갈 수 있는 지 표준으로 정해진 &lt;strong&gt;헤더(Header)&lt;/strong&gt;와 데이터가 들어간 &lt;strong&gt;바디(Body)&lt;/strong&gt;로 구성된다.&lt;/p&gt;

&lt;p&gt;　앱에서 웹서버에 요청하는 방식은 기존의 표준 자바와 다르지 않지만, 스레드를 사용한다는 점을 염두해야 한다. 가장 기본적인 방법으로 HttpURLConnection 객체를 사용하여 작성해볼 수 있다. 해당 객체에 속성을 설정하고 getResponseCode 메소드를 호출하면 웹서버에 연결하고 응답을 받아준다. 응답 데이터를 화면에 표시할 때는 Request 메소드를 이용하면 된다.&lt;/p&gt;

&lt;p&gt;　데이터를 읽어들일 때, BufferedReader 객체를 사용하면 한 줄씩 읽을 수 있다. 또한 웹서버에 요청하는 것이므로 인터넷 권한을 주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-volley-사용하기&quot;&gt;⛏ Volley 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　웹서버에 요청할 때 일반적으로 사용하는 HttpURLConnection 은 코드 양이 방대하다. 이를 간결화하기 위해 우리는 외부 라이브러리 &lt;strong&gt;Volley&lt;/strong&gt;를 사용한다. Volley는 코드 양이 간결화될 뿐만 아니라, 스레드를 신경쓰지 않아도 된다는 장점이 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;네트워크 요청 우선 순위를 자동으로 관리한다. &lt;br /&gt; 동시에 여러 네트워크 요청을 할 수 있다. &lt;br /&gt; 요청을 할 때 Cache 적용 여부를 의식하지 않아도 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　RequestQueue를 만들고, 그 안에 Request 객체를 만들어 넣어주면 요청은 자동으로 보내지게 된다. Request 객체는 네 개의 파라미터를 전달함으로써 생성된다. 요청 방식을 지정하고, 웹서버의 URL 정보를 전달하고, 응답이 성공적일 때 호출되는 onRequest 메소드를 작성하고, 에러가 발생했을 때 호출될 리스너 객체를 작성한다.&lt;/p&gt;

&lt;p&gt;　요청 큐는 앱이 시작되었을 때 초기화되어 있으면 되며, 한번 만들어두면 계속 사용할 수 있다. Application 클래스를 정의하고 앱에 등록하여 사용하는 경우에는 Application 클래스 안에 넣어둘 수도 있고, 별도의 클래스를 만들어 넣어둘 수도 있다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
implementation 'com.android.volley:volley:1.1.0'
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-json-이해하기&quot;&gt;⚒ JSON 이해하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　★★★★★★★ &lt;br /&gt;
　작성 必 &lt;br /&gt;
　★★★★★★★ &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-이미지-다운로드하기&quot;&gt;🛠 이미지 다운로드하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　★★★★★★★ &lt;br /&gt;
　작성 必 &lt;br /&gt;
　★★★★★★★ &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-영화api-사용하기&quot;&gt;🔧 영화API 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　★★★★★★★ &lt;br /&gt;
　작성 必 &lt;br /&gt;
　★★★★★★★ &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;detail&quot;&gt;DETAIL&lt;/h4&gt;
&lt;p&gt;HTTP(Hyper Text Transfer Protocol): HTML과 같은 문서 정보를 주고받을 수 있는 프로토콜(규약, 약속)&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse 안드로이드 앱 프로그래밍, 5. 네트워킹 &lt;br /&gt;
https://www.boostcourse.org/mo316/joinLectures/13169&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>네트워크
by boostcourse</summary></entry><entry><title>[BoostCourse] Android Programming 04</title><link href="http://localhost:4000/BoostCourse-Android4/" rel="alternate" type="text/html" title="[BoostCourse] Android Programming 04" /><published>2021-01-03T00:00:00+09:00</published><updated>2021-01-03T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-Android4</id><content type="html" xml:base="http://localhost:4000/BoostCourse-Android4/">&lt;h2 id=&quot;화면-내비게이션&quot;&gt;화면 내비게이션&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;프래그먼트 이해하기&lt;/li&gt;
  &lt;li&gt;프래그먼트 사용하기&lt;/li&gt;
  &lt;li&gt;액션바 사용하기&lt;/li&gt;
  &lt;li&gt;탭 만들기&lt;/li&gt;
  &lt;li&gt;뷰페이저 사용하기&lt;/li&gt;
  &lt;li&gt;바로가기 메뉴 만들기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-프래그먼트-이해하기&quot;&gt;🔑 프래그먼트 이해하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　안드로이드에서 화면은 액티비티로 만들어진다. 화면 제작 중에 부분 화면을 제작해야 하는 상황이 발생할 수 있다. 부분 화면을 액티비티(뷰)로 반복해 만들어 간다면, 코드를 지속적으로 새로 작성해야 하는 불편함뿐만 아니라 액티비티를 관리하는 시스템에 부담이 커진다. 시스템이 액티비티를 관리하는 것처럼 부분 화면을 독립적으로 제작하는 방식을 통해 만들어진 것이 ‘프래그먼트’ 이다. 프래그먼트는 &lt;strong&gt;액티비티가 시스템의 역할&lt;/strong&gt;을 대신하기 때문에, 액티비티보다 가볍게 화면을 전환할 수 있다. 
&lt;br /&gt;
　액티비티의 수명 주기에서 onAttach와 onDetach가 추가된다. onAttach는 onCreate보다 먼저 호출되면 프래그먼트가 액티비티 위에 올라감을 의미한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
**MainActivity.java** &lt;br /&gt;
MainFragment fragment = new MainFragment(); &lt;br /&gt;
getSupportFragmentManager().beginTransaction().add(R.id.container, fragment).commit(); &lt;br /&gt;
&lt;br /&gt;
**MainFragment.java** &lt;br /&gt;
ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_main, container, false); &lt;br /&gt;
return rootView; &lt;br /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;R.id.container 는 프래그먼트를 담을 공간 &lt;br /&gt; add 대신 replace 메소드 사용 시 기존 프래그먼트를 대체함&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-프래그먼트-사용하기&quot;&gt;🪓 프래그먼트 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　액티비티와 프래그먼트는 메소드와 인터페이스를 사용하여 소통할 수 있다. 프래그먼트는 인터페이스가 구현된 상위 액티비티의 메소드로 데이터를 전달하고, 액티비티는 인스턴스로 가지고 있는 프래그먼트의 메소드로 데이터를 전달할 수 있다. 즉 프래그먼트에서 액티비티로 데이터를 전달할 때에는 인터페이스가 필요하지만, 액티비티에서 프래그먼트로 데이터를 전달할 때는 단순한 메소드 호출로 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-액션바-사용하기&quot;&gt;🔨 액션바 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　액션바는 상단 타이틀을 말하며, 현재는 툴바의 기능 또한 가지고 있다.
&lt;br /&gt;
　메뉴는 옵션 메뉴(액션바에 통합됨)와 컨텍스트 메뉴(팝업)으로 나뉜다. onCreateOptionsMenu 를 통해 옵션 메뉴를 생성할 수 있으며, getMenuInflater.inflate() 를 이용해 인플레이션 작업을 해야 한다. onOptionsItemSelected는 옵션 메뉴 아이템을 클릭했을 때 호출하는 메서드이다. 메서드 내부에서 item.getItemId()를 사용해 아이템을 선택할 수 있다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
**menu 태그 내부** &lt;br /&gt;
&amp;lt;item id, title, icon, app:showAsAction, app:actionLayout&amp;gt; &lt;br /&gt;
showAsAction = &quot;always&quot; &quot;ifRoom&quot; &quot;withText&quot; &quot;never&quot; &lt;br /&gt;
actionLayout = &quot;@layout/search_layout&quot; //이런식으로 부분화면 레이아웃 추가가능 &lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-탭-사용하기&quot;&gt;⛏ 탭 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　탭은 하나의 화면에 여러 가지 서브화면들을 넣어둘 수 있는 장점이 있어 자주 사용된다. 몇 개의 탭 버튼이 상단이나 하단에 있고 그 탭 버튼을 누르면 화면이 전환되는 방식이다.
&lt;br /&gt;
　CoordinatorLayout을 사용하면 상단에 액션바 추가 시에 액션바와 아래 화면이 겹치지 않도록 생성해줄 수 있다. 강의는 해당 레이아웃 내에 액션바와 하단 탭 버튼을 추가하는 예제를 진행한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
CoordinatorLayout-AppBarLayout-Toolbar-/AppBarLayout-TabLayout/-/Coor-&amp;gt; FrameLayout &lt;br /&gt;
app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; //FrameLayout이 원래 레이아웃 화면 부분이며, 상단은 액션바 영역임을 구분함 &lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-뷰페이저-사용하기&quot;&gt;⚒ 뷰페이저 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　뷰페이저란 좌우 스크롤을 통해 하나의 뷰페이저 안에 들어가있는 화면이 넘어가는 기능을 제공한다. 일반적으로 뷰페이지 안에 여러 개의 부분 화면인 프래그먼트가 들어간다. 여러 개의 아이템 중 하나를 선택하는 ‘선택 위젯’이므로 어댑터를 사용한다. 즉 어댑터가 실제 데이터를 관리하고 뷰페이저는 껍데기를 역할을 하게 된다.
&lt;br /&gt;
　뷰페이저의 화면이 몇개이고, 몇번째 화면인지 알고 싶을 때는 타이틀스트립(PagerTitleStrip) 혹은 탭스트립(PagerTapStrip)을 사용한다. 예시로 타이틀스트립을 사용하는 경우에는, 프래그먼트 어댑터 내에 getPageTitle 메서드를 통해 페이지마다 타이틀을 붙여 리턴하면 된다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
MainActivity extends FragmentStatePagerAdapter &lt;br /&gt;
ArrayList Fragment items // 프래그먼트 아이템 관리 &lt;br /&gt;
viewpager.setOffscreenPageLimit(3) // 몇 개의 화면을 보여줄지 &lt;br /&gt;
viewpager.setAdapter(adpater); &lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-바로가기-메뉴-만들기&quot;&gt;🛠 바로가기 메뉴 만들기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　타이틀 왼쪽에 햄버거 모양의 아이콘을 바로가기 메뉴 화면이라고 부른다. 안드로이드에서는 NavigationDrawer라고 불리며 이는 기본적으로 제공된다. 해당 기능은 프래그먼트로 구성되기 때문에 프래그먼트의 동작원리를 정확히 이해하는 것이 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse 안드로이드 앱 프로그래밍, 4. 화면 내비게이션 &lt;br /&gt;
https://www.boostcourse.org/mo316/joinLectures/13161&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>화면 내비게이션
by boostcourse</summary></entry><entry><title>[BoostCourse] Android Programming 03</title><link href="http://localhost:4000/BoostCourse-Android03/" rel="alternate" type="text/html" title="[BoostCourse] Android Programming 03" /><published>2021-01-01T00:00:00+09:00</published><updated>2021-01-01T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-Android03</id><content type="html" xml:base="http://localhost:4000/BoostCourse-Android03/">&lt;h2 id=&quot;화면-여러-개-만들기&quot;&gt;화면 여러 개 만들기&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;화면 전환하기&lt;/li&gt;
  &lt;li&gt;인텐트 살펴보기&lt;/li&gt;
  &lt;li&gt;수명주기 이해하기&lt;/li&gt;
  &lt;li&gt;서비스 사용하기&lt;/li&gt;
  &lt;li&gt;브로드캐스트 수신자 사용하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-화면-전환하기&quot;&gt;🔑 화면 전환하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　시스템이 관리하는 애플리케이션 구성요소는 액티비티(Acitity)ㆍ서비스(Service)ㆍ브로드캐스트 리시버(Broadcast Receiver)ㆍ내용 제공자(Content Provider) 가 있다. 각 클래스들은 안드로이드 SDK가 제공하며, 매니페스트 파일을 통해 어떤 애플리케이션 구성요소가 포함되어 있는 지 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;　애플리케이션 구성요소 중 &lt;strong&gt;액티비티(Activity)&lt;/strong&gt;는 안드로이드 앱에서 하나의 화면을 만든다. 하나의 액티비티가 또 다른 액티비티로, 즉 화면이 전환되기 위해 &lt;strong&gt;인텐트(Intent)&lt;/strong&gt; 객체를 사용한다. startActivityForResult 메소드를 호출하면 인텐트 객체가 시스템(액티비티 매니저)으로 전달된다. 액티비티 매니저는 인텐트가 지정한 액티비티를 실행하여 화면에 보여주게 된다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
// 클래스 인스턴트를 인텐트의 파라미터로 넘겨주는 방식 &lt;br /&gt;
Intent intent = new Intent(Context pakageContext, Class&amp;lt;?&amp;gt; cls); &lt;br /&gt;
startActivityForResult(intent, INT_REQUEST_CODE); &lt;br /&gt;
&lt;br /&gt;
startActivityForResult(new Intent(MainActivity.this, SubActivity.class), INT_REQUEST_CODE); &lt;br /&gt;
&lt;br /&gt;
// ComponentName 객체 만들어 설정하는 방식 &lt;br /&gt;
Intent intent = new Intent(); &lt;br /&gt;
ComponentName name = new ComponentName(&quot;org.techtown.intent&quot;, &quot;org.techdown.intent.SubActivity&quot;); &lt;br /&gt;
intent.setComponent(name); &lt;br /&gt;
startActivityForResult(intent, INT_REQUEST_CODE); &lt;br /&gt; &lt;br /&gt;
finish();
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-인텐트-살펴보기&quot;&gt;🪓 인텐트 살펴보기&lt;/h3&gt;

&lt;h4 id=&quot;인텐트-종류&quot;&gt;인텐트 종류&lt;/h4&gt;
&lt;p&gt;　시스템에서 이해할 수 있는 객체로 만들어진 것이 &lt;strong&gt;인텐트(Intent)&lt;/strong&gt;이며, 화면을 실행할 때 인텐트가 사용된다. 인텐트에는 컴포넌트 A가 컴포넌트 B를 호출할 때 필요한 정보를 담고 있으며, 이 정보에는 호출되는 컴포넌트 B의 이름이 &lt;code class=&quot;highlighter-rouge&quot;&gt;명시적&lt;/code&gt;으로 표시되기도 하고, 속성들이 &lt;code class=&quot;highlighter-rouge&quot;&gt;암시적&lt;/code&gt;으로 표시되기도 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;① 명시적 인텐트 &lt;br /&gt; 인텐트에 클래스 객체 컴포넌트 이름을 지정하여 호출된 대상을 확실히 알 수 있는 경우에 사용한다. 주로 애플리케이션 내부에서 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;② 암시적 인텐트 &lt;br /&gt; 인텐트의 액션과 테이터를 지정하긴 했지만, 호출할 대상이 달라질 수 있는 경우에는 암시적 인텐트를 사용한다. 즉, 설치된 애플리케이션들에 대한 정보를 알고 있는 안드로이드 시스템이 인텐트를 이용해 요청한 정보를 처리할 수 있는 적절한 컴포넌트를 찾아본 다음, 사용자에게 그 대상과 처리 결과를 보여주는 과정을 거치게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;인텐트-플래그&quot;&gt;인텐트 플래그&lt;/h4&gt;
&lt;p&gt;　새로 실행하려는 액티비티와 화면에 보이는 액티비티가 동일한 액티비티인 경우 (ex. 서비스), 플래그를 사용하여 메모리에 액티비티를 새로 만들지 않고 화면에 보이는 액티비티를 재사용한다. 이같은 경우에 onCreate 메소드 대신 onNewIntent 메소드가 호출되어 인텐트를 전달받을 수 있다. 액티비티를 재사용할 시에는 인텐트에 추가할 수 있는 옵션인 &lt;strong&gt;플래그&lt;/strong&gt;를 활용한다. 즉, 시스템이 인텐트를 해석한 후 동작시킬 때 옵션에 따라 다른 동작을 하도록 한다. 플래그를 이해하기 위해서는 액티비티 스택에서 액티비티가 관리된다는 점을 알아야 한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
 intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); //설정 &lt;br /&gt;
 intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); //추가
 &lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;부가-데이터&quot;&gt;부가 데이터&lt;/h4&gt;

&lt;p&gt;　인텐트는 시스템을 통해 다른 액티비티로 전달될 수 있는데 액티비티뿐만 아니라 다른 애플리케이션 구성요소로도 전달될 수 있다. 애플리케이션 구성요소들 간에 데이터를 전달하는 데 인텐트가 사용되는 것이다. 부가 데이터는 시스템에서 건드리지 않고 전달만 되며, 인텐트 안에 번들(Bundle) 객체가 들어있어 그 안에 데이터를 넣을 때는 put, 데이터를 가져올 때는 get 메소드를 사용한다.&lt;/p&gt;

&lt;p&gt;　기존의 put, get 메소드를 이용해 인텐트에 넣을 수 있는 부가데이터의 자료형은 기본 자료형뿐이다. 다양한 객체의 정보를 전달하기 위해서는 &lt;strong&gt;Serializble&lt;/strong&gt; 또는 &lt;strong&gt;Parcelable&lt;/strong&gt; 객체를 만들어 전달할 수 있다.&lt;/p&gt;

&lt;p&gt;　데이터 클래스를 별도로 생성하여 전달할 때, 안드로이드에서는 Parcelable을 구현하는 것을 추천하고 있다. Serializable은 데이터를 효율적이지 않게 일렬 데이터로 만들어 전송하는 반면 Parcelable은 데이터 타입에 맞게 가공해준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-수명주기-이해하기&quot;&gt;🔨 수명주기 이해하기&lt;/h3&gt;

&lt;p&gt;　액티비티 수명주기는 액티비티의 상태가 변할 때마다 안드로이드 시스템에서 각 상황에 맞는 메소드를 자동으로 호출해줌으로써, 직접 상태에 맞는 코드를 넣어 액티비티의 상태에 따라 제어할 수 있도록 해준다.&lt;/p&gt;

&lt;p&gt;　&lt;img src=&quot;http://localhost:4000/images/android_lifecycle.png&quot; alt=&quot;Android_LifeCycle&quot; height=&quot;50&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　화면이 없어질 때 데이터를 임시로 저장할 때는 &lt;strong&gt;onPause()&lt;/strong&gt; 메소드를, 데이터를 복구할 때는 &lt;strong&gt;onResume()&lt;/strong&gt; 메소드를 사용한다. 이때 데이터는 SharedPreferences를 이용하면 저장할 수 있다. 또는 onSaveInstanceState 메소드와 onRestoreInstanceState 메소드를 사용하는 방법이 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-서비스-사용하기&quot;&gt;⛏ 서비스 사용하기&lt;/h3&gt;

&lt;p&gt;　&lt;strong&gt;서비스(Service)&lt;/strong&gt;는 화면이 없는 상태(백그라운드)에서 실행되는 애플리케이션의 구성요소 중 하나다. 인터넷을 통해 데이터를 주고받는 경우가 많은데 이때 대부분 서비스라는 것을 사용하게 된다. 애플리케이션 구성요소이기 때문에 프로젝트에 추가할 때 매니페스트 파일에 &lt;Service&gt; 태그를 사용한다. 서비스는 startService 메소드를 호출하면 시작된다.&lt;/Service&gt;&lt;/p&gt;

&lt;p&gt;　startService 메소드는 또한 인텐트 안에 넣어 전달한 명령이나 데이터를 처리할 수 있도록 onStartCommand() 메소드를 사용한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
@Override &lt;br /&gt;
public int onStartCommand(Intent intent, int flags, int startId) { &lt;br /&gt;
　Log.d(TAG, &quot;onStartCommand() 호출됨&quot;); &lt;br /&gt;
　return super.onStartCommand(intent, flags, startId); &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;　화면이 없는 서비스에서 화면이 있는 액티비티를 띄울 때는 태스크(Task)를 새로 만들어서 연결해야 한다. 그와 같은 경우에 일반적으로 세 개의 플래그(FLAG_ACTIVITY_NEW_TASK, FLAG_ACTIVITY_SINGLE_TOP, FLAG_ACTIVITY_CLEAR_TOP)를 사용한다. 그러면 액티비티는 새로 만들어지지 않고 기존 액티비티를 사용하고, onNewIntent 메소드가 자동으로 호출된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-브로드캐스트-수신자-사용하기&quot;&gt;⚒ 브로드캐스트 수신자 사용하기&lt;/h3&gt;

&lt;p&gt;　브로드캐스팅이란 여러 사람에게 동시에 데이터를 전달하는 것을 말한다. 안드로이드는 여러 애플리케이션 구성 요소에게 메시지를 전달하고 싶은 경우에 브로드캐스팅을 사용한다. 브로드캐스트 수신자 또한 애플리케이션 구성요소이므로 매니페이트 파일에 정보를 추가해준다. intent-filter 태그 내에는 어떤 브로드캐스팅 메시지를 받고 싶은지 지정할 수 있다. 또한 브로드캐스팅 메시지는 인텐트 객체로 만들어져 전달된다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
receiver android:name=&quot;.SmsReceiver&quot; &lt;br /&gt;
　intent-filter &lt;br /&gt;
　　action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot; &lt;br /&gt;
　/intent-filter &lt;br /&gt;
/receiver
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;detail&quot;&gt;DETAIL&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Serialization(직렬화)&lt;/code&gt; : 객체를 저장 장치에 저장 혹은 네트워크 전송을 위해 텍스트나 이진 형식으로 변환하는 것 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Serializble(객체 직렬화)&lt;/code&gt; : 객체를 바이트로 저장하는 자바의 인터페이스 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Parcelable&lt;/code&gt; : 안드로이드 SDK가 포함하고 있는 인터페이스 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt; : 자바 기능 중 하나로, 클래스나 인터페이스의 정보에 직접 접근할 수 있도록 하는 API &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Bundle&lt;/code&gt; : 여러 가지 타입의 값을 저장하는 Map 클래스이다. 예를 들면 String 값을 Bundle 클래스에 Mapping(대응, 변환)하는 것이다. 즉, Bundle 은 아무거나 포장할 수 있는 상자를 의미하고 이 상자를 이용하여 이리저리 인텐트도 오고갈 수 있고 다양한 데이터 통신에 이용할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse 안드로이드 앱 프로그래밍, 3. 화면 여러 개 만들기 &lt;br /&gt;
https://www.boostcourse.org/mo316/joinLectures/13160 &lt;br /&gt;
[Android] Intent &lt;br /&gt;
https://woovictory.github.io/2019/01/02/Android-What-is-Intent/ &lt;br /&gt;
Intent의 Flag 사용법 &lt;br /&gt;
https://ju-hy.tistory.com/46 &lt;br /&gt;
Android Bundle 이란? &lt;br /&gt;
https://www.crocus.co.kr/1560 &lt;br /&gt;
Android Serializable vs Parcelable &lt;br /&gt;
https://wooooooak.github.io/android/2019/09/19/Serializable-vs-Parcelable/ &lt;br /&gt;
Android &amp;amp; Java - Reflection &lt;br /&gt;
https://two22.tistory.com/14&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>화면 여러 개 만들기
by boostcourse</summary></entry><entry><title>[BoostCourse] Android Programming 02</title><link href="http://localhost:4000/BoostCourse-Android2/" rel="alternate" type="text/html" title="[BoostCourse] Android Programming 02" /><published>2020-12-30T00:00:00+09:00</published><updated>2020-12-30T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-Android2</id><content type="html" xml:base="http://localhost:4000/BoostCourse-Android2/">&lt;h2 id=&quot;이벤트와-리스트뷰&quot;&gt;이벤트와 리스트뷰&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;스크롤뷰 사용하기&lt;/li&gt;
  &lt;li&gt;이벤트 이해하기&lt;/li&gt;
  &lt;li&gt;토스트와 대화상자&lt;/li&gt;
  &lt;li&gt;비트맵 버튼 만들기&lt;/li&gt;
  &lt;li&gt;인플레이션 이해하기&lt;/li&gt;
  &lt;li&gt;리스트뷰 만들기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-스크롤뷰-사용하기&quot;&gt;🔑 스크롤뷰 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　스크롤뷰는 말그대로 스크롤 기능을 위해 사용한다. 글자가 이지미가 들어간 뷰가 화면 영역을 벗어나면 보이지 않는 경우에 대비할 수 있다. 해당 뷰는 원하는 영역을 ScrollView 태그로 감싸면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-이벤트-이해하기&quot;&gt;🪓 이벤트 이해하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　화면을 터치했을 때는 ‘이벤트’가 발생한다. 해당 이벤트는 화면의 어느 부분에 어떻게 클릭하거나 터치했는지에 대한 정보를 담았으며, 리스너를 이용해 다룰 수 있다. (ex. OnClickListenr 인터페이스) 예시로, 버튼에 리스너를 등록해두면 버튼이 클릭될 때마다 리스너의 메소드가 자동으로 호출되게 된다. 그 외에도 터치 이벤트와 키 이벤트가 있다.&lt;/p&gt;

&lt;p&gt;　&lt;code class=&quot;highlighter-rouge&quot;&gt;터치 이벤트&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;boolean onTouchEvent (MotionEvent event)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　&lt;code class=&quot;highlighter-rouge&quot;&gt;키 이벤트&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;boolean onKeyDown (int keyCode, KeyEvent event) &lt;br /&gt; boolean onKeyUp (int keyCode, KeyEvent event) &lt;br /&gt; void onBackPressed() // keyCode == KeyEvent.KEYCODE_BACK&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-토스트와-대화상자&quot;&gt;🔨 토스트와 대화상자&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　&lt;strong&gt;토스트(Toast)&lt;/strong&gt; 는 간단한 메시지를 화면에 띄어주는 역할을 한다. Log 클래스를 이용해 콘솔에 메시지를 출력할 수도 있지만, 화면에 보여주고 싶다면 토스트 기능을 사용한다.&lt;/p&gt;

&lt;p&gt;　유사한 역할로, &lt;strong&gt;스낵바&lt;/strong&gt;는 화면 내 아래쪽에서 올라왔다가 사라지는 뷰이다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
Toast.makeText(Context context, String message, int duration).show(); &lt;br /&gt;
Snackbar.make(View view, CharSequence text, int duration).show();
&lt;/p&gt;

&lt;p&gt;　사용자에게 어떤 내용을 알려주거나 ‘예’, ‘아니오’ 버튼을 선택하도록 할 때는 &lt;strong&gt;알림 대화상자(AlertDialog)&lt;/strong&gt;를 사용한다. 이는 AlertDialog.Builder 객체를 사용하여, AlertDialog 객체를 만들어 show 메소드를 이용해 화면에 표시한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
AlertDialog.Builder builder = new AlertDialog.Builder(this); &lt;br /&gt;
AlertDialog dialog = builder.create(); &lt;br /&gt;
dialog.show();
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-비트맵-버튼-만들기&quot;&gt;⛏ 비트맵 버튼 만들기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　&lt;strong&gt;① 나인패치(9Patch)&lt;/strong&gt;&lt;br /&gt;
　이미지 파일 이름에 .9 라는 글자를 붙여 나인패치 이미지를 생성할 수 있다. 이는 이미지의 깨질 가능성이 있는 부분은 늘리지 않아, 이미지의 크기가 변형되더라도 덜 왜곡된다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;② 비트맵 버튼(BitmapButton)&lt;/strong&gt;&lt;br /&gt;
　Button 을 상속하여 새로운 비트맵 버튼을 생성할 수 있다. 나인패치 이미지를 적용하는 대표적인 경우가 버튼인데, 배경을 이미지로 지정하여 만든 버튼은 눌러도 이미지의 변화가 없다. 이같은 단점을 보완하기 위해 비트맵 이미지를 이용해 버튼의 상태를 이벤트로 구분해 표시할 수 있다. 배경 이미지가 변경되면 &lt;code class=&quot;highlighter-rouge&quot;&gt;invalidate 메소드를 사용해 화면을 갱신&lt;/code&gt;해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-인플레이션-이해하기&quot;&gt;⚒ 인플레이션 이해하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　XML 레이아웃에 정의된 내용이 실제 메모리에 객체화되는 (생성되는) 과정을 &lt;strong&gt;인플레이션 과정&lt;/strong&gt;이라 한다. 이같은 레이아웃 인플레이션 과정은 setContentView() 메소드를 통해 (XML 파일의 전체 화면을) 할 수 있다. 부분 화면의 경우에는 LayoutInflater 를 이용해서 직접 메모리에 객체화를 해야 한다. 인플레이션 후에는 아이디를 통해서 내부의 뷰를 찾아 사용할 수 있다!&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
FrameLayout container = findViewById(R.id.container); &lt;br /&gt;
LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE); &lt;br /&gt;
inflater.inflate(R.layout.보여줄_XML_파일명, container, true);
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-리스트뷰-만들기&quot;&gt;🛠 리스트뷰 만들기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　리스트뷰에는 여러 개의 데이터를 넣어 보여줄 수 있는데, 좀 더 쉽게 만들 수 있도록 어댑터를 만들어 사용한다. 어댑터는 여러 개의 아이템 중에서 하나를 선택하는 방식을 가진 선택 위젯에서 사용된다. 뷰가 데이터를 관리하는 것이 아닌, 어댑터가 실제 데이터를 관리하는 것이다. 각각의 아이템을 위한 뷰도 어댑터에서 만들어주기 때문에 리스트뷰는 어댑터의 getView 메소드를 호출해 뷰 객체를 반환받은 뒤 화면에 보여주게 된다.&lt;/p&gt;

&lt;p&gt;　최근 실무에서는 리스트뷰(ListView)보다 리사이클러뷰(RecyclerView)를 더 많이 사용한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;유사한 선택 위젯으로 스피너와 그리드뷰가 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;detail&quot;&gt;DETAIL&lt;/h4&gt;
&lt;p&gt;@Override : 이미 구현되어있는 코드를 덮어쓴다는 의미로, 해당 의미를 컴퓨터에게 알려주는 용도다.&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse 안드로이드 앱 프로그래밍, 2. 이벤트와 리스트뷰 &lt;br /&gt;
https://www.boostcourse.org/mo316/joinLectures/13159 &lt;br /&gt; &lt;br /&gt;
Bitmap Button 만들기 &lt;br /&gt;
https://qlyh8.tistory.com/44&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>이벤트와 리스트뷰
by boostcourse</summary></entry><entry><title>[BoostCourse] Android Programming 01</title><link href="http://localhost:4000/BoostCourse-Android1/" rel="alternate" type="text/html" title="[BoostCourse] Android Programming 01" /><published>2020-12-28T00:00:00+09:00</published><updated>2020-12-28T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-Android1</id><content type="html" xml:base="http://localhost:4000/BoostCourse-Android1/">&lt;h2 id=&quot;레이아웃-만들기&quot;&gt;레이아웃 만들기&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;첫번째 앱 만들기&lt;/li&gt;
  &lt;li&gt;도구 사용하기&lt;/li&gt;
  &lt;li&gt;레이아웃 (제약, 리니어, 상대, 프레임)&lt;/li&gt;
  &lt;li&gt;기본 위젯들&lt;/li&gt;
  &lt;li&gt;드로어블 만들기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-첫번째-앱-만들기&quot;&gt;🔑 첫번째 앱 만들기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　’안드로이드 스튜디오’ 라는 도구를 사용해 안드로이드 앱을 만들 수 있다. 해당 도구는 안드로이드 개발자 사이트에서 다운로드 받을 수 있다.&lt;/p&gt;

&lt;p&gt;　애뮬레이터는 테스트할 때 사용하는 가상의 단말기다. 애뮬레이터를 실행하면 안드로이드 스튜디오를 이용해 만든 앱을 띄우고 테스트해볼 수 있다. 앱을 실행할 때는 상단의 아이콘 중 초록색 ▶ 아이콘을 누르면 된다.&lt;/p&gt;

&lt;p&gt;　프로젝트 내 파일을 살펴보면 xml과 java 로 나누어진 것을 확인할 수 있다. xml 파일은 레이아웃, java 파일은 레이아웃.xml에 기능을 넣어주는 역할을 한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
http://developer.android.com/studio/index.html
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-도구-사용하기&quot;&gt;🪓 도구 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　사용자에게 보이는 화면은 XML 파일로 만들어지며, XML 레이아웃이라 부른다. XML 파일 안에는 태그와 속성들이 들어가며, 이 파일을 시스템이 읽어 화면으로 보여둔다. 또한, 화면이나 소스 코드를 수정하면 안드로이드는 수정 사항을 바로 반영하게 된다.&lt;/p&gt;

&lt;p&gt;　각 태그는 뷰를 의미하며, 속성에 붙어있는 ‘android:’ 지시어는 안드로이드 SDK에서 정의한 속성이라는 의미다. 필수적인 속성은 크기를 나타내는 layout_width, layout_height 다.&lt;/p&gt;

&lt;p&gt;　화면을 만드는 가장 기본적인 단위는 &lt;strong&gt;뷰&lt;/strong&gt;다. 뷰 중에 눈에 보이는 것들은 위젯, 눈에 보이지 않는 것들은 레이아웃이라 구분한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-레이아웃-제약-리니어-상대-프레임&quot;&gt;🔨 레이아웃 (제약, 리니어, 상대, 프레임)&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　프로젝트를 처음 만들면 제약 레이아웃(Constraintlayout)이라는 것이 버튼을 담고 있는 형태로 만들어진다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;① ConstraintLayout&lt;/strong&gt;&lt;br /&gt;
　제약 레이아웃은 제약 조건을 이용해 그 안에 추가된 뷰들의 위치를 결정한다. 그러한 제약 조건은 연결선을 통해 만들어진다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;② LinearLayout&lt;/strong&gt;&lt;br /&gt;
　리니어 레이아웃은 상자를 쌓듯 뷰를 하나씩 쌓을 수 있는 레이아웃이다. 화면에서 뷰가 차지한 영역을 상자라 보고, 이 상자를 한쪽 방향(orientation = horizontal, vertical)으로 쌓을 수 있게 한다. 뷰를 정렬할 때는 layout_gravity(뷰 정렬)와 gravity(뷰 안 내용물 정렬)를 사용한다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;③ RelativeLayout&lt;/strong&gt;&lt;br /&gt;
　상대 레이아웃은 뷰를 담고 있는 부모 레이아웃이나 그 안에 들어있는 다른 뷰들과의 상대적 위치를 이용해 화면을 배치한다. 부모 레이아웃과의 상대적 위치를 지정할 때 사용하는 속성들은 모두 Parent 라는 단어가 들어가 있지만, 다른 뷰와의 상대적 위치를 지정할 때 사용하는 속성들에는 Parent 라는 단어가 들어가 있지 않다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;④ FrameLayout&lt;/strong&gt;&lt;br /&gt;
　프레임 레이아웃은 한번에 하나의 뷰만 보여주는 레이아웃으로, 화면에는 가장 나중에 추가한 뷰만 보인다. 이런 특성 때문에 화면 중첩 시에 주로 사용된다. (가시성 visibility 속성을 함께 이용할 수 있다.)&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;⑤ TableLayout&lt;/strong&gt;&lt;br /&gt;
　테이블 레이아웃은 격자 모양으로 뷰를 배치할 때 사용한다. 레이아웃 안에서 각 행은 TableRow 태그를 이용해 추가하며, 그 안에 추가되는 뷰의 개수에 따라 열의 개수 또한 결정된다. 리니어 레이아웃을 사용하여 테이블 모양을 만들 수 있지만, 정해진 규격에 맞춰 제작하고 싶을 때 테이블 레이아웃을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-기본-위젯들&quot;&gt;⛏ 기본 위젯들&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　&lt;strong&gt;① TextView&lt;/strong&gt;&lt;br /&gt;
　텍스트뷰는 화면에 글자를 표시하도록 해준다. 해당 뷰 안에 들어가는 내용은 가급적 stings.xml 파일 안에 넣어둔 태그 값으로 설정한다. 해당 방식은 다국어를 설정할 때도 유용한데, 언어 폴더를 각각 만들어 넣어준다면 단말의 Locale(위치)에 따라 언어가 변경될 수 있다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;② Button&lt;/strong&gt;&lt;br /&gt;
　버튼은 텍스트뷰를 상속하여 만들어졌다. 이는 라디오 버튼이나 체크 박스 등으로 나누어 사용될 수 있다. 그 중 라디오 버튼은 라디오 그룹을 이용해 하나의 그룹으로 묶어줄 수 있다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;③ EditText&lt;/strong&gt;&lt;br /&gt;
　에디드텍스트는 입력 상자 역할을 한다. inputType 속성을 이용해, 어떤 유형의 글자를 입력할 지 결정한다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;④ ImageView&lt;/strong&gt;&lt;br /&gt;
　이미지뷰는 이미지를 보여주는 뷰로, res/drwable 폴더 내의 이미지를 불러와 보여준다. 이미지 파일의 확장자는 png 형식의 이미지를 권장한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-드로어블-만들기&quot;&gt;⚒ 드로어블 만들기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　드로어블(Drawable)은 뷰에 설정할 수 있는 객체이며, 그래픽으로 그릴 수 있다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;① 상태 드로어블&lt;/strong&gt;&lt;br /&gt;
　상태 드로어블은 뷰의 상태에 따라 뷰에 보여줄 그래픽을 다르게 지정할 수 있다. drawable 폴더 내 최상위 태그는 selector 이며, 태그 내에 item 태그를 넣을 수 있으며 state_ 로 시작하는 상태를 나타내는 속성을 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;② 쉐이프 드로어블&lt;/strong&gt;&lt;br /&gt;
　쉐이프 드로어블은 XML로 도형을 그릴 수 있도록 한다. drawable 폴더 내 최상위 태그는 shape 이며, shape 속성을 이용해 원하는 모양의 도형을 지정할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;태그 종류&lt;/strong&gt; &lt;br /&gt; stroke : 테두리 선 속성 지정 &lt;br /&gt; width : 선의 굵기 &lt;br /&gt; color : 선의 색상 solid : 도형의 안쪽 채우기 &lt;br /&gt; gradient : 배경색으로 그라데이션 설정&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse 안드로이드 앱 프로그래밍, 1. 레이아웃 만들기 &lt;br /&gt;
https://www.boostcourse.org/mo316/joinLectures/13158&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>레이아웃 만들기
by boostcourse</summary></entry><entry><title>[BaekJoon] 10828. Stack</title><link href="http://localhost:4000/Baekjoon10828/" rel="alternate" type="text/html" title="[BaekJoon] 10828. Stack" /><published>2020-09-24T00:00:00+09:00</published><updated>2020-09-24T00:00:00+09:00</updated><id>http://localhost:4000/Baekjoon10828</id><content type="html" xml:base="http://localhost:4000/Baekjoon10828/">&lt;h2 id=&quot;스택&quot;&gt;스택&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오. 명령은 총 다섯 가지이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;push X: 정수 X를 스택에 넣는 연산이다.&lt;/li&gt;
  &lt;li&gt;pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.&lt;/li&gt;
  &lt;li&gt;size: 스택에 들어있는 정수의 개수를 출력한다.&lt;/li&gt;
  &lt;li&gt;empty: 스택이 비어있으면 1, 아니면 0을 출력한다.&lt;/li&gt;
  &lt;li&gt;top: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class Main{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　int n = sc.nextInt(); &lt;br /&gt;
　　　　int[] arr = new int[n]; &lt;br /&gt;
　　　　int top = -1; &lt;br /&gt;
　　　　&lt;br /&gt;
　　　　for(int i = 1;i &amp;lt;= n;i++) { &lt;br /&gt;
　　　　　　String txt = sc.nextLine(); &lt;br /&gt;
　　　　　　String txt2 = txt.split(&quot; &quot;)[0]; &lt;br /&gt;
&lt;br /&gt;
　　　　　　if(txt2.equals(&quot;push&quot;)) { &lt;br /&gt;
　　　　　　　　top++; &lt;br /&gt;
　　　　　　　　arr[top] = Integer.parseInt(txt.split(&quot; &quot;)[1]); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
&lt;br /&gt;
　　　　　　else if(txt2.equals(&quot;pop&quot;)) { &lt;br /&gt;
　　　　　　　　if(top == -1) &lt;br /&gt;
　　　　　　　　　　System.out.println(-1); &lt;br /&gt;
　　　　　　　　else { &lt;br /&gt;
　　　　　　　　　　System.out.println(arr[top]); &lt;br /&gt;
　　　　　　　　　　top--; &lt;br /&gt;
　　　　　　　　} &lt;br /&gt;
　　　　　　} &lt;br /&gt;
&lt;br /&gt;
　　　　　　else if(txt2.equals(&quot;size&quot;)) { &lt;br /&gt;
　　　　　　　　System.out.println(top+1); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
&lt;br /&gt;
　　　　　　else if(txt2.equals(&quot;empty&quot;)) { &lt;br /&gt;
　　　　　　　　if(top == -1) &lt;br /&gt;
　　　　　　　　　　System.out.println(1); &lt;br /&gt;
　　　　　　　　else &lt;br /&gt;
　　　　　　　　　　System.out.println(0); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
&lt;br /&gt;
　　　　　　else if(txt2.equals(&quot;top&quot;)) { &lt;br /&gt;
　　　　　　　　if(top == -1) &lt;br /&gt;
　　　　　　　　　　System.out.println(-1); &lt;br /&gt;
　　　　　　　　else &lt;br /&gt;
　　　　　　　　　　System.out.println(arr[top]); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　} &lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/10828, 백준 &lt;br /&gt;
https://thiago6.tistory.com/88?category=827161, 시간초과 오류 &lt;br /&gt;
https://hoho325.tistory.com/139?category=780777, 성공 답안&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>스택
by BaekJoon</summary></entry><entry><title>[BaekJoon] 2442. Drawing star</title><link href="http://localhost:4000/Baekjoon2442/" rel="alternate" type="text/html" title="[BaekJoon] 2442. Drawing star" /><published>2020-09-21T00:00:00+09:00</published><updated>2020-09-21T00:00:00+09:00</updated><id>http://localhost:4000/Baekjoon2442</id><content type="html" xml:base="http://localhost:4000/Baekjoon2442/">&lt;h2 id=&quot;별-찍기---5&quot;&gt;별 찍기 - 5&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　첫째 줄에는 별 1개, 둘째 줄에는 별 3개, …, N번째 줄에는 별 2×N-1개를 찍는 문제. 별은 가운데를 기준으로 대칭이어야 한다.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class NewClass{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　int n = sc.nextInt(); &lt;br /&gt;
　　　　&lt;br /&gt;
　　　　for(int i = 1;i &amp;lt;= n;i++) { &lt;br /&gt;
　　　　　　for(int j = 0;j &amp;lt; n-i;j++) { &lt;br /&gt;
　　　　　　　　System.out.print(&quot; &quot;); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　　　for(int j = 0;j &amp;lt; i*2-1;j++) { &lt;br /&gt;
　　　　　　　　System.out.print(&quot;*&quot;); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　　　System.out.println(); &lt;br /&gt;
　　　　} &lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/2442, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>별 찍기 - 5
by BaekJoon</summary></entry><entry><title>[BaekJoon] 1924. 2007</title><link href="http://localhost:4000/Baekjoon1924/" rel="alternate" type="text/html" title="[BaekJoon] 1924. 2007" /><published>2020-09-18T00:00:00+09:00</published><updated>2020-09-18T00:00:00+09:00</updated><id>http://localhost:4000/Baekjoon1924</id><content type="html" xml:base="http://localhost:4000/Baekjoon1924/">&lt;h2 id=&quot;2007년&quot;&gt;2007년&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　오늘은 2007년 1월 1일 월요일이다. 그렇다면 2007년 x월 y일은 무슨 요일일까? 이를 알아내는 프로그램을 작성하시오.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 빈 칸을 사이에 두고 x(1&amp;lt;= x &amp;lt;=12)와 y(1&amp;lt;= y &amp;lt;=31)이 주어진다. 참고로 2007년에는 1, 3, 5, 7, 8, 10, 12월은 31일까지, 4,6,9,11월은 30일까지, 2월은 28일까지 있다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 x월 y일이 무슨 요일인지에 따라 SUN, MON, TUE, WED, THU, FRI, SAT중 하나를 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class NewClass { &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　int[] date = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; &lt;br /&gt;
　　　　String[] day = {&quot;SUN&quot;, &quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;}; &lt;br /&gt;
　　　　int result = 0; &lt;br /&gt;
&lt;br /&gt;
　　　　int x = sc.nextInt(); &lt;br /&gt;
　　　　int y = sc.nextInt(); &lt;br /&gt;
　　　　for(int i = 0;i &amp;lt; x - 1;i++) { &lt;br /&gt;
　　　　　　result += date[i]; &lt;br /&gt;
　　　　} result += y; &lt;br /&gt;
&lt;br /&gt;
　　　　int temp = result % day.length; &lt;br /&gt;
　　　　System.out.println(day[temp]); &lt;br /&gt;
&lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/1924, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>2007년
by BaekJoon</summary></entry><entry><title>[BaekJoon] 11721. Print by ten</title><link href="http://localhost:4000/Baekjoon11721/" rel="alternate" type="text/html" title="[BaekJoon] 11721. Print by ten" /><published>2020-09-18T00:00:00+09:00</published><updated>2020-09-18T00:00:00+09:00</updated><id>http://localhost:4000/Baekjoon11721</id><content type="html" xml:base="http://localhost:4000/Baekjoon11721/">&lt;h2 id=&quot;열-개씩-끊어-출력하기&quot;&gt;열 개씩 끊어 출력하기&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　알파벳 소문자와 대문자로만 이루어진 길이가 N인 단어가 주어진다. 한 줄에 10글자씩 끊어서 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 단어가 주어진다. 단어는 알파벳 소문자와 대문자로만 이루어져 있으며, 길이는 100을 넘지 않는다. 길이가 0인 단어는 주어지지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　입력으로 주어진 단어를 열 개씩 끊어서 한 줄에 하나씩 출력한다. 단어의 길이가 10의 배수가 아닌 경우에는 마지막 줄에는 10개 미만의 글자만 출력할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class NewClass{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　String word = sc.next(); &lt;br /&gt;
　　　　int len = word.length(); &lt;br /&gt;
&lt;br /&gt;
　　　　for(int i = 0;i &amp;lt; len;i++) { &lt;br /&gt;
　　　　　　if(i % 10 == 9) { &lt;br /&gt;
　　　　　　　　System.out.println(word.charAt(i)); &lt;br /&gt;
　　　　　　　　continue; &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　　　System.out.print(word.charAt(i)); &lt;br /&gt;
　　　　} &lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/11721, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>열 개씩 끊어 출력하기
by BaekJoon</summary></entry><entry><title>[BaekJoon] 11720. Sum of Number</title><link href="http://localhost:4000/Baekjoon11720/" rel="alternate" type="text/html" title="[BaekJoon] 11720. Sum of Number" /><published>2020-09-18T00:00:00+09:00</published><updated>2020-09-18T00:00:00+09:00</updated><id>http://localhost:4000/Baekjoon11720</id><content type="html" xml:base="http://localhost:4000/Baekjoon11720/">&lt;h2 id=&quot;숫자의-합&quot;&gt;숫자의 합&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　입력으로 주어진 숫자 N개의 합을 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class NewClass{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　int sum = 0; &lt;br /&gt;
　　　　&lt;br /&gt;
　　　　int count = sc.nextInt(); &lt;br /&gt;
　　　　String num = sc.next(); &lt;br /&gt;
        &lt;br /&gt;
　　　　if(num.length() == count) { &lt;br /&gt;
　　　　　　for(int i = 0;i &amp;lt; count;i++) { &lt;br /&gt;
　　　　　　　　sum += Integer.parseInt(num.substring(i, i+1)); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　　　System.out.println(sum); &lt;br /&gt;
　　　　} else { &lt;br /&gt;
　　　　　　System.out.println(&quot;out of index&quot;); &lt;br /&gt;
　　　　　　return; &lt;br /&gt;
　　　　} &lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;　💌 string.charAt(i) - ‘0’&lt;br /&gt;
　　: string의 i 위치 char를 아스키 코드를 활용해 int로 변경&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/11720, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>숫자의 합
by BaekJoon</summary></entry></feed>
