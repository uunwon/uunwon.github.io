<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.6.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-04-26T17:11:27+09:00</updated><id>http://localhost:4000/</id><title>UUNWON</title><subtitle>Student at Korea Polytechnic University</subtitle><entry><title>Software Attack</title><link href="http://localhost:4000/SW-ATTACK/" rel="alternate" type="text/html" title="Software Attack" /><published>2021-04-21T00:00:00+09:00</published><updated>2021-04-21T00:00:00+09:00</updated><id>http://localhost:4000/SW-ATTACK</id><content type="html" xml:base="http://localhost:4000/SW-ATTACK/">&lt;h2 id=&quot;sw-개발-보안을-위한-공격기법의-이해-by-수제비&quot;&gt;SW 개발 보안을 위한 공격기법의 이해 by 수제비&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;DoS 공격&lt;/li&gt;
  &lt;li&gt;DDoS 공격&lt;/li&gt;
  &lt;li&gt;자원 고갈 공격&lt;/li&gt;
  &lt;li&gt;애플리케이션 공격&lt;/li&gt;
  &lt;li&gt;네트워크 서비스 공격&lt;/li&gt;
  &lt;li&gt;취약점 공격
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;dos-공격&quot;&gt;DoS 공격&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　Denial of Service 란 시스템을 악의적으로 공격해 해당 시스템의 자원을 부족하게 하여 원래 의도된 용도로 사용하지 못하게 하는 공격이다. DoS 공격의 종류에는 지역 시스템 공격과 원격 네트워크 공격이 있다.&lt;/p&gt;

&lt;p&gt;　&lt;code class=&quot;highlighter-rouge&quot;&gt;지역 시스템 공격&lt;/code&gt;은 실제 대상 시스템에 접근하여 서버 하드웨어에 직접 과부하를 주는 공격이고, &lt;code class=&quot;highlighter-rouge&quot;&gt;원격 네트워크 공격&lt;/code&gt;은 공격자가 목표 시스템에 접근하지 않고 원격지에서 인터넷 등을 이용한 공격이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;ddos-공격&quot;&gt;DDoS 공격&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　DoS의 또 다른 형태로 여러 대의 공격자를 분산 배치하여 동시에 동작하게 함으로써 특정 사이트를 공격하는 기법이다. 해커들이 취약한 인터넷 시스템에 대한 액세스가 이뤄지면, 침입한 시스템에 소프트웨어를 설치하고 이를 실행시켜 원격에서 공격을 개시한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;자원-고갈-공격&quot;&gt;자원 고갈 공격&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　서버 간 핸드셰이크를 통해 통신이 연결되는 정상 트래픽과 달리 DoS 공격은 정상 접속을 시도하는 오픈된 소켓에 트래픽을 집중시킨다. 공격이 임계치에 도달하면 사용자들은 네트워크에 전혀 접속할 수 없게 된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SYN 플러딩&lt;/code&gt;&lt;br /&gt;
TCP 프로토콜의 구조적인 문제를 이용한 공격으로, 공격자는 ACK를 발송하지 않고 계속 새로운 연결 요청을 하게 되어 (SYN 패킷) 서버는 자원할당을 해지하지 않고 자원만 소비하여 자원이 고갈된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TCP 세션 하이재킹&lt;/code&gt;&lt;br /&gt;
TCP Sequence number의 보안상 문제점 때문에 발생하며 TCP의 세션 관리 취약점을 이용한 공격 기법이다. TCP 세션 하이재킹에 대응하기 위해서는 비동기화 상태 탐지, ACK 패킷 비율 모니터링, 특정 세션에서 패킷 유실 및 재전송이 증가되는 것을 탐지해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UDP 플러딩&lt;/code&gt;&lt;br /&gt;
대량의 UDP 패킷을 만들어 임의의 포트 번호로 전송하여 응답 메시지(ICMP)를 생성하게 하여 지속해서 자원을 고갈시키는 공격&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;스머프&lt;/code&gt;&lt;br /&gt;
출발지 주소를 공격 대상의 IP로 설정하여 네트워크 전체에게 ICMP Echo 패킷을 직접 브로드캐스팅하여 마비시키는 공격&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PoD(Ping of Death)&lt;/code&gt;&lt;br /&gt;
큰 사이즈의 패킷을 의도적으로 목표시스템으로 발생시켜 시스템이 서비스할 수 없는 상태로 만드는 공격&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;애플리케이션-공격&quot;&gt;애플리케이션 공격&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP GET 플러딩&lt;/code&gt;&lt;br /&gt;
Http 캐시 옵션을 조작하여 캐싱 서버가 아닌 웹서버가 직접 처리하도록 유도, 웹서버 자원을 소진시키는 서비스 거부 공격&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Slowloris&lt;/code&gt;&lt;br /&gt;
HTTP GET 메소드를 사용하여 헤더의 최종 끝을 알리는 개행 문자열인 \r\n\r\n을 전송하지 않고, \r\n만 전송하여 대상 웹서버와 연결상태를 장시간 지속시키고 연결 자원을 모두 소진시키는 서비스 거부 공격&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RUDY&lt;/code&gt;&lt;br /&gt;
요청 헤더의 Content-length를 비정상적으로 크게 설정하여 메시지 바디 부분을 매우 소량으로 보내 계속 연결 상태를 유지시키는 공격&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;네트워크-서비스-공격&quot;&gt;네트워크 서비스 공격&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;네트워크 스캐너, 스니퍼&lt;/code&gt;&lt;br /&gt;
네트워크 하드웨어 및 소프트웨어 구성의 취약점 파악을 위해 공격자가 사용하는 공격 도구&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;패스워드 크래킹&lt;/code&gt;&lt;br /&gt;
사전(Dictionary) 크래킹과 무차별(Brute Force) 크래킹 방법을 사용해 네트워크 패스워드를 탐색&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IP 스푸핑&lt;/code&gt;&lt;br /&gt;
서버에 대한 인증되지 않은 액세스 권한을 입수하는 데 사용하는 기법&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;트로이 목마&lt;/code&gt;&lt;br /&gt;
악성 루틴이 숨어 있는 프로그램으로서 겉보기에는 정상적인 프로그램처럼 보이지만 실행하면 악성 코드를 실행&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;취약점-공격&quot;&gt;취약점 공격&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;랜드 어택&lt;/code&gt;&lt;br /&gt;
출발지 IP와 목적지 IP를 같은 패킷 주소로 만들어 보냄으로써 수신자가 자기 자신에게 응답을 보내게 하여 시스템의 가용성을 침해하는 공격기법&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;봉크(Bonk)/보잉크(Boink)&lt;/code&gt;&lt;br /&gt;
프로토콜의 오류 제어를 이용한 공격기법으로서 시스템의 패킷 재전송과 재조립이 과부하를 유발&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;티어 드롭&lt;/code&gt;&lt;br /&gt;
IP 패킷의 재조합 과정에서 잘못된 Fragment Offset 정보로 인해 수신시스템이 문제를 발생하도록 만드는 DoS 공격&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><category term="test" /><summary>SW 개발 보안을 위한 공격기법의 이해 by 수제비</summary></entry><entry><title>SQL</title><link href="http://localhost:4000/SQL/" rel="alternate" type="text/html" title="SQL" /><published>2021-04-20T00:00:00+09:00</published><updated>2021-04-20T00:00:00+09:00</updated><id>http://localhost:4000/SQL</id><content type="html" xml:base="http://localhost:4000/SQL/">&lt;h2 id=&quot;sql-by-수제비&quot;&gt;SQL by 수제비&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;절차형 SQL&lt;/li&gt;
  &lt;li&gt;데이터 분석 함수&lt;/li&gt;
  &lt;li&gt;데이터베이스 기본 연산&lt;/li&gt;
  &lt;li&gt;데이터 제어어 (DCL) 명령문 
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;절차형-sql&quot;&gt;절차형 SQL&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;프로시저(Procedure)&lt;/code&gt;&lt;br /&gt;
　절차형 SQL을 활용하여 특정 기능을 수행할 수 있는 트랜잭션 언어이다. 프로시저 호출을 통해 실행되며, 이를 통해 일련의 SQL 작업을 포함하는 데이터 조작어를 수행한다.&lt;/p&gt;

&lt;p&gt;　실행부(TRANSACTION) 는 해당 프로시저에서 수행한 DML을 DBMS에 반영할지 복구할지를 결정하는 부분이다. &lt;strong&gt;COMMIT&lt;/strong&gt;은 하나의 트랜잭션이 성공적으로 끝나고, 데이터베이스가 일관성 있는 상태에 있을 때 하나의 트랜잭션이 끝냈을 때 사용하는 연산이다. &lt;strong&gt;ROLLBACK&lt;/strong&gt;은 하나의 트랜잭션이 비정상적으로 종료되어 트랜잭션 원자성이 깨질 경우 처음부터 다시 시작하거나, 부분적으로 연산을 취소하는 연산이다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
EXECUTE 프로시저_명 (파라미터_1, 파라미터_2, .. );
&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;사용자 정의함수&lt;/code&gt;&lt;br /&gt;
　절차형 SQL을 활용하여 일련의 SQL 처리를 수행하여, 수행 결과를 &lt;strong&gt;단일 값으로 반환&lt;/strong&gt;할 수 있는 절차형 SQL이다. DBMS에서 제공되는 공통적 함수 이외에 사용자가 직접 정의하고 작성한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
함수명 (파라미터1, 파라미터2, ...)
&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;트리거(Trigger)&lt;/code&gt;&lt;br /&gt;
　특정 테이블에 삽입, 수정, 삭제 등의 데이터 변경 이벤트가 발생하면 DBMS에서 자동적으로 실행되도록 구현된 프로그램이다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;행 트리거&lt;/strong&gt;는 데이터 변화가 생길 때마다 실행되며, &lt;strong&gt;문장 트리거&lt;/strong&gt;는 트리거에 의해 단 한번 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;데이터-분석-함수&quot;&gt;데이터 분석 함수&lt;/h3&gt;

&lt;p&gt;　데이터 분석 함수란 총합, 평균 등의 데이터 분석을 위해 &lt;strong&gt;복수 행 기준의 데이터를 모아서 처리&lt;/strong&gt;하는 것을 목적으로 하는 다중 행 함수이다. GROUP BY 구문을 활용해 복수 행을 그룹핑한다.&lt;/p&gt;

&lt;h4 id=&quot;-집계-함수&quot;&gt;📌 집계 함수&lt;/h4&gt;
&lt;p&gt;　여러 행 또는 테이블 전체 행으로부터 하나의 결괏값을 반환하는 함수이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt;&lt;br /&gt;
해당 구문 뒤에 테이블을 구분하는 컬럼을 기재하여 그룹화한다. 실제 구체적인 데이터 분석값을 보고자 하는 컬럼 단위를 선정할 때 사용되는 기준이 된다. (속성값을 그룹으로 분류하고자 할 때)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HAVING&lt;/code&gt;&lt;br /&gt;
해당 구문은 WHERE 구문 내에는 사용할 수 없는 집계 함수의 구문을 적용하여 복수 행의 계산 결과를 조건별로 적용하는 데 사용된다. 즉, GROUP BY 및 집계 함수에 대한 WHERE 구문이다. (그룹에 제하는 조건문을 작성할 수 있는 절)&lt;/p&gt;

&lt;h4 id=&quot;-그룹-함수&quot;&gt;📌 그룹 함수&lt;/h4&gt;
&lt;p&gt;　테이블의 전체 행을 하나 이상의 컬럼을 기준으로 컬럼 값에 따라 그룹화하여 그룹별로 결과를 출력하는 함수이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ROLLUP&lt;/code&gt;&lt;br /&gt;
해당 함수에 의해 지정된 컬럼은 중간 집계 값을 산출할 수 있는 그룹 함수로, 지정 컬럼의 수보다 하나 더 큰 레벨만큼의 중간 집계 값이 생성된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CUBE&lt;/code&gt;&lt;br /&gt;
결합 가능한 모든 값에 대해 다차원 집계를 생성하는 그룹 함수이다. 연산이 많아 시스템에 부담을 준다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GROUPING SETS&lt;/code&gt;&lt;br /&gt;
집계 대상 컬럼들에 대한 개별 집계를 구할 수 있으며, ROLLUP이나 CUBE와는 달리 컬럼 간 순서와 무관한 결과를 얻을 수 있는 그룹 함수이다.&lt;/p&gt;

&lt;h4 id=&quot;-윈도-함수&quot;&gt;📌 윈도 함수&lt;/h4&gt;
&lt;p&gt;　데이터베이스를 사용한 &lt;strong&gt;온라인 분석 처리&lt;/strong&gt; 용도로 사용하기 위해서 표준 SQL에 추가된 함수다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;순위 함수&lt;/code&gt;&lt;br /&gt;
레코드의 순위를 계산하는 함수&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;행순위 함수&lt;/code&gt;&lt;br /&gt;
레코드에서 가장 먼저 나오거나 가장 뒤에 나오는 값, 이전/이후의 값들을 출력하는 함수&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;그룹 내 비율 함수&lt;/code&gt;&lt;br /&gt;
백분율을 보여주거나 행의 순서별 백분율 등 비율과 관련된 통계를 보여주는 함수&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;데이터베이스-기본-연산&quot;&gt;데이터베이스 기본 연산&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 데이터의 내용을 조회할 때 사용하는 명령어&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
SELECT [ALL | DISTINCT | DISTINCTALL] 속성명1, 속성명2, .. &lt;br /&gt;
FROM 테이블명1, ... &lt;br /&gt;
[WHERE 조건] &lt;br /&gt;
[GROUP BY 속성명1, ..] &lt;br /&gt;
[HAVING 그룹조건] &lt;br /&gt;
[ORDER BY 속성 [ASC | DESC]];
&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;INSERT&lt;/code&gt; 데이터의 내용을 삽입할 때 사용하는 명령어&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
INSERT INTO 테이블명(속성명1, ..) VALUES(데이터1, ..);
&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 데이터의 내용을 변경할 때 사용하는 명령어&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
UPDATE 테이블명 SET 속성명 = 데이터, .. WHERE 조건;
&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DELETE&lt;/code&gt; 데이터의 내용을 삭제할 때 사용하는 명령어&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
DELETE FROM 테이블명 WHERE 조건;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;데이터-제어어-dcl-명령문&quot;&gt;데이터 제어어 (DCL) 명령문&lt;/h3&gt;

&lt;p&gt;　DCL은 데이터베이스 관리자가 데이터 보안, 무결성 유지, 병행 제어, 회복을 위해 관리자(DBA)가 사용하는 제어용 언어다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GRANT 권한 ON 테이블 TO 사용자&lt;/code&gt;&lt;br /&gt;
관리자가 사용자에게 데이터베이스에 대한 권한을 부여하는 명령어&lt;br /&gt;
(+ WITH GRANT OPTION)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;REVOKE 권한 ON 테이블 FROM 사용자&lt;/code&gt;&lt;br /&gt;
관리자가 사용자에게 부여했던 권한을 회수하기 위한 명령어&lt;br /&gt;
(+ CASCADE CONSTRAINTS)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;plus&quot;&gt;PLUS&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;&lt;strong&gt;뷰 생성&lt;/strong&gt;: CREATE VIEW 이름 AS (조건); &lt;br /&gt;
&lt;strong&gt;인덱스 생성&lt;/strong&gt;: CREATE INDEX 이름 ON 조건; &lt;br /&gt;
&lt;strong&gt;UNION&lt;/strong&gt;: 합집합이면서 중복 제거 &lt;br /&gt;
&lt;strong&gt;UNIONALL&lt;/strong&gt;: 합집합이면서 중복 허용&lt;/p&gt;</content><category term="test" /><summary>SQL by 수제비</summary></entry><entry><title>Protocol</title><link href="http://localhost:4000/Protocol/" rel="alternate" type="text/html" title="Protocol" /><published>2021-04-20T00:00:00+09:00</published><updated>2021-04-20T00:00:00+09:00</updated><id>http://localhost:4000/Protocol</id><content type="html" xml:base="http://localhost:4000/Protocol/">&lt;h2 id=&quot;protocol&quot;&gt;Protocol&lt;/h2&gt;

&lt;p&gt;　&lt;strong&gt;프로토콜&lt;/strong&gt;은 서로 다른 시스템이나 기기들 간의 데이터 교환을 원활히 하기 위해 표준화된 통신규약&lt;/p&gt;

&lt;h3 id=&quot;soap&quot;&gt;SOAP&lt;/h3&gt;
&lt;p&gt;Simple Object Access Protocol(SOAP) 은 HTTP, HTTPS, SMTP 등을 사용하여 XML 기반의 메시지를 네트워크 상태에서 교환하는 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ipsec&quot;&gt;IPsec&lt;/h3&gt;
&lt;p&gt;IP 계층(3계층) 에서 무결성과 인증을 보장하는 인증헤더(AH)와 기밀성을 보장하는 암호화(ESP)를 이용하여 양 종단 간 구간에 보안서비스를 제공하는 IP 계층 보안 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ike&quot;&gt;IKE&lt;/h3&gt;
&lt;p&gt;Internet Key Exchange 는 보안 관련 설정들을 생성, 협상 및 관리하는 프로토콜로 UDP 500번 포트를 사용하는 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ssh&quot;&gt;SSH&lt;/h3&gt;
&lt;p&gt;네트워크 보안도구 중 하나로 원격 접속을 안전하게 할 수 있게 해주는 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;tls&quot;&gt;TLS&lt;/h3&gt;
&lt;p&gt;SSH에서 발전된 프로토콜로 네트워크 통신보안을 위해 설계된 암호 규약으로 국제 표준 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ssl&quot;&gt;SSL&lt;/h3&gt;
&lt;p&gt;응용 계층과 TCP/IP 계층 사이에서 웹 데이터 암호화 및 전송 시 기밀성을 보장하는 공개키 기반의 보안 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ah&quot;&gt;AH&lt;/h3&gt;
&lt;p&gt;Authentication Header 는 기밀성(암호화)를 제외한 메시지 checksum을 활용한 데이터 인증과 비연결형 무결성을 보장해주는 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;esp&quot;&gt;ESP&lt;/h3&gt;
&lt;p&gt;Eucapsulating Security Payload 는 암호화 알고리즘을 활용한 캡슐화 기반 페이로드 기밀성을 제공하는 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ldap&quot;&gt;LDAP&lt;/h3&gt;
&lt;p&gt;TCP/IP 위에서 디렉토리 서비스를 조회하고 수정하는 응용 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ipv4&quot;&gt;IPv4&lt;/h3&gt;
&lt;p&gt;인터넷에서 사용되는 패킷 교환 네트워크 상에서 데이터를 교환하기 위한 32bit 주소체계를 갖는 네트워크 계층 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ipv6&quot;&gt;IPv6&lt;/h3&gt;
&lt;p&gt;현재 IPv4가 가지고 있는 주소 고갈, 보안성, 이동성 지원 등의 문제점을 해결하기 위해서 개발된 128bit 주소 체계를 갖는 차세대 인터넷 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ftp&quot;&gt;FTP&lt;/h3&gt;
&lt;p&gt;파일 전송 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;smtp&quot;&gt;SMTP&lt;/h3&gt;
&lt;p&gt;메일 전송 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;telnet&quot;&gt;telnet&lt;/h3&gt;
&lt;p&gt;원격 접속 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;ip&quot;&gt;IP&lt;/h3&gt;
&lt;p&gt;Internet Protocol은 주소 지정 가능한 연결형 프로토콜, 송신/수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는 데 사용하는 통신규약&lt;/p&gt;

&lt;h3 id=&quot;icmp&quot;&gt;ICMP&lt;/h3&gt;
&lt;p&gt;Internet Control Message Protocol은 IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜로 수신지 도달 불가 메시지를 통해 수신지 또는 서비스에 도달할 수 없는 호스트를 통지하는 데 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;igmp&quot;&gt;IGMP&lt;/h3&gt;
&lt;p&gt;호스트 컴퓨터와 인접 라우터가 멀티캐스트 그룹 멤버십을 구성하는데 사용하는 통신 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;tcp&quot;&gt;TCP&lt;/h3&gt;
&lt;p&gt;전송 계층에 위치하면서 근거리 통신망이나 인트라넷, 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 옥텟을 안정적으로, 순서대로, 에러 없이 교환할 수 있게 해주는 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;udp&quot;&gt;UDP&lt;/h3&gt;
&lt;p&gt;비연결성이고, 신뢰성이 없고, 순서화되지 않은 데이터그램 서비스를 제공하는 전송(Transport, 4계층) 계층의 통신 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;x25&quot;&gt;X.25&lt;/h3&gt;
&lt;p&gt;통신을 원하는 두 단말장치가 패킷 교환망을 통해 패킷을 원활히 전달하기 위한 통신 프로토콜 (고정된 대역폭, 패킷 사용, 1~3계층 담당, 송수신 신뢰성, 성능 저하)&lt;/p&gt;

&lt;h3 id=&quot;프레임-릴레이&quot;&gt;프레임 릴레이&lt;/h3&gt;
&lt;p&gt;ISDN을 사용하기 위한 프로토콜 (유연한 대역폭, 기능 단순화, 1~2계층 담당, 저렴한 가격) (ISDN = 디지털 통신망을 이용해 음성ㆍ문자ㆍ영상 등의 통신을 종합적으로 할 수 있도록 하는 통신서비스)&lt;/p&gt;

&lt;h3 id=&quot;atm&quot;&gt;ATM&lt;/h3&gt;
&lt;p&gt;정보 전달의 기본단위를 53byte 셀 단위로 전달하는 비동기식 시분할 다중화 방식의 패킷형 전송 기술 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;arp&quot;&gt;ARP&lt;/h3&gt;
&lt;p&gt;IP 주소를 MAC 주소로 변환하는 프로토콜&lt;/p&gt;

&lt;h3 id=&quot;라우팅-알고리즘&quot;&gt;라우팅 알고리즘&lt;/h3&gt;
&lt;p&gt;　데이터는 송신 측으로부터 수신 측까지 데이터를 전달하는 과정에서 다양한 물리적인 장치들을 거쳐 간다. &lt;strong&gt;목적지까지의 최적 경로를 산출&lt;/strong&gt;하기 위한 법칙이 라우팅 알고리즘이다. 라우팅 알고리즘에는 인접 라우터와 정보를 공유하여 목적지까지 거리와 방향을 결정하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;거리벡터 알고리즘&lt;/code&gt;과 링크 상태 정보를 모든 라우터에 전달하여 최단 경로 트리를 구성하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;링크상태 알고리즘&lt;/code&gt;이 있다.&lt;/p&gt;

&lt;h4 id=&quot;-rip&quot;&gt;📌 RIP&lt;/h4&gt;
&lt;p&gt;최초의 라우팅 프로토콜, 거리 벡터 알고리즘 활용하여 30초 주기로 전체 라우팅의 정보를 갱신, 변화 업데이트 시 많은 시간이 소요&lt;/p&gt;
&lt;h4 id=&quot;-igrp&quot;&gt;📌 IGRP&lt;/h4&gt;
&lt;p&gt;RIP의 문제점 개선, 네트워크 상태를 고려하여 라우팅&lt;/p&gt;
&lt;h4 id=&quot;-ospf&quot;&gt;📌 OSPF&lt;/h4&gt;
&lt;p&gt;링크 상태 알고리즘을 사용, 발생한 변경 정보에 대해 RIP 보다 빠른 업데이트&lt;/p&gt;
&lt;h4 id=&quot;-bgp&quot;&gt;📌 BGP&lt;/h4&gt;
&lt;p&gt;규모가 큰 네트워크의 상호 연결&lt;/p&gt;

&lt;h3 id=&quot;osi-7계층-프로토콜&quot;&gt;OSI 7계층 프로토콜&lt;/h3&gt;
&lt;p class=&quot;notice&quot;&gt;
응용 http ftp &lt;br /&gt;
표현 jpeg mpeg &lt;br /&gt;
세션 ssh tls ssl &lt;br /&gt;
전송 tcp udp &lt;br /&gt;
네트워크 ip icmp &lt;br /&gt;
데이터 이더넷 &lt;br /&gt;
물리 rs-232c
&lt;/p&gt;</content><category term="test" /><summary>Protocol</summary></entry><entry><title>Process</title><link href="http://localhost:4000/Process/" rel="alternate" type="text/html" title="Process" /><published>2021-04-19T00:00:00+09:00</published><updated>2021-04-19T00:00:00+09:00</updated><id>http://localhost:4000/Process</id><content type="html" xml:base="http://localhost:4000/Process/">&lt;h2 id=&quot;process-by-수제비&quot;&gt;Process by 수제비&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스&lt;/li&gt;
  &lt;li&gt;프로세스 상태 전이&lt;/li&gt;
  &lt;li&gt;프로세스 스케줄링 
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;프로세스&quot;&gt;프로세스&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　프로세스(Process)란 일반적으로 CPU에 의해 처리되는 프로그램으로 현재 실행 중인 프로그램을 말한다. 하나의 프로세스는 여러가지 이벤트에 의해 일련의 서로 구분되는 &lt;strong&gt;상태 변화&lt;/strong&gt;(생성 상태, 준비 상태, 실행 상태, 대기 상태, 완료 상태) 를 겪는다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스-상태-전이&quot;&gt;프로세스 상태 전이&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　프로세스의 상태 전이는 하나의 작업이 컴퓨터 시스템에 입력되어 완료되기까지 프로세스의 상태가 준비, 실행 및 대기 상태로 변하는 활동을 말한다. &lt;strong&gt;활동 상태&lt;/strong&gt;는 프로세스가 기억장치를 할당받은 상태이며, &lt;strong&gt;지연 상태&lt;/strong&gt;는 기억장치를 할당받지 못한 상태이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;img src=&quot;http://localhost:4000/images/process_state.png&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;디스패치&lt;/strong&gt;는 준비 상태에 있는 여러 프로세스(Ready list) 중 실행될 프로세스를 선정(Scheduling)하여 CPU를 할당(Dispatching)하는 것으로 문맥교환(Context switching)이 발생한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스-스케줄링&quot;&gt;프로세스 스케줄링&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　프로세스 스케줄링은 CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 작업이다. 하나의 프로세스가 CPU를 차지하고 있을 때, 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 방식인 &lt;code class=&quot;highlighter-rouge&quot;&gt;선점형 스케줄링&lt;/code&gt;과 한 프로세스가 CPU를 할당받으면 작업 종료 후 CPU 반환 시까지 다른 프로세스는 CPU 점유가 불가능한 &lt;code class=&quot;highlighter-rouge&quot;&gt;비선점형 스케줄링&lt;/code&gt; 방식이 있다.&lt;/p&gt;

&lt;h4 id=&quot;-선점형-스케줄링&quot;&gt;📌 선점형 스케줄링&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;라운드로빈(Round Robin)&lt;/code&gt;&lt;br /&gt;
프로세스는 같은 크기의 CPU 시간을 할당, 프로세스가 할당된 시간 내에 처리 완료를 목하면 준비 큐 리스트의 가장 뒤로 보내지고, CPU는 대기 중인 다음 프로세스로 넘어감&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SRT(Shortest Remaing Time)&lt;/code&gt;&lt;br /&gt;
가장 짧은 시간이 소요되는 프로세스를 먼저 수행하고, 남은 처리 시간이 더 짧다고 판단되는 프로세스가 준비 큐에 생시면 언제라도 프로세스가 선정됨&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;다단계 큐&lt;/code&gt;&lt;br /&gt;
작업들을 여러 종류의 그룹으로 분할, 여러 개의 큐를 이용하여 상위단계 작업에 의한 하위단계 작업이 선정 당함&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;다단계 피드백 큐&lt;/code&gt;&lt;br /&gt;
FCFS(FIFO)와 라운드로빈 스케줄링 혼합, 새로운 프로세스는 높은 우선순위를 가지며 프로세스의 실행 시간이 길어질수록 점점 낮은 우선순위 큐로 이동하며 마지막 단계는 RR을 적용함&lt;/p&gt;

&lt;h4 id=&quot;-비선점형-스케줄링&quot;&gt;📌 비선점형 스케줄링&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;우선순위&lt;/code&gt;&lt;br /&gt;
프로세스별로 우선순위가 주어지고, 우선순위에 따라 CPU를 할당함&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;기한부(Deadline)&lt;/code&gt;&lt;br /&gt;
작업들이 명시된 시간이나 기한 내에 완료되도록 계획&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FCFS&lt;/code&gt;&lt;br /&gt;
프로세스가 대기 큐에 도착한 순서에 따라 CPU를 할당함&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SJF(Shortest Job First)&lt;/code&gt;&lt;br /&gt;
프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료 시까지 자원 점유&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HRN(Highest Response Ratio Next)&lt;/code&gt;&lt;br /&gt;
대기 중인 프로세스 중 현재 응답률이 가장 높은 것을 선택, 기아현상 최소화 (= 대기시간+서비스시간 / 서비스시간)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;concept&quot;&gt;CONCEPT&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;&lt;strong&gt;문맥교환(Context switching)&lt;/strong&gt;: CPU가 현재 실행하고 있는 프로세스의 문맥 상태를 프로세스 제어블록(PCB)에 저장하고 다음 프로세스의 PCB로부터 문맥을 복원하는 작업 &lt;br /&gt;
&lt;strong&gt;기아현상(starvation)&lt;/strong&gt;: 시스템 부하가 많아 준비 큐에 있는 낮은 등급의 프로세스가 무한정 기다리는 현상 &lt;br /&gt;
&lt;strong&gt;에이징 기법(Aging)&lt;/strong&gt;: 프로세스가 자원을 기다리고 있는 시간에 비례하여 우선순위를 부여함으로써 무기한 대기하는 문제를 방지하는 기법&lt;/p&gt;</content><category term="test" /><summary>Process by 수제비</summary></entry><entry><title>Software Test</title><link href="http://localhost:4000/Software-Test/" rel="alternate" type="text/html" title="Software Test" /><published>2021-04-18T00:00:00+09:00</published><updated>2021-04-18T00:00:00+09:00</updated><id>http://localhost:4000/Software-Test</id><content type="html" xml:base="http://localhost:4000/Software-Test/">&lt;h2 id=&quot;software-test-by-수제비&quot;&gt;Software Test by 수제비&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;소프트웨어 테스트&lt;/li&gt;
  &lt;li&gt;프로그램 실행 여부에 따른 분류&lt;/li&gt;
  &lt;li&gt;테스트 기법에 따른 분류&lt;/li&gt;
  &lt;li&gt;테스트 시각에 따른 분류&lt;/li&gt;
  &lt;li&gt;테스트 목적에 따른 분류&lt;/li&gt;
  &lt;li&gt;테스트 오라클
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;소프트웨어-테스트&quot;&gt;소프트웨어 테스트&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　소프트웨어 테스트란 개발된 응용 애플리케이션이나 시스템이 사용자가 요구하는 기능과 성능, 사용성, 안정성 등을 만족하는지 확인하고, 노출되지 않은 숨어있는 소프트웨어의 결함을 찾아내는 활동이다.&lt;/p&gt;

&lt;p&gt;　위와 같은 테스트는 오류 발견 관점, 오류 예방 관점, 품질 향상 관점에서 필요하다.&lt;/p&gt;

&lt;h4 id=&quot;-소프트웨어-테스트-산출물&quot;&gt;📌 소프트웨어 테스트 산출물&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;
- &lt;b&gt;테스트 계획서&lt;/b&gt;: 테스트 수행을 계획한 문서&lt;br /&gt;
- &lt;b&gt;테스트 케이스&lt;/b&gt;: 테스트를 위한 설계 산출물로, 응용 소프트웨어가 사용자의 요구사항을 준수하는지 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과로 구성된 테스트 항목의 명세서&lt;br /&gt;
- &lt;b&gt;테스트 시나리오&lt;/b&gt;: 테스트 수행을 위한 여러 개의 테스트 케이스의 집합으로 테스트 케이스의 동작 순서를 기술한 문서&lt;br /&gt;
- &lt;b&gt;테스트 결과서&lt;/b&gt;: 테스트 결과를 정리한 문서
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로그램-실행-여부에-따른-분류&quot;&gt;프로그램 실행 여부에 따른 분류&lt;/h3&gt;

&lt;h4 id=&quot;정적-테스트&quot;&gt;정적 테스트&lt;/h4&gt;
&lt;p&gt;　프로그램의 실행 없이 &lt;strong&gt;구조를 분석&lt;/strong&gt;하여 논리성을 검증하는 테스트&lt;br /&gt;
　(ex) 동료 검토, 워크스루, 인스펙션&lt;/p&gt;

&lt;h4 id=&quot;동적-테스트&quot;&gt;동적 테스트&lt;/h4&gt;
&lt;p&gt;　프로그램 실행을 요구하는 테스트&lt;br /&gt;
　(ex) 화이트박스 테스트, 블랙박스 테스트&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-기법에-따른-분류&quot;&gt;테스트 기법에 따른 분류&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;화이트박스 테스트&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;제어구조 테스트&lt;/strong&gt;&lt;br /&gt;
소프트웨어의 논리적 복잡도 측정 후 수행 경로들의 집합을 정의하는 테스트&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;루프 테스트&lt;/strong&gt;&lt;br /&gt;
프로그램의 루프 구조에 국한해서 실시하는 테스트&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;블랙박스 테스트&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;동등분할 테스트&lt;/strong&gt;&lt;br /&gt;
입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 대표값 테스트 케이스를 도출하여 케이스를 도출하여 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;경계 값 분석 테스트&lt;/strong&gt;&lt;br /&gt;
등가분할 후 경계 값 부분에서 오류 발생 확률이 높기에 경계 값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;결정 테이블 테스트&lt;/strong&gt;&lt;br /&gt;
요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합하여 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;상태전이 테스트&lt;/strong&gt;&lt;br /&gt;
테스트 대상/시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;유스케이스 테스트&lt;/strong&gt;&lt;br /&gt;
시스템이 실제 사용되는 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화하여 수행하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;분류트리 테스트&lt;/strong&gt;&lt;br /&gt;
SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;페어와이즈 테스트&lt;/strong&gt;&lt;br /&gt;
Test data 값들 간에 최소한 한 번씩을 조합하는 방식이며, 이는 커버해야 할 기능적 범위를 모든 조합에 비해 상대적으로 적은 양의 테스트 세트를 구성하기 위한 테스트 기법&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-시각에-따른-분류&quot;&gt;테스트 시각에 따른 분류&lt;/h3&gt;

&lt;h4 id=&quot;검증verification&quot;&gt;검증(Verification)&lt;/h4&gt;
&lt;p&gt;　소프트웨어 과정을 테스트&lt;/p&gt;

&lt;h4 id=&quot;확인validation&quot;&gt;확인(Validation)&lt;/h4&gt;
&lt;p&gt;　소프트웨어 결과를 테스트&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-목적에-따른-분류&quot;&gt;테스트 목적에 따른 분류&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
ㆁ &lt;strong&gt;회복 테스트&lt;/strong&gt;&lt;br /&gt;
시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여부를 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;안전 테스트&lt;/strong&gt;&lt;br /&gt;
소스 코드 내의 보안적인 결함을 미리 점검하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;강도 테스트&lt;/strong&gt;&lt;br /&gt;
시스템 과부하 시에도 정상 작동되는지를 검증하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;성능 테스트&lt;/strong&gt;&lt;br /&gt;
이벤트에 응답하는 시간, 처리하는 업무량 등을 측정하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;구조 테스트&lt;/strong&gt;&lt;br /&gt;
시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;회귀 테스트&lt;/strong&gt;&lt;br /&gt;
오류를 제거하거나 수정한 시스템에서 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지 확인하는 일종의 반복 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;병행 테스트&lt;/strong&gt;&lt;br /&gt;
변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과를 비교하는 테스트 기법&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-오라클&quot;&gt;테스트 오라클&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참 값을 입력하여 비교하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;참 오라클&lt;/strong&gt;&lt;br /&gt;
모든 입력값에 대하여 기대하는 결과를 생성함으로써 발생된 오류를 모두 검출할 수 있는 오라클&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;샘플링 오라클&lt;/strong&gt;&lt;br /&gt;
특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;휴리스틱 오라클&lt;/strong&gt;&lt;br /&gt;
샘플링 오라클을 개선한 오라클로, 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;일관성 검사 오라클&lt;/strong&gt;&lt;br /&gt;
애플리케이션 변경이 있을 때, 수행 전과 후의 결괏값이 동일한지 확인하는 오라클&lt;/p&gt;</content><category term="test" /><summary>Software Test by 수제비</summary></entry><entry><title>Design Pattern</title><link href="http://localhost:4000/Design-Pattern/" rel="alternate" type="text/html" title="Design Pattern" /><published>2021-04-17T00:00:00+09:00</published><updated>2021-04-17T00:00:00+09:00</updated><id>http://localhost:4000/Design-Pattern</id><content type="html" xml:base="http://localhost:4000/Design-Pattern/">&lt;h2 id=&quot;design-pattern-by-수제비&quot;&gt;Design Pattern by 수제비&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;디자인 패턴&lt;/li&gt;
  &lt;li&gt;디자인 패턴 분류&lt;/li&gt;
  &lt;li&gt;디자인 패턴 종류&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;디자인-패턴&quot;&gt;디자인 패턴&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　소프트웨어 개발 방법에서 사용되는 &lt;strong&gt;디자인 패턴&lt;/strong&gt;은 프로그램 개발에서 자주 나타나는 과제를 해결하기 위한 방법 중 하나로, 과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재사용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다. 알고리즘과 같이 프로그램 코드로 바로 변환될 수 있는 형태는 아니지만, 특정한 상황에서 구조적인 문제를 해결하는 방식이다.&lt;/p&gt;

&lt;p&gt;　즉, 소프트웨어를 설계할 때 또는 프로그램 개발 과정에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;특정 부분에서 많이 발생하는 문제를 정리&lt;/code&gt;하여 상황에 따라 해결할 수 있는 해결책 (패턴)이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;디자인-패턴-분류&quot;&gt;디자인 패턴 분류&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
① &lt;strong&gt;생성 패턴(Creational Pattern)&lt;/strong&gt;&lt;br /&gt;
　: 객체의 생성과 관련된 패턴&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
추상 팩토리(Abstract Factory), 빌더(Builder), 팩토리 메소드(Factory Method), 프로토타입(Prototype), 싱글톤(Singleton)
&lt;/p&gt;

&lt;p&gt;② &lt;strong&gt;구조 패턴(Structural Pattern)&lt;/strong&gt;&lt;br /&gt;
　: 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
어댑터(Adapter), 브리지(Bridge), 컴포지트(Composite), 데코레이터(Decorator), 퍼싸드(Facade), 플라이웨이트(Flyweight), 프록시(Proxy)
&lt;/p&gt;

&lt;p&gt;③ &lt;strong&gt;행위 패턴(Behavioral Pattern)&lt;/strong&gt;&lt;br /&gt;
　: 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
책임 연쇄(Chain of Responsibility), 커맨드(Command), 인터프리터(Interpreter), 반복자(Iterator), 중재자(Mediator), 메멘토(Memento), 옵서버(Observer), 상태(State), 전략(Strategy), 템플릿 메소드(Template Method), 방문자(Visitor)
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;디자인-패턴-종류&quot;&gt;디자인 패턴 종류&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
ㆁ &lt;strong&gt;Abstract Factory&lt;/strong&gt;&lt;br /&gt;
　구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Factroy Method&lt;/strong&gt;&lt;br /&gt;
　객체 생성 처리를 서브(하위) 클래스로 분리해 처리하도록 캡슐화하는 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Singleton&lt;/strong&gt;&lt;br /&gt;
　전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Builder&lt;/strong&gt;&lt;br /&gt;
　복잡한 인스턴스를 조립하여 만드는 구조로, 복합 객체를 생성할 때 객체를 생성하는 방법(과정)과 객체를 구현(표현)하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Bridge&lt;/strong&gt;&lt;br /&gt;
　기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Adapter&lt;/strong&gt;&lt;br /&gt;
　기존 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴으로, 상속을 이용하여 클래스 패턴과 위임을 이용하는 인스턴스 패턴의 두가지 형태로 사용되는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Composite&lt;/strong&gt;&lt;br /&gt;
　객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Prototype&lt;/strong&gt;&lt;br /&gt;
　처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴으로, 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하며 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용되는 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Decorator&lt;/strong&gt;&lt;br /&gt;
　객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주는 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Observer&lt;/strong&gt;&lt;br /&gt;
　한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Iterator&lt;/strong&gt;&lt;br /&gt;
　컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있는 방법을 제공하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;State&lt;/strong&gt;&lt;br /&gt;
　객체의 상태에 따라 객체의 행위 내용을 변경해주는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Strategy&lt;/strong&gt;&lt;br /&gt;
　행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Template Method&lt;/strong&gt;&lt;br /&gt;
　어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Command&lt;/strong&gt;&lt;br /&gt;
　실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Visitor&lt;/strong&gt;&lt;br /&gt;
　각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴으로, 객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 사용하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Mediator&lt;/strong&gt;&lt;br /&gt;
　객체지향설계에서 객체의 수가 너무 많아지면 서로 통신하느라 복잡해져 객체지향에서 가장 중요한 느슨한 결합의 특성을 해칠 수 있다. 이를 해결하는 한가지 방법으로 중간에 이를 통제하고 지시할 수 있는 역할을 하는 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체지향의 목표를 달성하게 해주는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Memento&lt;/strong&gt;&lt;br /&gt;
　객체를 이전 상태로 복구시켜야하는 경우, ‘작업취소(undo)’를 요청하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Interpreter&lt;/strong&gt;&lt;br /&gt;
　언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 디자인 패턴 (문법 자체를 캡슐화)&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Facade&lt;/strong&gt;&lt;br /&gt;
　복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자와 시스템 간, 또는 여타 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴이다. 오류에 대해서 단위별로 확인할 수 있게 하며, 사용자의 측면에서 단순한 인터페이스를 제공하여 접근성을 높일 수 있는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Chain of Responsibility&lt;/strong&gt;&lt;br /&gt;
　정적으로 어떤 기능에 대한 처리의 연결이 하드코딩되어 있을 시, 기능 처리의 연결 변경이 불가능한데 이를 동적으로 연결되어 있는 경우에 따라서 다르게 처리될 수 있도록 연결한 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Proxy&lt;/strong&gt;&lt;br /&gt;
　’실체 객체에 대한 대리 객체’ 로 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이 점을 이용해 미리 할당하지 않아도 상관없는 것들을 실제 이용할 때 할당하게 하여 메모리 용량을 아낄 수 있으며, 실체 객체를 드러나지 않게 하여 정보은닉의 역할도 수행하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Flyweight&lt;/strong&gt;&lt;br /&gt;
　다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 클래스화하여 공유함으로써 메모리를 절약하고, ‘클래스의 경량화’를 목적으로 하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://helloworld-88.tistory.com/291 &lt;br /&gt;
https://www.notion.so/23-1959a781210b48b0b726cba983231649&lt;/p&gt;</content><category term="test" /><summary>Design Pattern by 수제비</summary></entry><entry><title>Class, Object, Instance</title><link href="http://localhost:4000/Class-Object/" rel="alternate" type="text/html" title="Class, Object, Instance" /><published>2021-04-14T00:00:00+09:00</published><updated>2021-04-14T00:00:00+09:00</updated><id>http://localhost:4000/Class-Object</id><content type="html" xml:base="http://localhost:4000/Class-Object/">&lt;h2 id=&quot;class-object-instance&quot;&gt;Class, Object, Instance&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;클래스 (Class)&lt;/li&gt;
  &lt;li&gt;객체 (Object)&lt;/li&gt;
  &lt;li&gt;인스턴스 (Instance)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-class&quot;&gt;🔑 Class&lt;/h3&gt;
&lt;p&gt;　객체를 만들어내기 위한 설계도 혹은 틀&lt;br /&gt;
　연관되어 있는 변수와 메서드의 집합&lt;br /&gt;
　-&amp;gt; 클래스란 객체를 정의해놓은 것으로써, 객체를 생성하는데 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-object&quot;&gt;🪓 Object&lt;/h3&gt;
&lt;p&gt;　소프트웨어 세계에 구현할 대상&lt;br /&gt;
　클래스에 선언된 모양 그대로 생성된 실체&lt;br /&gt;
　-&amp;gt; 클래스의 인스턴스라고도 부르며, 모든 인스턴스를 대표하는 포괄적인 의미를 가진다. oop의 관점에서 &lt;strong&gt;클래스의 타입&lt;/strong&gt;으로 선언되었을 때 ‘객체’라고 부른다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-instance&quot;&gt;🔨 Instance&lt;/h3&gt;
&lt;p&gt;　설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체&lt;br /&gt;
　객체를 소프트웨어에 실체화한 것
　실체화된 인스턴스는 메모리에 할당됨  &lt;br /&gt;
　-&amp;gt; oop의 관점에서 &lt;strong&gt;객체가 메모리에 할당&lt;/strong&gt;되어 실제 사용될 때 ‘인스턴스’라 부르며, 추상적인 개념과 구체적인 객체 사이의 &lt;strong&gt;관계&lt;/strong&gt;에 초점을 맞출 경우에 ‘~의 인스턴스’ 형태로 사용된다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
/* 클래스 */ &lt;br /&gt;
public class Animal{ &lt;br /&gt;
　　... &lt;br /&gt;
 } &lt;br /&gt;
/* 객체와 인스턴스 */ &lt;br /&gt;
public class Main { &lt;br /&gt;
　public static void main(String[] args) &lt;br /&gt;
　　　　Animal cat, dog; // '객체' &lt;br /&gt;
　　　　// 인스턴스화 &lt;br /&gt;
　　　　cat = new Animal(); // cat은 Animal 클래스의 '인스턴스' (객체를 메모리에 할당) &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p&gt;https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html &lt;br /&gt;&lt;/p&gt;</content><category term="java" /><summary>Class, Object, Instance</summary></entry><entry><title>[BoostCourse] Hello, Kotlin</title><link href="http://localhost:4000/BoostCourse-HelloKotlin/" rel="alternate" type="text/html" title="[BoostCourse] Hello, Kotlin" /><published>2021-02-04T00:00:00+09:00</published><updated>2021-02-04T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-HelloKotlin</id><content type="html" xml:base="http://localhost:4000/BoostCourse-HelloKotlin/">&lt;h2 id=&quot;코틀린을-왜-배워야-할까&quot;&gt;코틀린을 왜 배워야 할까?&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린을 왜 배워야 할까?&lt;/li&gt;
  &lt;li&gt;코틀린의 매력을 알아볼까요?&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어에 대한 경험담&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-코틀린을-왜-배워야-할까&quot;&gt;🔑 코틀린을 왜 배워야 할까?&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　코틀린은 새롭게 부상하고 있는 안드로이드 모바일 앱을 제작하기 위한 언어다. 많은 기업들이 자바에서 코틀린으로 갈아타는 모습을 볼 수 있으며, 개발자들의 선호도 또한 높은 편에 속한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-코틀린의-매력을-알아볼까요&quot;&gt;🪓 코틀린의 매력을 알아볼까요?&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　코틀린의 특징&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Statically typed&lt;/strong&gt;: 정적 타입 언어 (컴파일시 변수의 자료형이 결정됨) &lt;br /&gt; &lt;strong&gt;Interoperable&lt;/strong&gt;: Kotile/JVM을 사용해 자바와 100% 호환 &lt;br /&gt; &lt;strong&gt;Null safety&lt;/strong&gt;: NPE(Null Pointer Exception)를 방지할 수 있는 안전성 &lt;br /&gt; &lt;strong&gt;Immutable&lt;/strong&gt;: 상태를 바꾸지 않는 불변성 제공 (val=final) &lt;br /&gt;
  &lt;strong&gt;Concise&lt;/strong&gt;: 보일러플레이트 코드의 간결성 &lt;br /&gt; &lt;strong&gt;Extension Functions&lt;/strong&gt;: 간편한 확장 함수 &lt;br /&gt; &lt;strong&gt;Functional Programming&lt;/strong&gt;: 함수형 프로그래밍(클래스 없이 함수의 유기적 연결을 통한 프로그래밍 방식) &lt;br /&gt; &lt;strong&gt;Multiplatform&lt;/strong&gt;: 사용 가능한 플랫폼 多 &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-프로그래밍-언어에-대한-경험담&quot;&gt;🔨 프로그래밍 언어에 대한 경험담&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　영어 실력은 아이엘츠 6.0 이상이면 충분하다.&lt;br /&gt;
　해외 기업은 스펙보다 경험 위주로 본다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
// 해외 개발자 채용정보 &lt;br /&gt;
https://www.glassdoor.com &lt;br /&gt;
https://www.seek.com &lt;br /&gt;
https://www.linkedin.com
&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
// 개발자 지식 쌓기 &lt;br /&gt;
github.com/android/architecture-samples &lt;br /&gt;
medium.com &lt;br /&gt;
developer.android.com
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse Hello, Kotlin &lt;br /&gt;
https://www.boostcourse.org/mo001/joinLectures/78789 &lt;br /&gt;&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>코틀린을 왜 배워야 할까?
by boostcourse</summary></entry><entry><title>[BoostCourse] Android Programming 05</title><link href="http://localhost:4000/BoostCourse-Android5/" rel="alternate" type="text/html" title="[BoostCourse] Android Programming 05" /><published>2021-01-06T00:00:00+09:00</published><updated>2021-01-06T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-Android5</id><content type="html" xml:base="http://localhost:4000/BoostCourse-Android5/">&lt;h2 id=&quot;네트워크&quot;&gt;네트워크&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;스레드 사용하기&lt;/li&gt;
  &lt;li&gt;소켓 사용하기&lt;/li&gt;
  &lt;li&gt;웹으로 요청하기&lt;/li&gt;
  &lt;li&gt;Volley 사용하기&lt;/li&gt;
  &lt;li&gt;JSON 이해하기&lt;/li&gt;
  &lt;li&gt;이미지 다운로드하기&lt;/li&gt;
  &lt;li&gt;영화API 사용하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-스레드-사용하기&quot;&gt;🔑 스레드 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　앱 생성 시에, 리눅스 위에서 프로세스가 생성되면서 그와 동시에 앱의 기본 실행을 담당하는 메인 스레드가 생성된다. &lt;strong&gt;스레드(Thread)&lt;/strong&gt;는 동시에 동작하기 위한 하나의 실행 단위다. 메인 스레드와 별도로 실행되고 독립적인 실행을 위해서 추가적으로 스레드를 제작할 수 있다. 하지만 추가 제작된 스레드는 UI에 직접 접근할 수 없기 때문에, &lt;strong&gt;핸들러(Handler)&lt;/strong&gt;를 사용한다.&lt;/p&gt;

&lt;p&gt;　핸들러는 메인 스레드 안에서 큐처럼 동작하여, 핸들러가 요청받은 것과 메인 스레드에서 동작하는 것이 순차적으로 동작하도록 한다. 핸들러는 message 객체의 sendMessage 메소드를 가지고 데이터를 보내 처리하고, 그 메시지를 핸들러가 받아 사용하면 메인 UI를 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;　핸들러를 상속받아 클래스를 사용하는 방식, 더 간결하게는 Runnable 인터페이스를 이용해 직접 한 번 실행될 객체를 정의할 수 있다. Message 객체가 아닌 post 메소드를 호출하는 방식으로! 더욱 간결하게 처리할 수 있다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
Handler.post(new Runnable() run());
&lt;/p&gt;

&lt;p&gt;　핸들러를 사용하는 방식 외에도 &lt;strong&gt;AsyncTask&lt;/strong&gt;를 상속한 클래스로 스레드를 만들고 메인 UI에 접근까지 할 수 있다. AsyncTask는 스레드로 동작하는 코드와 UI로 접근하는 코드를 메소드로 분리해 간편하다. 즉, 명확하게 어떤 기능에 대한 처리를 스레드를 쓴다고 해도 같은 클래스 안에 코드를 넣을 수 있다는 강점이 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;doInBackground(): 스레드 안에서 실행될 코드 &lt;br /&gt; onProgressUpdate(): 중간중간 화면(UI)를 업데이트하기 위한 실행 코드 &lt;br /&gt; onPostExecute(): 결과 값을 전달받아 실행될 코드&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-소켓-사용하기&quot;&gt;🪓 소켓 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　네트워킹이란, 클라이언트(요청)와 서버(응답)의 동작 방식을 말한다. 안드로이드에서는 네트워킹을 사용할 때 반드시 스레드를 사용하며, &lt;strong&gt;post 메소드&lt;/strong&gt; 사용을 권장한다.&lt;/p&gt;

&lt;p&gt;　소켓은 서버 소켓과 클라이언트 소켓을 만들고 서로 연결하는 과정을 갖는다. 서버 소켓은 연결을 기다리는 역할, 클라이언트 소켓은 연결을 만드는 역할을 한다. 서버는 ServerSocket 클래스를 이용해 객체를 만들고 accept 함수를 호출하여 클라이언트로부터의 접속을 기다린다. 클라이언트는 IP와 서버와 동일한 포트 번호를 전달하고, 서버에 접속한다.&lt;/p&gt;

&lt;p&gt;　데이터를 보내고 받는 방식으로는 ObjectOutputStream(데이터 전송)의 writeObject 메소드와 ObjectInputStream(데이터 수신)의 readObject 메소드를 사용한다. 데이터를 전송한 후에는 &lt;strong&gt;flush&lt;/strong&gt; 메소드를 이용해 현재 버퍼에 저장되어 있는 내용을 클라이언트로 전송하고, 버퍼를 비운다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-웹으로-요청하기&quot;&gt;🔨 웹으로 요청하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　소켓은 두개의 컴퓨터 간에 통로를 만들어주고 통로 간에 데이터를 주고받을 수 있게 만들어주는 방법이다. 최근엔 소켓보다 웹이 많이 사용되는데, 웹서버는 &lt;strong&gt;HTTP 요청&lt;/strong&gt;을 받아 처리할 수 있다. 데이터를 주고받는 HTTP 포맷은 어떤 것들이 들어갈 수 있는 지 표준으로 정해진 &lt;strong&gt;헤더(Header)&lt;/strong&gt;와 데이터가 들어간 &lt;strong&gt;바디(Body)&lt;/strong&gt;로 구성된다.&lt;/p&gt;

&lt;p&gt;　앱에서 웹서버에 요청하는 방식은 기존의 표준 자바와 다르지 않지만, 스레드를 사용한다는 점을 염두해야 한다. 가장 기본적인 방법으로 HttpURLConnection 객체를 사용하여 작성해볼 수 있다. 해당 객체에 속성을 설정하고 getResponseCode 메소드를 호출하면 웹서버에 연결하고 응답을 받아준다. 응답 데이터를 화면에 표시할 때는 Request 메소드를 이용하면 된다.&lt;/p&gt;

&lt;p&gt;　데이터를 읽어들일 때, BufferedReader 객체를 사용하면 한 줄씩 읽을 수 있다. 또한 웹서버에 요청하는 것이므로 인터넷 권한을 주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-volley-사용하기&quot;&gt;⛏ Volley 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　웹서버에 요청할 때 일반적으로 사용하는 HttpURLConnection 은 코드 양이 방대하다. 이를 간결화하기 위해 우리는 외부 라이브러리 &lt;strong&gt;Volley&lt;/strong&gt;를 사용한다. Volley는 코드 양이 간결화될 뿐만 아니라, 스레드를 신경쓰지 않아도 된다는 장점이 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;네트워크 요청 우선 순위를 자동으로 관리한다. &lt;br /&gt; 동시에 여러 네트워크 요청을 할 수 있다. &lt;br /&gt; 요청을 할 때 Cache 적용 여부를 의식하지 않아도 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　RequestQueue를 만들고, 그 안에 Request 객체를 만들어 넣어주면 요청은 자동으로 보내지게 된다. Request 객체는 네 개의 파라미터를 전달함으로써 생성된다. 요청 방식을 지정하고, 웹서버의 URL 정보를 전달하고, 응답이 성공적일 때 호출되는 onRequest 메소드를 작성하고, 에러가 발생했을 때 호출될 리스너 객체를 작성한다.&lt;/p&gt;

&lt;p&gt;　요청 큐는 앱이 시작되었을 때 초기화되어 있으면 되며, 한번 만들어두면 계속 사용할 수 있다. Application 클래스를 정의하고 앱에 등록하여 사용하는 경우에는 Application 클래스 안에 넣어둘 수도 있고, 별도의 클래스를 만들어 넣어둘 수도 있다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
implementation 'com.android.volley:volley:1.1.0'
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-json-이해하기&quot;&gt;⚒ JSON 이해하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　데이터가 왔다 갔다 할 때, HTTP 포맷이 왔다 갔다 하는 것이다. 이에 더해 우리가 대상으로 하는 &lt;strong&gt;데이터 포맷&lt;/strong&gt;이 xml 이냐, json 인지 알아보자. &lt;strong&gt;JSON&lt;/strong&gt;은 자바스크립트 객체 포맷의 데이터를 주고 받을 때 사용할 수 있도록 만든 것이다. 파싱 과정을 통해 JSON 형식의 데이터를 사용할 수 있는데, 이는 JSON 문자열을 해석하여 자바 객체로 만드는 과정을 말한다. 이같은 파싱은 구글이 만든 Gson에 의해 이루어진다.&lt;/p&gt;

&lt;p&gt;　JSON 포맷을 GSON을 이용해 자바 객체로 만들어주고, 그 객체에 들어있는 데이터를 사용할 수 있게 된다. 받아온 데이터를 JSON에 맞추어 자바 객체로 만들기 위해서는 자바 클래스를 정의한다. JSON 문자열의 속성 중 값이 배열인 경우에는, 자바 클래스를 정의할 때 ArrayList 자료형을 사용한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
Gson gson = new Gson(); &lt;br /&gt;
MovieList movieList = gson.fromJson(response, MovieList.class);
&lt;/p&gt;

&lt;h3 id=&quot;-이미지-다운로드하기&quot;&gt;🛠 이미지 다운로드하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　위에서 웹서버에 데이터를 요청하고 응답받아 처리하는 과정을 살펴보았다. 응답받을 데이터가 &lt;strong&gt;이미지&lt;/strong&gt;파일일 경우에는, 이미지 파일에 대한 정보만 응답 데이터에 넣어두고 이미지 파일은 별도로 다운로드 받는다. 인터넷을 사용하기 위해 스레드를 생성해야 하므로 AsyncTask를 상속해 새로운 클래스를 정의한다. 클래스 내에서 이미지를 비트맵으로 받아 화면에 보여준다.&lt;/p&gt;

&lt;p&gt;　이미지 파일의 경우에는 파일의 크기가 크기에, 이전에 사용한 비트맵 객체는 정리한다. 외부 라이브러리(ex.UniversalImageLoader)를 사용하면 자동적으로 처리가 되며, 직접 이전의 비트맵의 존재 여부를 확인한 후 삭제할 수 있다. 클래스 안에 HashMap 객체를 만들고 이미지 주소를 메모리에 만들어진 비트맵 객체와 매핑하도록 하여 처리한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
Bitmap bitmap = null; &lt;br /&gt;
URL url = new URL(urlStr); &lt;br /&gt;
bitmap = BitmapFactory.decodeStream(url.openConnection().getInputStream());
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;detail&quot;&gt;DETAIL&lt;/h4&gt;
&lt;p&gt;HTTP(Hyper Text Transfer Protocol): HTML과 같은 문서 정보를 주고받을 수 있는 규약
API 사용 시, 크롬 내 JSONView 확장프로그램을 이용해 가시성 좋게 포맷팅 가능&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse 안드로이드 앱 프로그래밍, 5. 네트워킹 &lt;br /&gt;
https://www.boostcourse.org/mo316/joinLectures/13169 &lt;br /&gt;
[JAVA] flush () &lt;br /&gt;
https://m.blog.naver.com/PostView.nhn?blogId=klh1514&amp;amp;logNo=120190269672&amp;amp;proxyReferer=https:%2F%2Fwww.google.com%2F&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>네트워크
by boostcourse</summary></entry><entry><title>[BoostCourse] Android Programming 04</title><link href="http://localhost:4000/BoostCourse-Android4/" rel="alternate" type="text/html" title="[BoostCourse] Android Programming 04" /><published>2021-01-03T00:00:00+09:00</published><updated>2021-01-03T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-Android4</id><content type="html" xml:base="http://localhost:4000/BoostCourse-Android4/">&lt;h2 id=&quot;화면-내비게이션&quot;&gt;화면 내비게이션&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;프래그먼트 이해하기&lt;/li&gt;
  &lt;li&gt;프래그먼트 사용하기&lt;/li&gt;
  &lt;li&gt;액션바 사용하기&lt;/li&gt;
  &lt;li&gt;탭 만들기&lt;/li&gt;
  &lt;li&gt;뷰페이저 사용하기&lt;/li&gt;
  &lt;li&gt;바로가기 메뉴 만들기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-프래그먼트-이해하기&quot;&gt;🔑 프래그먼트 이해하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　안드로이드에서 화면은 액티비티로 만들어진다. 화면 제작 중에 부분 화면을 제작해야 하는 상황이 발생할 수 있다. 부분 화면을 액티비티(뷰)로 반복해 만들어 간다면, 코드를 지속적으로 새로 작성해야 하는 불편함뿐만 아니라 액티비티를 관리하는 시스템에 부담이 커진다. 시스템이 액티비티를 관리하는 것처럼 부분 화면을 독립적으로 제작하는 방식을 통해 만들어진 것이 ‘프래그먼트’ 이다. 프래그먼트는 &lt;strong&gt;액티비티가 시스템의 역할&lt;/strong&gt;을 대신하기 때문에, 액티비티보다 가볍게 화면을 전환할 수 있다. 
&lt;br /&gt;
　액티비티의 수명 주기에서 onAttach와 onDetach가 추가된다. onAttach는 onCreate보다 먼저 호출되면 프래그먼트가 액티비티 위에 올라감을 의미한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
**MainActivity.java** &lt;br /&gt;
MainFragment fragment = new MainFragment(); &lt;br /&gt;
getSupportFragmentManager().beginTransaction().add(R.id.container, fragment).commit(); &lt;br /&gt;
&lt;br /&gt;
**MainFragment.java** &lt;br /&gt;
ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_main, container, false); &lt;br /&gt;
return rootView; &lt;br /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;R.id.container 는 프래그먼트를 담을 공간 &lt;br /&gt; add 대신 replace 메소드 사용 시 기존 프래그먼트를 대체함&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-프래그먼트-사용하기&quot;&gt;🪓 프래그먼트 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　액티비티와 프래그먼트는 메소드와 인터페이스를 사용하여 소통할 수 있다. 프래그먼트는 인터페이스가 구현된 상위 액티비티의 메소드로 데이터를 전달하고, 액티비티는 인스턴스로 가지고 있는 프래그먼트의 메소드로 데이터를 전달할 수 있다. 즉 프래그먼트에서 액티비티로 데이터를 전달할 때에는 인터페이스가 필요하지만, 액티비티에서 프래그먼트로 데이터를 전달할 때는 단순한 메소드 호출로 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-액션바-사용하기&quot;&gt;🔨 액션바 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　액션바는 상단 타이틀을 말하며, 현재는 툴바의 기능 또한 가지고 있다.
&lt;br /&gt;
　메뉴는 옵션 메뉴(액션바에 통합됨)와 컨텍스트 메뉴(팝업)으로 나뉜다. onCreateOptionsMenu 를 통해 옵션 메뉴를 생성할 수 있으며, getMenuInflater.inflate() 를 이용해 인플레이션 작업을 해야 한다. onOptionsItemSelected는 옵션 메뉴 아이템을 클릭했을 때 호출하는 메서드이다. 메서드 내부에서 item.getItemId()를 사용해 아이템을 선택할 수 있다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
**menu 태그 내부** &lt;br /&gt;
&amp;lt;item id, title, icon, app:showAsAction, app:actionLayout&amp;gt; &lt;br /&gt;
showAsAction = &quot;always&quot; &quot;ifRoom&quot; &quot;withText&quot; &quot;never&quot; &lt;br /&gt;
actionLayout = &quot;@layout/search_layout&quot; //이런식으로 부분화면 레이아웃 추가가능 &lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-탭-사용하기&quot;&gt;⛏ 탭 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　탭은 하나의 화면에 여러 가지 서브화면들을 넣어둘 수 있는 장점이 있어 자주 사용된다. 몇 개의 탭 버튼이 상단이나 하단에 있고 그 탭 버튼을 누르면 화면이 전환되는 방식이다.
&lt;br /&gt;
　CoordinatorLayout을 사용하면 상단에 액션바 추가 시에 액션바와 아래 화면이 겹치지 않도록 생성해줄 수 있다. 강의는 해당 레이아웃 내에 액션바와 하단 탭 버튼을 추가하는 예제를 진행한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
CoordinatorLayout-AppBarLayout-Toolbar-/AppBarLayout-TabLayout/-/Coor-&amp;gt; FrameLayout &lt;br /&gt;
app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; //FrameLayout이 원래 레이아웃 화면 부분이며, 상단은 액션바 영역임을 구분함 &lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-뷰페이저-사용하기&quot;&gt;⚒ 뷰페이저 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　뷰페이저란 좌우 스크롤을 통해 하나의 뷰페이저 안에 들어가있는 화면이 넘어가는 기능을 제공한다. 일반적으로 뷰페이지 안에 여러 개의 부분 화면인 프래그먼트가 들어간다. 여러 개의 아이템 중 하나를 선택하는 ‘선택 위젯’이므로 어댑터를 사용한다. 즉 어댑터가 실제 데이터를 관리하고 뷰페이저는 껍데기를 역할을 하게 된다.
&lt;br /&gt;
　뷰페이저의 화면이 몇개이고, 몇번째 화면인지 알고 싶을 때는 타이틀스트립(PagerTitleStrip) 혹은 탭스트립(PagerTapStrip)을 사용한다. 예시로 타이틀스트립을 사용하는 경우에는, 프래그먼트 어댑터 내에 getPageTitle 메서드를 통해 페이지마다 타이틀을 붙여 리턴하면 된다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
MainActivity extends FragmentStatePagerAdapter &lt;br /&gt;
ArrayList Fragment items // 프래그먼트 아이템 관리 &lt;br /&gt;
viewpager.setOffscreenPageLimit(3) // 몇 개의 화면을 보여줄지 &lt;br /&gt;
viewpager.setAdapter(adpater); &lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-바로가기-메뉴-만들기&quot;&gt;🛠 바로가기 메뉴 만들기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　타이틀 왼쪽에 햄버거 모양의 아이콘을 바로가기 메뉴 화면이라고 부른다. 안드로이드에서는 NavigationDrawer라고 불리며 이는 기본적으로 제공된다. 해당 기능은 프래그먼트로 구성되기 때문에 프래그먼트의 동작원리를 정확히 이해하는 것이 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse 안드로이드 앱 프로그래밍, 4. 화면 내비게이션 &lt;br /&gt;
https://www.boostcourse.org/mo316/joinLectures/13161&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>화면 내비게이션
by boostcourse</summary></entry></feed>
