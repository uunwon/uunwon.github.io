<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.6.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-04-19T16:43:16+09:00</updated><id>http://localhost:4000/</id><title>UUNWON</title><subtitle>Student at Korea Polytechnic University</subtitle><entry><title>Process</title><link href="http://localhost:4000/Process/" rel="alternate" type="text/html" title="Process" /><published>2021-04-19T00:00:00+09:00</published><updated>2021-04-19T00:00:00+09:00</updated><id>http://localhost:4000/Process</id><content type="html" xml:base="http://localhost:4000/Process/">&lt;h2 id=&quot;process-by-수제비&quot;&gt;Process by 수제비&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스&lt;/li&gt;
  &lt;li&gt;프로세스 상태 전이&lt;/li&gt;
  &lt;li&gt;프로세스 스케줄링 
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;프로세스&quot;&gt;프로세스&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　프로세스(Process)란 일반적으로 CPU에 의해 처리되는 프로그램으로 현재 실행 중인 프로그램을 말한다. 하나의 프로세스는 여러가지 이벤트에 의해 일련의 서로 구분되는 &lt;strong&gt;상태 변화&lt;/strong&gt;(생성 상태, 준비 상태, 실행 상태, 대기 상태, 완료 상태) 를 겪는다.&lt;/p&gt;</content><category term="test" /><summary>Process by 수제비</summary></entry><entry><title>Software Test</title><link href="http://localhost:4000/Software-Test/" rel="alternate" type="text/html" title="Software Test" /><published>2021-04-18T00:00:00+09:00</published><updated>2021-04-18T00:00:00+09:00</updated><id>http://localhost:4000/Software-Test</id><content type="html" xml:base="http://localhost:4000/Software-Test/">&lt;h2 id=&quot;software-test-by-수제비&quot;&gt;Software Test by 수제비&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;소프트웨어 테스트&lt;/li&gt;
  &lt;li&gt;프로그램 실행 여부에 따른 분류&lt;/li&gt;
  &lt;li&gt;테스트 기법에 따른 분류&lt;/li&gt;
  &lt;li&gt;테스트 시각에 따른 분류&lt;/li&gt;
  &lt;li&gt;테스트 목적에 따른 분류&lt;/li&gt;
  &lt;li&gt;테스트 오라클
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;소프트웨어-테스트&quot;&gt;소프트웨어 테스트&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　소프트웨어 테스트란 개발된 응용 애플리케이션이나 시스템이 사용자가 요구하는 기능과 성능, 사용성, 안정성 등을 만족하는지 확인하고, 노출되지 않은 숨어있는 소프트웨어의 결함을 찾아내는 활동이다.&lt;/p&gt;

&lt;p&gt;　위와 같은 테스트는 오류 발견 관점, 오류 예방 관점, 품질 향상 관점에서 필요하다.&lt;/p&gt;

&lt;h4 id=&quot;-소프트웨어-테스트-산출물&quot;&gt;📌 소프트웨어 테스트 산출물&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;
- &lt;b&gt;테스트 계획서&lt;/b&gt;: 테스트 수행을 계획한 문서&lt;br /&gt;
- &lt;b&gt;테스트 케이스&lt;/b&gt;: 테스트를 위한 설계 산출물로, 응용 소프트웨어가 사용자의 요구사항을 준수하는지 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과로 구성된 테스트 항목의 명세서&lt;br /&gt;
- &lt;b&gt;테스트 시나리오&lt;/b&gt;: 테스트 수행을 위한 여러 개의 테스트 케이스의 집합으로 테스트 케이스의 동작 순서를 기술한 문서&lt;br /&gt;
- &lt;b&gt;테스트 결과서&lt;/b&gt;: 테스트 결과를 정리한 문서
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로그램-실행-여부에-따른-분류&quot;&gt;프로그램 실행 여부에 따른 분류&lt;/h3&gt;

&lt;h4 id=&quot;정적-테스트&quot;&gt;정적 테스트&lt;/h4&gt;
&lt;p&gt;　프로그램의 실행 없이 &lt;strong&gt;구조를 분석&lt;/strong&gt;하여 논리성을 검증하는 테스트&lt;br /&gt;
　(ex) 동료 검토, 워크스루, 인스펙션&lt;/p&gt;

&lt;h4 id=&quot;동적-테스트&quot;&gt;동적 테스트&lt;/h4&gt;
&lt;p&gt;　프로그램 실행을 요구하는 테스트&lt;br /&gt;
　(ex) 화이트박스 테스트, 블랙박스 테스트&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-기법에-따른-분류&quot;&gt;테스트 기법에 따른 분류&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;화이트박스 테스트&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;제어구조 테스트&lt;/strong&gt;&lt;br /&gt;
소프트웨어의 논리적 복잡도 측정 후 수행 경로들의 집합을 정의하는 테스트&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;루프 테스트&lt;/strong&gt;&lt;br /&gt;
프로그램의 루프 구조에 국한해서 실시하는 테스트&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;블랙박스 테스트&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;동등분할 테스트&lt;/strong&gt;&lt;br /&gt;
입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 대표값 테스트 케이스를 도출하여 케이스를 도출하여 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;경계 값 분석 테스트&lt;/strong&gt;&lt;br /&gt;
등가분할 후 경계 값 부분에서 오류 발생 확률이 높기에 경계 값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;결정 테이블 테스트&lt;/strong&gt;&lt;br /&gt;
요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합하여 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;상태전이 테스트&lt;/strong&gt;&lt;br /&gt;
테스트 대상/시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;유스케이스 테스트&lt;/strong&gt;&lt;br /&gt;
시스템이 실제 사용되는 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화하여 수행하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;분류트리 테스트&lt;/strong&gt;&lt;br /&gt;
SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;페어와이즈 테스트&lt;/strong&gt;&lt;br /&gt;
Test data 값들 간에 최소한 한 번씩을 조합하는 방식이며, 이는 커버해야 할 기능적 범위를 모든 조합에 비해 상대적으로 적은 양의 테스트 세트를 구성하기 위한 테스트 기법&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-시각에-따른-분류&quot;&gt;테스트 시각에 따른 분류&lt;/h3&gt;

&lt;h4 id=&quot;검증verification&quot;&gt;검증(Verification)&lt;/h4&gt;
&lt;p&gt;　소프트웨어 과정을 테스트&lt;/p&gt;

&lt;h4 id=&quot;확인validation&quot;&gt;확인(Validation)&lt;/h4&gt;
&lt;p&gt;　소프트웨어 결과를 테스트&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-목적에-따른-분류&quot;&gt;테스트 목적에 따른 분류&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
ㆁ &lt;strong&gt;회복 테스트&lt;/strong&gt;&lt;br /&gt;
시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여부를 테스트하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;안전 테스트&lt;/strong&gt;&lt;br /&gt;
소스 코드 내의 보안적인 결함을 미리 점검하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;강도 테스트&lt;/strong&gt;&lt;br /&gt;
시스템 과부하 시에도 정상 작동되는지를 검증하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;성능 테스트&lt;/strong&gt;&lt;br /&gt;
이벤트에 응답하는 시간, 처리하는 업무량 등을 측정하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;구조 테스트&lt;/strong&gt;&lt;br /&gt;
시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가하는 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;회귀 테스트&lt;/strong&gt;&lt;br /&gt;
오류를 제거하거나 수정한 시스템에서 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지 확인하는 일종의 반복 테스트 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;병행 테스트&lt;/strong&gt;&lt;br /&gt;
변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과를 비교하는 테스트 기법&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;테스트-오라클&quot;&gt;테스트 오라클&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참 값을 입력하여 비교하는 기법&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;참 오라클&lt;/strong&gt;&lt;br /&gt;
모든 입력값에 대하여 기대하는 결과를 생성함으로써 발생된 오류를 모두 검출할 수 있는 오라클&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;샘플링 오라클&lt;/strong&gt;&lt;br /&gt;
특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;휴리스틱 오라클&lt;/strong&gt;&lt;br /&gt;
샘플링 오라클을 개선한 오라클로, 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;일관성 검사 오라클&lt;/strong&gt;&lt;br /&gt;
애플리케이션 변경이 있을 때, 수행 전과 후의 결괏값이 동일한지 확인하는 오라클&lt;/p&gt;</content><category term="test" /><summary>Software Test by 수제비</summary></entry><entry><title>Design Pattern</title><link href="http://localhost:4000/Design-Pattern/" rel="alternate" type="text/html" title="Design Pattern" /><published>2021-04-17T00:00:00+09:00</published><updated>2021-04-17T00:00:00+09:00</updated><id>http://localhost:4000/Design-Pattern</id><content type="html" xml:base="http://localhost:4000/Design-Pattern/">&lt;h2 id=&quot;design-pattern-by-수제비&quot;&gt;Design Pattern by 수제비&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;디자인 패턴&lt;/li&gt;
  &lt;li&gt;디자인 패턴 분류&lt;/li&gt;
  &lt;li&gt;디자인 패턴 종류&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;디자인-패턴&quot;&gt;디자인 패턴&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　소프트웨어 개발 방법에서 사용되는 &lt;strong&gt;디자인 패턴&lt;/strong&gt;은 프로그램 개발에서 자주 나타나는 과제를 해결하기 위한 방법 중 하나로, 과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재사용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다. 알고리즘과 같이 프로그램 코드로 바로 변환될 수 있는 형태는 아니지만, 특정한 상황에서 구조적인 문제를 해결하는 방식이다.&lt;/p&gt;

&lt;p&gt;　즉, 소프트웨어를 설계할 때 또는 프로그램 개발 과정에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;특정 부분에서 많이 발생하는 문제를 정리&lt;/code&gt;하여 상황에 따라 해결할 수 있는 해결책 (패턴)이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;디자인-패턴-분류&quot;&gt;디자인 패턴 분류&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
① &lt;strong&gt;생성 패턴(Creational Pattern)&lt;/strong&gt;&lt;br /&gt;
　: 객체의 생성과 관련된 패턴&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
추상 팩토리(Abstract Factory), 빌더(Builder), 팩토리 메소드(Factory Method), 프로토타입(Prototype), 싱글톤(Singleton)
&lt;/p&gt;

&lt;p&gt;② &lt;strong&gt;구조 패턴(Structural Pattern)&lt;/strong&gt;&lt;br /&gt;
　: 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
어댑터(Adapter), 브리지(Bridge), 컴포지트(Composite), 데코레이터(Decorator), 퍼싸드(Facade), 플라이웨이트(Flyweight), 프록시(Proxy)
&lt;/p&gt;

&lt;p&gt;③ &lt;strong&gt;행위 패턴(Behavioral Pattern)&lt;/strong&gt;&lt;br /&gt;
　: 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴&lt;/p&gt;
&lt;p class=&quot;notice&quot;&gt;
책임 연쇄(Chain of Responsibility), 커맨드(Command), 인터프리터(Interpreter), 반복자(Iterator), 중재자(Mediator), 메멘토(Memento), 옵서버(Observer), 상태(State), 전략(Strategy), 템플릿 메소드(Template Method), 방문자(Visitor)
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;디자인-패턴-종류&quot;&gt;디자인 패턴 종류&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
ㆁ &lt;strong&gt;Abstract Factory&lt;/strong&gt;&lt;br /&gt;
　구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Factroy Method&lt;/strong&gt;&lt;br /&gt;
　객체 생성 처리를 서브(하위) 클래스로 분리해 처리하도록 캡슐화하는 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Singleton&lt;/strong&gt;&lt;br /&gt;
　전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Builder&lt;/strong&gt;&lt;br /&gt;
　복잡한 인스턴스를 조립하여 만드는 구조로, 복합 객체를 생성할 때 객체를 생성하는 방법(과정)과 객체를 구현(표현)하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Bridge&lt;/strong&gt;&lt;br /&gt;
　기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Adapter&lt;/strong&gt;&lt;br /&gt;
　기존 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴으로, 상속을 이용하여 클래스 패턴과 위임을 이용하는 인스턴스 패턴의 두가지 형태로 사용되는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Composite&lt;/strong&gt;&lt;br /&gt;
　객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Prototype&lt;/strong&gt;&lt;br /&gt;
　처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴으로, 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하며 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용되는 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Decorator&lt;/strong&gt;&lt;br /&gt;
　객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주는 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Observer&lt;/strong&gt;&lt;br /&gt;
　한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Iterator&lt;/strong&gt;&lt;br /&gt;
　컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있는 방법을 제공하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;State&lt;/strong&gt;&lt;br /&gt;
　객체의 상태에 따라 객체의 행위 내용을 변경해주는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Strategy&lt;/strong&gt;&lt;br /&gt;
　행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Template Method&lt;/strong&gt;&lt;br /&gt;
　어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Command&lt;/strong&gt;&lt;br /&gt;
　실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Visitor&lt;/strong&gt;&lt;br /&gt;
　각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴으로, 객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 사용하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Mediator&lt;/strong&gt;&lt;br /&gt;
　객체지향설계에서 객체의 수가 너무 많아지면 서로 통신하느라 복잡해져 객체지향에서 가장 중요한 느슨한 결합의 특성을 해칠 수 있다. 이를 해결하는 한가지 방법으로 중간에 이를 통제하고 지시할 수 있는 역할을 하는 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체지향의 목표를 달성하게 해주는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Memento&lt;/strong&gt;&lt;br /&gt;
　객체를 이전 상태로 복구시켜야하는 경우, ‘작업취소(undo)’를 요청하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Interpreter&lt;/strong&gt;&lt;br /&gt;
　언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 디자인 패턴 (문법 자체를 캡슐화)&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Facade&lt;/strong&gt;&lt;br /&gt;
　복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자와 시스템 간, 또는 여타 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴이다. 오류에 대해서 단위별로 확인할 수 있게 하며, 사용자의 측면에서 단순한 인터페이스를 제공하여 접근성을 높일 수 있는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Chain of Responsibility&lt;/strong&gt;&lt;br /&gt;
　정적으로 어떤 기능에 대한 처리의 연결이 하드코딩되어 있을 시, 기능 처리의 연결 변경이 불가능한테 이를 동적으로 연결되어 있는 경우에 따라서 다르게 처리될 수 있도록 연결한 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Proxy&lt;/strong&gt;&lt;br /&gt;
　’실체 객체에 대한 대리 객체’ 로 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이 점을 이용해 미리 할당하지 않아도 상관없는 것들을 실제 이용할 때 할당하게 하여 메모리 용량을 아낄 수 있으며, 실체 객체를 드러나지 않게 하여 정보은닉의 역할도 수행하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;ㆁ &lt;strong&gt;Flyweight&lt;/strong&gt;&lt;br /&gt;
　다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 클래스화하여 공유함으로써 메모리를 절약하고, ‘클래스의 경량화’를 목적으로 하는 디자인 패턴&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://helloworld-88.tistory.com/291 &lt;br /&gt;
https://www.notion.so/23-1959a781210b48b0b726cba983231649&lt;/p&gt;</content><category term="test" /><summary>Design Pattern by 수제비</summary></entry><entry><title>Class, Object, Instance</title><link href="http://localhost:4000/Class-Object/" rel="alternate" type="text/html" title="Class, Object, Instance" /><published>2021-04-14T00:00:00+09:00</published><updated>2021-04-14T00:00:00+09:00</updated><id>http://localhost:4000/Class-Object</id><content type="html" xml:base="http://localhost:4000/Class-Object/">&lt;h2 id=&quot;class-object-instance&quot;&gt;Class, Object, Instance&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;클래스 (Class)&lt;/li&gt;
  &lt;li&gt;객체 (Object)&lt;/li&gt;
  &lt;li&gt;인스턴스 (Instance)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-class&quot;&gt;🔑 Class&lt;/h3&gt;
&lt;p&gt;　객체를 만들어내기 위한 설계도 혹은 틀&lt;br /&gt;
　연관되어 있는 변수와 메서드의 집합&lt;br /&gt;
　-&amp;gt; 클래스란 객체를 정의해놓은 것으로써, 객체를 생성하는데 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-object&quot;&gt;🪓 Object&lt;/h3&gt;
&lt;p&gt;　소프트웨어 세계에 구현할 대상&lt;br /&gt;
　클래스에 선언된 모양 그대로 생성된 실체&lt;br /&gt;
　-&amp;gt; 클래스의 인스턴스라고도 부르며, 모든 인스턴스를 대표하는 포괄적인 의미를 가진다. oop의 관점에서 &lt;strong&gt;클래스의 타입&lt;/strong&gt;으로 선언되었을 때 ‘객체’라고 부른다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-instance&quot;&gt;🔨 Instance&lt;/h3&gt;
&lt;p&gt;　설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체&lt;br /&gt;
　객체를 소프트웨어에 실체화한 것
　실체화된 인스턴스는 메모리에 할당됨  &lt;br /&gt;
　-&amp;gt; oop의 관점에서 &lt;strong&gt;객체가 메모리에 할당&lt;/strong&gt;되어 실제 사용될 때 ‘인스턴스’라 부르며, 추상적인 개념과 구체적인 객체 사이의 &lt;strong&gt;관계&lt;/strong&gt;에 초점을 맞출 경우에 ‘~의 인스턴스’ 형태로 사용된다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
/* 클래스 */ &lt;br /&gt;
public class Animal{ &lt;br /&gt;
　　... &lt;br /&gt;
 } &lt;br /&gt;
/* 객체와 인스턴스 */ &lt;br /&gt;
public class Main { &lt;br /&gt;
　public static void main(String[] args) &lt;br /&gt;
　　　　Animal cat, dog; // '객체' &lt;br /&gt;
　　　　// 인스턴스화 &lt;br /&gt;
　　　　cat = new Animal(); // cat은 Animal 클래스의 '인스턴스' (객체를 메모리에 할당) &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p&gt;https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html &lt;br /&gt;&lt;/p&gt;</content><category term="java" /><summary>Class, Object, Instance</summary></entry><entry><title>[BoostCourse] Hello, Kotlin</title><link href="http://localhost:4000/BoostCourse-HelloKotlin/" rel="alternate" type="text/html" title="[BoostCourse] Hello, Kotlin" /><published>2021-02-04T00:00:00+09:00</published><updated>2021-02-04T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-HelloKotlin</id><content type="html" xml:base="http://localhost:4000/BoostCourse-HelloKotlin/">&lt;h2 id=&quot;코틀린을-왜-배워야-할까&quot;&gt;코틀린을 왜 배워야 할까?&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린을 왜 배워야 할까?&lt;/li&gt;
  &lt;li&gt;코틀린의 매력을 알아볼까요?&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어에 대한 경험담&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-코틀린을-왜-배워야-할까&quot;&gt;🔑 코틀린을 왜 배워야 할까?&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　코틀린은 새롭게 부상하고 있는 안드로이드 모바일 앱을 제작하기 위한 언어다. 많은 기업들이 자바에서 코틀린으로 갈아타는 모습을 볼 수 있으며, 개발자들의 선호도 또한 높은 편에 속한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-코틀린의-매력을-알아볼까요&quot;&gt;🪓 코틀린의 매력을 알아볼까요?&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　코틀린의 특징&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Statically typed&lt;/strong&gt;: 정적 타입 언어 (컴파일시 변수의 자료형이 결정됨) &lt;br /&gt; &lt;strong&gt;Interoperable&lt;/strong&gt;: Kotile/JVM을 사용해 자바와 100% 호환 &lt;br /&gt; &lt;strong&gt;Null safety&lt;/strong&gt;: NPE(Null Pointer Exception)를 방지할 수 있는 안전성 &lt;br /&gt; &lt;strong&gt;Immutable&lt;/strong&gt;: 상태를 바꾸지 않는 불변성 제공 (val=final) &lt;br /&gt;
  &lt;strong&gt;Concise&lt;/strong&gt;: 보일러플레이트 코드의 간결성 &lt;br /&gt; &lt;strong&gt;Extension Functions&lt;/strong&gt;: 간편한 확장 함수 &lt;br /&gt; &lt;strong&gt;Functional Programming&lt;/strong&gt;: 함수형 프로그래밍(클래스 없이 함수의 유기적 연결을 통한 프로그래밍 방식) &lt;br /&gt; &lt;strong&gt;Multiplatform&lt;/strong&gt;: 사용 가능한 플랫폼 多 &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-프로그래밍-언어에-대한-경험담&quot;&gt;🔨 프로그래밍 언어에 대한 경험담&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　영어 실력은 아이엘츠 6.0 이상이면 충분하다.&lt;br /&gt;
　해외 기업은 스펙보다 경험 위주로 본다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
// 해외 개발자 채용정보 &lt;br /&gt;
https://www.glassdoor.com &lt;br /&gt;
https://www.seek.com &lt;br /&gt;
https://www.linkedin.com
&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
// 개발자 지식 쌓기 &lt;br /&gt;
github.com/android/architecture-samples &lt;br /&gt;
medium.com &lt;br /&gt;
developer.android.com
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse Hello, Kotlin &lt;br /&gt;
https://www.boostcourse.org/mo001/joinLectures/78789 &lt;br /&gt;&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>코틀린을 왜 배워야 할까?
by boostcourse</summary></entry><entry><title>[BoostCourse] Android Programming 05</title><link href="http://localhost:4000/BoostCourse-Android5/" rel="alternate" type="text/html" title="[BoostCourse] Android Programming 05" /><published>2021-01-06T00:00:00+09:00</published><updated>2021-01-06T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-Android5</id><content type="html" xml:base="http://localhost:4000/BoostCourse-Android5/">&lt;h2 id=&quot;네트워크&quot;&gt;네트워크&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;스레드 사용하기&lt;/li&gt;
  &lt;li&gt;소켓 사용하기&lt;/li&gt;
  &lt;li&gt;웹으로 요청하기&lt;/li&gt;
  &lt;li&gt;Volley 사용하기&lt;/li&gt;
  &lt;li&gt;JSON 이해하기&lt;/li&gt;
  &lt;li&gt;이미지 다운로드하기&lt;/li&gt;
  &lt;li&gt;영화API 사용하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-스레드-사용하기&quot;&gt;🔑 스레드 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　앱 생성 시에, 리눅스 위에서 프로세스가 생성되면서 그와 동시에 앱의 기본 실행을 담당하는 메인 스레드가 생성된다. &lt;strong&gt;스레드(Thread)&lt;/strong&gt;는 동시에 동작하기 위한 하나의 실행 단위다. 메인 스레드와 별도로 실행되고 독립적인 실행을 위해서 추가적으로 스레드를 제작할 수 있다. 하지만 추가 제작된 스레드는 UI에 직접 접근할 수 없기 때문에, &lt;strong&gt;핸들러(Handler)&lt;/strong&gt;를 사용한다.&lt;/p&gt;

&lt;p&gt;　핸들러는 메인 스레드 안에서 큐처럼 동작하여, 핸들러가 요청받은 것과 메인 스레드에서 동작하는 것이 순차적으로 동작하도록 한다. 핸들러는 message 객체의 sendMessage 메소드를 가지고 데이터를 보내 처리하고, 그 메시지를 핸들러가 받아 사용하면 메인 UI를 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;　핸들러를 상속받아 클래스를 사용하는 방식, 더 간결하게는 Runnable 인터페이스를 이용해 직접 한 번 실행될 객체를 정의할 수 있다. Message 객체가 아닌 post 메소드를 호출하는 방식으로! 더욱 간결하게 처리할 수 있다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
Handler.post(new Runnable() run());
&lt;/p&gt;

&lt;p&gt;　핸들러를 사용하는 방식 외에도 &lt;strong&gt;AsyncTask&lt;/strong&gt;를 상속한 클래스로 스레드를 만들고 메인 UI에 접근까지 할 수 있다. AsyncTask는 스레드로 동작하는 코드와 UI로 접근하는 코드를 메소드로 분리해 간편하다. 즉, 명확하게 어떤 기능에 대한 처리를 스레드를 쓴다고 해도 같은 클래스 안에 코드를 넣을 수 있다는 강점이 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;doInBackground(): 스레드 안에서 실행될 코드 &lt;br /&gt; onProgressUpdate(): 중간중간 화면(UI)를 업데이트하기 위한 실행 코드 &lt;br /&gt; onPostExecute(): 결과 값을 전달받아 실행될 코드&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-소켓-사용하기&quot;&gt;🪓 소켓 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　네트워킹이란, 클라이언트(요청)와 서버(응답)의 동작 방식을 말한다. 안드로이드에서는 네트워킹을 사용할 때 반드시 스레드를 사용하며, &lt;strong&gt;post 메소드&lt;/strong&gt; 사용을 권장한다.&lt;/p&gt;

&lt;p&gt;　소켓은 서버 소켓과 클라이언트 소켓을 만들고 서로 연결하는 과정을 갖는다. 서버 소켓은 연결을 기다리는 역할, 클라이언트 소켓은 연결을 만드는 역할을 한다. 서버는 ServerSocket 클래스를 이용해 객체를 만들고 accept 함수를 호출하여 클라이언트로부터의 접속을 기다린다. 클라이언트는 IP와 서버와 동일한 포트 번호를 전달하고, 서버에 접속한다.&lt;/p&gt;

&lt;p&gt;　데이터를 보내고 받는 방식으로는 ObjectOutputStream(데이터 전송)의 writeObject 메소드와 ObjectInputStream(데이터 수신)의 readObject 메소드를 사용한다. 데이터를 전송한 후에는 &lt;strong&gt;flush&lt;/strong&gt; 메소드를 이용해 현재 버퍼에 저장되어 있는 내용을 클라이언트로 전송하고, 버퍼를 비운다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-웹으로-요청하기&quot;&gt;🔨 웹으로 요청하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　소켓은 두개의 컴퓨터 간에 통로를 만들어주고 통로 간에 데이터를 주고받을 수 있게 만들어주는 방법이다. 최근엔 소켓보다 웹이 많이 사용되는데, 웹서버는 &lt;strong&gt;HTTP 요청&lt;/strong&gt;을 받아 처리할 수 있다. 데이터를 주고받는 HTTP 포맷은 어떤 것들이 들어갈 수 있는 지 표준으로 정해진 &lt;strong&gt;헤더(Header)&lt;/strong&gt;와 데이터가 들어간 &lt;strong&gt;바디(Body)&lt;/strong&gt;로 구성된다.&lt;/p&gt;

&lt;p&gt;　앱에서 웹서버에 요청하는 방식은 기존의 표준 자바와 다르지 않지만, 스레드를 사용한다는 점을 염두해야 한다. 가장 기본적인 방법으로 HttpURLConnection 객체를 사용하여 작성해볼 수 있다. 해당 객체에 속성을 설정하고 getResponseCode 메소드를 호출하면 웹서버에 연결하고 응답을 받아준다. 응답 데이터를 화면에 표시할 때는 Request 메소드를 이용하면 된다.&lt;/p&gt;

&lt;p&gt;　데이터를 읽어들일 때, BufferedReader 객체를 사용하면 한 줄씩 읽을 수 있다. 또한 웹서버에 요청하는 것이므로 인터넷 권한을 주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-volley-사용하기&quot;&gt;⛏ Volley 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　웹서버에 요청할 때 일반적으로 사용하는 HttpURLConnection 은 코드 양이 방대하다. 이를 간결화하기 위해 우리는 외부 라이브러리 &lt;strong&gt;Volley&lt;/strong&gt;를 사용한다. Volley는 코드 양이 간결화될 뿐만 아니라, 스레드를 신경쓰지 않아도 된다는 장점이 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;네트워크 요청 우선 순위를 자동으로 관리한다. &lt;br /&gt; 동시에 여러 네트워크 요청을 할 수 있다. &lt;br /&gt; 요청을 할 때 Cache 적용 여부를 의식하지 않아도 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　RequestQueue를 만들고, 그 안에 Request 객체를 만들어 넣어주면 요청은 자동으로 보내지게 된다. Request 객체는 네 개의 파라미터를 전달함으로써 생성된다. 요청 방식을 지정하고, 웹서버의 URL 정보를 전달하고, 응답이 성공적일 때 호출되는 onRequest 메소드를 작성하고, 에러가 발생했을 때 호출될 리스너 객체를 작성한다.&lt;/p&gt;

&lt;p&gt;　요청 큐는 앱이 시작되었을 때 초기화되어 있으면 되며, 한번 만들어두면 계속 사용할 수 있다. Application 클래스를 정의하고 앱에 등록하여 사용하는 경우에는 Application 클래스 안에 넣어둘 수도 있고, 별도의 클래스를 만들어 넣어둘 수도 있다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
implementation 'com.android.volley:volley:1.1.0'
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-json-이해하기&quot;&gt;⚒ JSON 이해하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　데이터가 왔다 갔다 할 때, HTTP 포맷이 왔다 갔다 하는 것이다. 이에 더해 우리가 대상으로 하는 &lt;strong&gt;데이터 포맷&lt;/strong&gt;이 xml 이냐, json 인지 알아보자. &lt;strong&gt;JSON&lt;/strong&gt;은 자바스크립트 객체 포맷의 데이터를 주고 받을 때 사용할 수 있도록 만든 것이다. 파싱 과정을 통해 JSON 형식의 데이터를 사용할 수 있는데, 이는 JSON 문자열을 해석하여 자바 객체로 만드는 과정을 말한다. 이같은 파싱은 구글이 만든 Gson에 의해 이루어진다.&lt;/p&gt;

&lt;p&gt;　JSON 포맷을 GSON을 이용해 자바 객체로 만들어주고, 그 객체에 들어있는 데이터를 사용할 수 있게 된다. 받아온 데이터를 JSON에 맞추어 자바 객체로 만들기 위해서는 자바 클래스를 정의한다. JSON 문자열의 속성 중 값이 배열인 경우에는, 자바 클래스를 정의할 때 ArrayList 자료형을 사용한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
Gson gson = new Gson(); &lt;br /&gt;
MovieList movieList = gson.fromJson(response, MovieList.class);
&lt;/p&gt;

&lt;h3 id=&quot;-이미지-다운로드하기&quot;&gt;🛠 이미지 다운로드하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　위에서 웹서버에 데이터를 요청하고 응답받아 처리하는 과정을 살펴보았다. 응답받을 데이터가 &lt;strong&gt;이미지&lt;/strong&gt;파일일 경우에는, 이미지 파일에 대한 정보만 응답 데이터에 넣어두고 이미지 파일은 별도로 다운로드 받는다. 인터넷을 사용하기 위해 스레드를 생성해야 하므로 AsyncTask를 상속해 새로운 클래스를 정의한다. 클래스 내에서 이미지를 비트맵으로 받아 화면에 보여준다.&lt;/p&gt;

&lt;p&gt;　이미지 파일의 경우에는 파일의 크기가 크기에, 이전에 사용한 비트맵 객체는 정리한다. 외부 라이브러리(ex.UniversalImageLoader)를 사용하면 자동적으로 처리가 되며, 직접 이전의 비트맵의 존재 여부를 확인한 후 삭제할 수 있다. 클래스 안에 HashMap 객체를 만들고 이미지 주소를 메모리에 만들어진 비트맵 객체와 매핑하도록 하여 처리한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
Bitmap bitmap = null; &lt;br /&gt;
URL url = new URL(urlStr); &lt;br /&gt;
bitmap = BitmapFactory.decodeStream(url.openConnection().getInputStream());
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;detail&quot;&gt;DETAIL&lt;/h4&gt;
&lt;p&gt;HTTP(Hyper Text Transfer Protocol): HTML과 같은 문서 정보를 주고받을 수 있는 규약
API 사용 시, 크롬 내 JSONView 확장프로그램을 이용해 가시성 좋게 포맷팅 가능&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse 안드로이드 앱 프로그래밍, 5. 네트워킹 &lt;br /&gt;
https://www.boostcourse.org/mo316/joinLectures/13169 &lt;br /&gt;
[JAVA] flush () &lt;br /&gt;
https://m.blog.naver.com/PostView.nhn?blogId=klh1514&amp;amp;logNo=120190269672&amp;amp;proxyReferer=https:%2F%2Fwww.google.com%2F&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>네트워크
by boostcourse</summary></entry><entry><title>[BoostCourse] Android Programming 04</title><link href="http://localhost:4000/BoostCourse-Android4/" rel="alternate" type="text/html" title="[BoostCourse] Android Programming 04" /><published>2021-01-03T00:00:00+09:00</published><updated>2021-01-03T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-Android4</id><content type="html" xml:base="http://localhost:4000/BoostCourse-Android4/">&lt;h2 id=&quot;화면-내비게이션&quot;&gt;화면 내비게이션&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;프래그먼트 이해하기&lt;/li&gt;
  &lt;li&gt;프래그먼트 사용하기&lt;/li&gt;
  &lt;li&gt;액션바 사용하기&lt;/li&gt;
  &lt;li&gt;탭 만들기&lt;/li&gt;
  &lt;li&gt;뷰페이저 사용하기&lt;/li&gt;
  &lt;li&gt;바로가기 메뉴 만들기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-프래그먼트-이해하기&quot;&gt;🔑 프래그먼트 이해하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　안드로이드에서 화면은 액티비티로 만들어진다. 화면 제작 중에 부분 화면을 제작해야 하는 상황이 발생할 수 있다. 부분 화면을 액티비티(뷰)로 반복해 만들어 간다면, 코드를 지속적으로 새로 작성해야 하는 불편함뿐만 아니라 액티비티를 관리하는 시스템에 부담이 커진다. 시스템이 액티비티를 관리하는 것처럼 부분 화면을 독립적으로 제작하는 방식을 통해 만들어진 것이 ‘프래그먼트’ 이다. 프래그먼트는 &lt;strong&gt;액티비티가 시스템의 역할&lt;/strong&gt;을 대신하기 때문에, 액티비티보다 가볍게 화면을 전환할 수 있다. 
&lt;br /&gt;
　액티비티의 수명 주기에서 onAttach와 onDetach가 추가된다. onAttach는 onCreate보다 먼저 호출되면 프래그먼트가 액티비티 위에 올라감을 의미한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
**MainActivity.java** &lt;br /&gt;
MainFragment fragment = new MainFragment(); &lt;br /&gt;
getSupportFragmentManager().beginTransaction().add(R.id.container, fragment).commit(); &lt;br /&gt;
&lt;br /&gt;
**MainFragment.java** &lt;br /&gt;
ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_main, container, false); &lt;br /&gt;
return rootView; &lt;br /&gt;
&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;R.id.container 는 프래그먼트를 담을 공간 &lt;br /&gt; add 대신 replace 메소드 사용 시 기존 프래그먼트를 대체함&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-프래그먼트-사용하기&quot;&gt;🪓 프래그먼트 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　액티비티와 프래그먼트는 메소드와 인터페이스를 사용하여 소통할 수 있다. 프래그먼트는 인터페이스가 구현된 상위 액티비티의 메소드로 데이터를 전달하고, 액티비티는 인스턴스로 가지고 있는 프래그먼트의 메소드로 데이터를 전달할 수 있다. 즉 프래그먼트에서 액티비티로 데이터를 전달할 때에는 인터페이스가 필요하지만, 액티비티에서 프래그먼트로 데이터를 전달할 때는 단순한 메소드 호출로 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-액션바-사용하기&quot;&gt;🔨 액션바 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　액션바는 상단 타이틀을 말하며, 현재는 툴바의 기능 또한 가지고 있다.
&lt;br /&gt;
　메뉴는 옵션 메뉴(액션바에 통합됨)와 컨텍스트 메뉴(팝업)으로 나뉜다. onCreateOptionsMenu 를 통해 옵션 메뉴를 생성할 수 있으며, getMenuInflater.inflate() 를 이용해 인플레이션 작업을 해야 한다. onOptionsItemSelected는 옵션 메뉴 아이템을 클릭했을 때 호출하는 메서드이다. 메서드 내부에서 item.getItemId()를 사용해 아이템을 선택할 수 있다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
**menu 태그 내부** &lt;br /&gt;
&amp;lt;item id, title, icon, app:showAsAction, app:actionLayout&amp;gt; &lt;br /&gt;
showAsAction = &quot;always&quot; &quot;ifRoom&quot; &quot;withText&quot; &quot;never&quot; &lt;br /&gt;
actionLayout = &quot;@layout/search_layout&quot; //이런식으로 부분화면 레이아웃 추가가능 &lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-탭-사용하기&quot;&gt;⛏ 탭 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　탭은 하나의 화면에 여러 가지 서브화면들을 넣어둘 수 있는 장점이 있어 자주 사용된다. 몇 개의 탭 버튼이 상단이나 하단에 있고 그 탭 버튼을 누르면 화면이 전환되는 방식이다.
&lt;br /&gt;
　CoordinatorLayout을 사용하면 상단에 액션바 추가 시에 액션바와 아래 화면이 겹치지 않도록 생성해줄 수 있다. 강의는 해당 레이아웃 내에 액션바와 하단 탭 버튼을 추가하는 예제를 진행한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
CoordinatorLayout-AppBarLayout-Toolbar-/AppBarLayout-TabLayout/-/Coor-&amp;gt; FrameLayout &lt;br /&gt;
app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; //FrameLayout이 원래 레이아웃 화면 부분이며, 상단은 액션바 영역임을 구분함 &lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-뷰페이저-사용하기&quot;&gt;⚒ 뷰페이저 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　뷰페이저란 좌우 스크롤을 통해 하나의 뷰페이저 안에 들어가있는 화면이 넘어가는 기능을 제공한다. 일반적으로 뷰페이지 안에 여러 개의 부분 화면인 프래그먼트가 들어간다. 여러 개의 아이템 중 하나를 선택하는 ‘선택 위젯’이므로 어댑터를 사용한다. 즉 어댑터가 실제 데이터를 관리하고 뷰페이저는 껍데기를 역할을 하게 된다.
&lt;br /&gt;
　뷰페이저의 화면이 몇개이고, 몇번째 화면인지 알고 싶을 때는 타이틀스트립(PagerTitleStrip) 혹은 탭스트립(PagerTapStrip)을 사용한다. 예시로 타이틀스트립을 사용하는 경우에는, 프래그먼트 어댑터 내에 getPageTitle 메서드를 통해 페이지마다 타이틀을 붙여 리턴하면 된다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
MainActivity extends FragmentStatePagerAdapter &lt;br /&gt;
ArrayList Fragment items // 프래그먼트 아이템 관리 &lt;br /&gt;
viewpager.setOffscreenPageLimit(3) // 몇 개의 화면을 보여줄지 &lt;br /&gt;
viewpager.setAdapter(adpater); &lt;br /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-바로가기-메뉴-만들기&quot;&gt;🛠 바로가기 메뉴 만들기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　타이틀 왼쪽에 햄버거 모양의 아이콘을 바로가기 메뉴 화면이라고 부른다. 안드로이드에서는 NavigationDrawer라고 불리며 이는 기본적으로 제공된다. 해당 기능은 프래그먼트로 구성되기 때문에 프래그먼트의 동작원리를 정확히 이해하는 것이 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse 안드로이드 앱 프로그래밍, 4. 화면 내비게이션 &lt;br /&gt;
https://www.boostcourse.org/mo316/joinLectures/13161&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>화면 내비게이션
by boostcourse</summary></entry><entry><title>[BoostCourse] Android Programming 03</title><link href="http://localhost:4000/BoostCourse-Android03/" rel="alternate" type="text/html" title="[BoostCourse] Android Programming 03" /><published>2021-01-01T00:00:00+09:00</published><updated>2021-01-01T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-Android03</id><content type="html" xml:base="http://localhost:4000/BoostCourse-Android03/">&lt;h2 id=&quot;화면-여러-개-만들기&quot;&gt;화면 여러 개 만들기&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;화면 전환하기&lt;/li&gt;
  &lt;li&gt;인텐트 살펴보기&lt;/li&gt;
  &lt;li&gt;수명주기 이해하기&lt;/li&gt;
  &lt;li&gt;서비스 사용하기&lt;/li&gt;
  &lt;li&gt;브로드캐스트 수신자 사용하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-화면-전환하기&quot;&gt;🔑 화면 전환하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　시스템이 관리하는 애플리케이션 구성요소는 액티비티(Acitity)ㆍ서비스(Service)ㆍ브로드캐스트 리시버(Broadcast Receiver)ㆍ내용 제공자(Content Provider) 가 있다. 각 클래스들은 안드로이드 SDK가 제공하며, 매니페스트 파일을 통해 어떤 애플리케이션 구성요소가 포함되어 있는 지 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;　애플리케이션 구성요소 중 &lt;strong&gt;액티비티(Activity)&lt;/strong&gt;는 안드로이드 앱에서 하나의 화면을 만든다. 하나의 액티비티가 또 다른 액티비티로, 즉 화면이 전환되기 위해 &lt;strong&gt;인텐트(Intent)&lt;/strong&gt; 객체를 사용한다. startActivityForResult 메소드를 호출하면 인텐트 객체가 시스템(액티비티 매니저)으로 전달된다. 액티비티 매니저는 인텐트가 지정한 액티비티를 실행하여 화면에 보여주게 된다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
// 클래스 인스턴트를 인텐트의 파라미터로 넘겨주는 방식 &lt;br /&gt;
Intent intent = new Intent(Context pakageContext, Class&amp;lt;?&amp;gt; cls); &lt;br /&gt;
startActivityForResult(intent, INT_REQUEST_CODE); &lt;br /&gt;
&lt;br /&gt;
startActivityForResult(new Intent(MainActivity.this, SubActivity.class), INT_REQUEST_CODE); &lt;br /&gt;
&lt;br /&gt;
// ComponentName 객체 만들어 설정하는 방식 &lt;br /&gt;
Intent intent = new Intent(); &lt;br /&gt;
ComponentName name = new ComponentName(&quot;org.techtown.intent&quot;, &quot;org.techdown.intent.SubActivity&quot;); &lt;br /&gt;
intent.setComponent(name); &lt;br /&gt;
startActivityForResult(intent, INT_REQUEST_CODE); &lt;br /&gt; &lt;br /&gt;
finish();
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-인텐트-살펴보기&quot;&gt;🪓 인텐트 살펴보기&lt;/h3&gt;

&lt;h4 id=&quot;인텐트-종류&quot;&gt;인텐트 종류&lt;/h4&gt;
&lt;p&gt;　시스템에서 이해할 수 있는 객체로 만들어진 것이 &lt;strong&gt;인텐트(Intent)&lt;/strong&gt;이며, 화면을 실행할 때 인텐트가 사용된다. 인텐트에는 컴포넌트 A가 컴포넌트 B를 호출할 때 필요한 정보를 담고 있으며, 이 정보에는 호출되는 컴포넌트 B의 이름이 &lt;code class=&quot;highlighter-rouge&quot;&gt;명시적&lt;/code&gt;으로 표시되기도 하고, 속성들이 &lt;code class=&quot;highlighter-rouge&quot;&gt;암시적&lt;/code&gt;으로 표시되기도 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;① 명시적 인텐트 &lt;br /&gt; 인텐트에 클래스 객체 컴포넌트 이름을 지정하여 호출된 대상을 확실히 알 수 있는 경우에 사용한다. 주로 애플리케이션 내부에서 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;② 암시적 인텐트 &lt;br /&gt; 인텐트의 액션과 테이터를 지정하긴 했지만, 호출할 대상이 달라질 수 있는 경우에는 암시적 인텐트를 사용한다. 즉, 설치된 애플리케이션들에 대한 정보를 알고 있는 안드로이드 시스템이 인텐트를 이용해 요청한 정보를 처리할 수 있는 적절한 컴포넌트를 찾아본 다음, 사용자에게 그 대상과 처리 결과를 보여주는 과정을 거치게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;인텐트-플래그&quot;&gt;인텐트 플래그&lt;/h4&gt;
&lt;p&gt;　새로 실행하려는 액티비티와 화면에 보이는 액티비티가 동일한 액티비티인 경우 (ex. 서비스), 플래그를 사용하여 메모리에 액티비티를 새로 만들지 않고 화면에 보이는 액티비티를 재사용한다. 이같은 경우에 onCreate 메소드 대신 onNewIntent 메소드가 호출되어 인텐트를 전달받을 수 있다. 액티비티를 재사용할 시에는 인텐트에 추가할 수 있는 옵션인 &lt;strong&gt;플래그&lt;/strong&gt;를 활용한다. 즉, 시스템이 인텐트를 해석한 후 동작시킬 때 옵션에 따라 다른 동작을 하도록 한다. 플래그를 이해하기 위해서는 액티비티 스택에서 액티비티가 관리된다는 점을 알아야 한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
 intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); //설정 &lt;br /&gt;
 intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); //추가
 &lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;부가-데이터&quot;&gt;부가 데이터&lt;/h4&gt;

&lt;p&gt;　인텐트는 시스템을 통해 다른 액티비티로 전달될 수 있는데 액티비티뿐만 아니라 다른 애플리케이션 구성요소로도 전달될 수 있다. 애플리케이션 구성요소들 간에 데이터를 전달하는 데 인텐트가 사용되는 것이다. 부가 데이터는 시스템에서 건드리지 않고 전달만 되며, 인텐트 안에 번들(Bundle) 객체가 들어있어 그 안에 데이터를 넣을 때는 put, 데이터를 가져올 때는 get 메소드를 사용한다.&lt;/p&gt;

&lt;p&gt;　기존의 put, get 메소드를 이용해 인텐트에 넣을 수 있는 부가데이터의 자료형은 기본 자료형뿐이다. 다양한 객체의 정보를 전달하기 위해서는 &lt;strong&gt;Serializble&lt;/strong&gt; 또는 &lt;strong&gt;Parcelable&lt;/strong&gt; 객체를 만들어 전달할 수 있다.&lt;/p&gt;

&lt;p&gt;　데이터 클래스를 별도로 생성하여 전달할 때, 안드로이드에서는 Parcelable을 구현하는 것을 추천하고 있다. Serializable은 데이터를 효율적이지 않게 일렬 데이터로 만들어 전송하는 반면 Parcelable은 데이터 타입에 맞게 가공해준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-수명주기-이해하기&quot;&gt;🔨 수명주기 이해하기&lt;/h3&gt;

&lt;p&gt;　액티비티 수명주기는 액티비티의 상태가 변할 때마다 안드로이드 시스템에서 각 상황에 맞는 메소드를 자동으로 호출해줌으로써, 직접 상태에 맞는 코드를 넣어 액티비티의 상태에 따라 제어할 수 있도록 해준다.&lt;/p&gt;

&lt;p&gt;　&lt;img src=&quot;http://localhost:4000/images/android_lifecycle.png&quot; alt=&quot;Android_LifeCycle&quot; height=&quot;50&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　화면이 없어질 때 데이터를 임시로 저장할 때는 &lt;strong&gt;onPause()&lt;/strong&gt; 메소드를, 데이터를 복구할 때는 &lt;strong&gt;onResume()&lt;/strong&gt; 메소드를 사용한다. 이때 데이터는 SharedPreferences를 이용하면 저장할 수 있다. 또는 onSaveInstanceState 메소드와 onRestoreInstanceState 메소드를 사용하는 방법이 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-서비스-사용하기&quot;&gt;⛏ 서비스 사용하기&lt;/h3&gt;

&lt;p&gt;　&lt;strong&gt;서비스(Service)&lt;/strong&gt;는 화면이 없는 상태(백그라운드)에서 실행되는 애플리케이션의 구성요소 중 하나다. 인터넷을 통해 데이터를 주고받는 경우가 많은데 이때 대부분 서비스라는 것을 사용하게 된다. 애플리케이션 구성요소이기 때문에 프로젝트에 추가할 때 매니페스트 파일에 &lt;Service&gt; 태그를 사용한다. 서비스는 startService 메소드를 호출하면 시작된다.&lt;/Service&gt;&lt;/p&gt;

&lt;p&gt;　startService 메소드는 또한 인텐트 안에 넣어 전달한 명령이나 데이터를 처리할 수 있도록 onStartCommand() 메소드를 사용한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
@Override &lt;br /&gt;
public int onStartCommand(Intent intent, int flags, int startId) { &lt;br /&gt;
　Log.d(TAG, &quot;onStartCommand() 호출됨&quot;); &lt;br /&gt;
　return super.onStartCommand(intent, flags, startId); &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;　화면이 없는 서비스에서 화면이 있는 액티비티를 띄울 때는 태스크(Task)를 새로 만들어서 연결해야 한다. 그와 같은 경우에 일반적으로 세 개의 플래그(FLAG_ACTIVITY_NEW_TASK, FLAG_ACTIVITY_SINGLE_TOP, FLAG_ACTIVITY_CLEAR_TOP)를 사용한다. 그러면 액티비티는 새로 만들어지지 않고 기존 액티비티를 사용하고, onNewIntent 메소드가 자동으로 호출된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-브로드캐스트-수신자-사용하기&quot;&gt;⚒ 브로드캐스트 수신자 사용하기&lt;/h3&gt;

&lt;p&gt;　브로드캐스팅이란 여러 사람에게 동시에 데이터를 전달하는 것을 말한다. 안드로이드는 여러 애플리케이션 구성 요소에게 메시지를 전달하고 싶은 경우에 브로드캐스팅을 사용한다. 브로드캐스트 수신자 또한 애플리케이션 구성요소이므로 매니페스트 파일에 정보를 추가해준다. intent-filter 태그 내에는 어떤 브로드캐스팅 메시지를 받고 싶은지 지정할 수 있다. 또한 브로드캐스팅 메시지는 인텐트 객체로 만들어져 전달된다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
receiver android:name=&quot;.SmsReceiver&quot; &lt;br /&gt;
　intent-filter &lt;br /&gt;
　　action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot; &lt;br /&gt;
　/intent-filter &lt;br /&gt;
/receiver
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;detail&quot;&gt;DETAIL&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Serialization(직렬화)&lt;/code&gt; : 객체를 저장 장치에 저장 혹은 네트워크 전송을 위해 텍스트나 이진 형식으로 변환하는 것 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Serializble(객체 직렬화)&lt;/code&gt; : 객체를 바이트로 저장하는 자바의 인터페이스 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Parcelable&lt;/code&gt; : 안드로이드 SDK가 포함하고 있는 인터페이스 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt; : 자바 기능 중 하나로, 클래스나 인터페이스의 정보에 직접 접근할 수 있도록 하는 API &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Bundle&lt;/code&gt; : 여러 가지 타입의 값을 저장하는 Map 클래스이다. 예를 들면 String 값을 Bundle 클래스에 Mapping(대응, 변환)하는 것이다. 즉, Bundle 은 아무거나 포장할 수 있는 상자를 의미하고 이 상자를 이용하여 이리저리 인텐트도 오고갈 수 있고 다양한 데이터 통신에 이용할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse 안드로이드 앱 프로그래밍, 3. 화면 여러 개 만들기 &lt;br /&gt;
https://www.boostcourse.org/mo316/joinLectures/13160 &lt;br /&gt;
[Android] Intent &lt;br /&gt;
https://woovictory.github.io/2019/01/02/Android-What-is-Intent/ &lt;br /&gt;
Intent의 Flag 사용법 &lt;br /&gt;
https://ju-hy.tistory.com/46 &lt;br /&gt;
Android Bundle 이란? &lt;br /&gt;
https://www.crocus.co.kr/1560 &lt;br /&gt;
Android Serializable vs Parcelable &lt;br /&gt;
https://wooooooak.github.io/android/2019/09/19/Serializable-vs-Parcelable/ &lt;br /&gt;
Android &amp;amp; Java - Reflection &lt;br /&gt;
https://two22.tistory.com/14&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>화면 여러 개 만들기
by boostcourse</summary></entry><entry><title>[BoostCourse] Android Programming 02</title><link href="http://localhost:4000/BoostCourse-Android2/" rel="alternate" type="text/html" title="[BoostCourse] Android Programming 02" /><published>2020-12-30T00:00:00+09:00</published><updated>2020-12-30T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-Android2</id><content type="html" xml:base="http://localhost:4000/BoostCourse-Android2/">&lt;h2 id=&quot;이벤트와-리스트뷰&quot;&gt;이벤트와 리스트뷰&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;스크롤뷰 사용하기&lt;/li&gt;
  &lt;li&gt;이벤트 이해하기&lt;/li&gt;
  &lt;li&gt;토스트와 대화상자&lt;/li&gt;
  &lt;li&gt;비트맵 버튼 만들기&lt;/li&gt;
  &lt;li&gt;인플레이션 이해하기&lt;/li&gt;
  &lt;li&gt;리스트뷰 만들기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-스크롤뷰-사용하기&quot;&gt;🔑 스크롤뷰 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　스크롤뷰는 말그대로 스크롤 기능을 위해 사용한다. 글자가 이지미가 들어간 뷰가 화면 영역을 벗어나면 보이지 않는 경우에 대비할 수 있다. 해당 뷰는 원하는 영역을 ScrollView 태그로 감싸면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-이벤트-이해하기&quot;&gt;🪓 이벤트 이해하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　화면을 터치했을 때는 ‘이벤트’가 발생한다. 해당 이벤트는 화면의 어느 부분에 어떻게 클릭하거나 터치했는지에 대한 정보를 담았으며, 리스너를 이용해 다룰 수 있다. (ex. OnClickListenr 인터페이스) 예시로, 버튼에 리스너를 등록해두면 버튼이 클릭될 때마다 리스너의 메소드가 자동으로 호출되게 된다. 그 외에도 터치 이벤트와 키 이벤트가 있다.&lt;/p&gt;

&lt;p&gt;　&lt;code class=&quot;highlighter-rouge&quot;&gt;터치 이벤트&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;boolean onTouchEvent (MotionEvent event)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　&lt;code class=&quot;highlighter-rouge&quot;&gt;키 이벤트&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;boolean onKeyDown (int keyCode, KeyEvent event) &lt;br /&gt; boolean onKeyUp (int keyCode, KeyEvent event) &lt;br /&gt; void onBackPressed() // keyCode == KeyEvent.KEYCODE_BACK&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-토스트와-대화상자&quot;&gt;🔨 토스트와 대화상자&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　&lt;strong&gt;토스트(Toast)&lt;/strong&gt; 는 간단한 메시지를 화면에 띄어주는 역할을 한다. Log 클래스를 이용해 콘솔에 메시지를 출력할 수도 있지만, 화면에 보여주고 싶다면 토스트 기능을 사용한다.&lt;/p&gt;

&lt;p&gt;　유사한 역할로, &lt;strong&gt;스낵바&lt;/strong&gt;는 화면 내 아래쪽에서 올라왔다가 사라지는 뷰이다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
Toast.makeText(Context context, String message, int duration).show(); &lt;br /&gt;
Snackbar.make(View view, CharSequence text, int duration).show();
&lt;/p&gt;

&lt;p&gt;　사용자에게 어떤 내용을 알려주거나 ‘예’, ‘아니오’ 버튼을 선택하도록 할 때는 &lt;strong&gt;알림 대화상자(AlertDialog)&lt;/strong&gt;를 사용한다. 이는 AlertDialog.Builder 객체를 사용하여, AlertDialog 객체를 만들어 show 메소드를 이용해 화면에 표시한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
AlertDialog.Builder builder = new AlertDialog.Builder(this); &lt;br /&gt;
AlertDialog dialog = builder.create(); &lt;br /&gt;
dialog.show();
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-비트맵-버튼-만들기&quot;&gt;⛏ 비트맵 버튼 만들기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　&lt;strong&gt;① 나인패치(9Patch)&lt;/strong&gt;&lt;br /&gt;
　이미지 파일 이름에 .9 라는 글자를 붙여 나인패치 이미지를 생성할 수 있다. 이는 이미지의 깨질 가능성이 있는 부분은 늘리지 않아, 이미지의 크기가 변형되더라도 덜 왜곡된다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;② 비트맵 버튼(BitmapButton)&lt;/strong&gt;&lt;br /&gt;
　Button 을 상속하여 새로운 비트맵 버튼을 생성할 수 있다. 나인패치 이미지를 적용하는 대표적인 경우가 버튼인데, 배경을 이미지로 지정하여 만든 버튼은 눌러도 이미지의 변화가 없다. 이같은 단점을 보완하기 위해 비트맵 이미지를 이용해 버튼의 상태를 이벤트로 구분해 표시할 수 있다. 배경 이미지가 변경되면 &lt;code class=&quot;highlighter-rouge&quot;&gt;invalidate 메소드를 사용해 화면을 갱신&lt;/code&gt;해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-인플레이션-이해하기&quot;&gt;⚒ 인플레이션 이해하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　XML 레이아웃에 정의된 내용이 실제 메모리에 객체화되는 (생성되는) 과정을 &lt;strong&gt;인플레이션 과정&lt;/strong&gt;이라 한다. 이같은 레이아웃 인플레이션 과정은 setContentView() 메소드를 통해 (XML 파일의 전체 화면을) 할 수 있다. 부분 화면의 경우에는 LayoutInflater 를 이용해서 직접 메모리에 객체화를 해야 한다. 인플레이션 후에는 아이디를 통해서 내부의 뷰를 찾아 사용할 수 있다!&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
FrameLayout container = findViewById(R.id.container); &lt;br /&gt;
LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE); &lt;br /&gt;
inflater.inflate(R.layout.보여줄_XML_파일명, container, true);
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-리스트뷰-만들기&quot;&gt;🛠 리스트뷰 만들기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　리스트뷰에는 여러 개의 데이터를 넣어 보여줄 수 있는데, 좀 더 쉽게 만들 수 있도록 어댑터를 만들어 사용한다. 어댑터는 여러 개의 아이템 중에서 하나를 선택하는 방식을 가진 선택 위젯에서 사용된다. 뷰가 데이터를 관리하는 것이 아닌, 어댑터가 실제 데이터를 관리하는 것이다. 각각의 아이템을 위한 뷰도 어댑터에서 만들어주기 때문에 리스트뷰는 어댑터의 getView 메소드를 호출해 뷰 객체를 반환받은 뒤 화면에 보여주게 된다.&lt;/p&gt;

&lt;p&gt;　최근 실무에서는 리스트뷰(ListView)보다 리사이클러뷰(RecyclerView)를 더 많이 사용한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;유사한 선택 위젯으로 스피너와 그리드뷰가 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;detail&quot;&gt;DETAIL&lt;/h4&gt;
&lt;p&gt;@Override : 이미 구현되어있는 코드를 덮어쓴다는 의미로, 해당 의미를 컴퓨터에게 알려주는 용도다.&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse 안드로이드 앱 프로그래밍, 2. 이벤트와 리스트뷰 &lt;br /&gt;
https://www.boostcourse.org/mo316/joinLectures/13159 &lt;br /&gt; &lt;br /&gt;
Bitmap Button 만들기 &lt;br /&gt;
https://qlyh8.tistory.com/44&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>이벤트와 리스트뷰
by boostcourse</summary></entry><entry><title>[BoostCourse] Android Programming 01</title><link href="http://localhost:4000/BoostCourse-Android1/" rel="alternate" type="text/html" title="[BoostCourse] Android Programming 01" /><published>2020-12-28T00:00:00+09:00</published><updated>2020-12-28T00:00:00+09:00</updated><id>http://localhost:4000/BoostCourse-Android1</id><content type="html" xml:base="http://localhost:4000/BoostCourse-Android1/">&lt;h2 id=&quot;레이아웃-만들기&quot;&gt;레이아웃 만들기&lt;/h2&gt;
&lt;h4 id=&quot;by-boostcourse&quot;&gt;by boostcourse&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;첫번째 앱 만들기&lt;/li&gt;
  &lt;li&gt;도구 사용하기&lt;/li&gt;
  &lt;li&gt;레이아웃 (제약, 리니어, 상대, 프레임)&lt;/li&gt;
  &lt;li&gt;기본 위젯들&lt;/li&gt;
  &lt;li&gt;드로어블 만들기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-첫번째-앱-만들기&quot;&gt;🔑 첫번째 앱 만들기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　’안드로이드 스튜디오’ 라는 도구를 사용해 안드로이드 앱을 만들 수 있다. 해당 도구는 안드로이드 개발자 사이트에서 다운로드 받을 수 있다.&lt;/p&gt;

&lt;p&gt;　애뮬레이터는 테스트할 때 사용하는 가상의 단말기다. 애뮬레이터를 실행하면 안드로이드 스튜디오를 이용해 만든 앱을 띄우고 테스트해볼 수 있다. 앱을 실행할 때는 상단의 아이콘 중 초록색 ▶ 아이콘을 누르면 된다.&lt;/p&gt;

&lt;p&gt;　프로젝트 내 파일을 살펴보면 xml과 java 로 나누어진 것을 확인할 수 있다. xml 파일은 레이아웃, java 파일은 레이아웃.xml에 기능을 넣어주는 역할을 한다.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;
http://developer.android.com/studio/index.html
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-도구-사용하기&quot;&gt;🪓 도구 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　사용자에게 보이는 화면은 XML 파일로 만들어지며, XML 레이아웃이라 부른다. XML 파일 안에는 태그와 속성들이 들어가며, 이 파일을 시스템이 읽어 화면으로 보여둔다. 또한, 화면이나 소스 코드를 수정하면 안드로이드는 수정 사항을 바로 반영하게 된다.&lt;/p&gt;

&lt;p&gt;　각 태그는 뷰를 의미하며, 속성에 붙어있는 ‘android:’ 지시어는 안드로이드 SDK에서 정의한 속성이라는 의미다. 필수적인 속성은 크기를 나타내는 layout_width, layout_height 다.&lt;/p&gt;

&lt;p&gt;　화면을 만드는 가장 기본적인 단위는 &lt;strong&gt;뷰&lt;/strong&gt;다. 뷰 중에 눈에 보이는 것들은 위젯, 눈에 보이지 않는 것들은 레이아웃이라 구분한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-레이아웃-제약-리니어-상대-프레임&quot;&gt;🔨 레이아웃 (제약, 리니어, 상대, 프레임)&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　프로젝트를 처음 만들면 제약 레이아웃(Constraintlayout)이라는 것이 버튼을 담고 있는 형태로 만들어진다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;① ConstraintLayout&lt;/strong&gt;&lt;br /&gt;
　제약 레이아웃은 제약 조건을 이용해 그 안에 추가된 뷰들의 위치를 결정한다. 그러한 제약 조건은 연결선을 통해 만들어진다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;② LinearLayout&lt;/strong&gt;&lt;br /&gt;
　리니어 레이아웃은 상자를 쌓듯 뷰를 하나씩 쌓을 수 있는 레이아웃이다. 화면에서 뷰가 차지한 영역을 상자라 보고, 이 상자를 한쪽 방향(orientation = horizontal, vertical)으로 쌓을 수 있게 한다. 뷰를 정렬할 때는 layout_gravity(뷰 정렬)와 gravity(뷰 안 내용물 정렬)를 사용한다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;③ RelativeLayout&lt;/strong&gt;&lt;br /&gt;
　상대 레이아웃은 뷰를 담고 있는 부모 레이아웃이나 그 안에 들어있는 다른 뷰들과의 상대적 위치를 이용해 화면을 배치한다. 부모 레이아웃과의 상대적 위치를 지정할 때 사용하는 속성들은 모두 Parent 라는 단어가 들어가 있지만, 다른 뷰와의 상대적 위치를 지정할 때 사용하는 속성들에는 Parent 라는 단어가 들어가 있지 않다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;④ FrameLayout&lt;/strong&gt;&lt;br /&gt;
　프레임 레이아웃은 한번에 하나의 뷰만 보여주는 레이아웃으로, 화면에는 가장 나중에 추가한 뷰만 보인다. 이런 특성 때문에 화면 중첩 시에 주로 사용된다. (가시성 visibility 속성을 함께 이용할 수 있다.)&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;⑤ TableLayout&lt;/strong&gt;&lt;br /&gt;
　테이블 레이아웃은 격자 모양으로 뷰를 배치할 때 사용한다. 레이아웃 안에서 각 행은 TableRow 태그를 이용해 추가하며, 그 안에 추가되는 뷰의 개수에 따라 열의 개수 또한 결정된다. 리니어 레이아웃을 사용하여 테이블 모양을 만들 수 있지만, 정해진 규격에 맞춰 제작하고 싶을 때 테이블 레이아웃을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-기본-위젯들&quot;&gt;⛏ 기본 위젯들&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　&lt;strong&gt;① TextView&lt;/strong&gt;&lt;br /&gt;
　텍스트뷰는 화면에 글자를 표시하도록 해준다. 해당 뷰 안에 들어가는 내용은 가급적 stings.xml 파일 안에 넣어둔 태그 값으로 설정한다. 해당 방식은 다국어를 설정할 때도 유용한데, 언어 폴더를 각각 만들어 넣어준다면 단말의 Locale(위치)에 따라 언어가 변경될 수 있다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;② Button&lt;/strong&gt;&lt;br /&gt;
　버튼은 텍스트뷰를 상속하여 만들어졌다. 이는 라디오 버튼이나 체크 박스 등으로 나누어 사용될 수 있다. 그 중 라디오 버튼은 라디오 그룹을 이용해 하나의 그룹으로 묶어줄 수 있다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;③ EditText&lt;/strong&gt;&lt;br /&gt;
　에디트텍스트는 입력 상자 역할을 한다. inputType 속성을 이용해, 어떤 유형의 글자를 입력할 지 결정한다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;④ ImageView&lt;/strong&gt;&lt;br /&gt;
　이미지뷰는 이미지를 보여주는 뷰로, res/drwable 폴더 내의 이미지를 불러와 보여준다. 이미지 파일의 확장자는 png 형식의 이미지를 권장한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-드로어블-만들기&quot;&gt;⚒ 드로어블 만들기&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　드로어블(Drawable)은 뷰에 설정할 수 있는 객체이며, 그래픽으로 그릴 수 있다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;① 상태 드로어블&lt;/strong&gt;&lt;br /&gt;
　상태 드로어블은 뷰의 상태에 따라 뷰에 보여줄 그래픽을 다르게 지정할 수 있다. drawable 폴더 내 최상위 태그는 selector 이며, 태그 내에 item 태그를 넣을 수 있으며 state_ 로 시작하는 상태를 나타내는 속성을 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;② 쉐이프 드로어블&lt;/strong&gt;&lt;br /&gt;
　쉐이프 드로어블은 XML로 도형을 그릴 수 있도록 한다. drawable 폴더 내 최상위 태그는 shape 이며, shape 속성을 이용해 원하는 모양의 도형을 지정할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;태그 종류&lt;/strong&gt; &lt;br /&gt; stroke : 테두리 선 속성 지정 &lt;br /&gt; width : 선의 굵기 &lt;br /&gt; color : 선의 색상 &lt;br /&gt; solid : 도형의 안쪽 채우기 &lt;br /&gt; gradient : 배경색으로 그라데이션 설정&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;boostcourse 안드로이드 앱 프로그래밍, 1. 레이아웃 만들기 &lt;br /&gt;
https://www.boostcourse.org/mo316/joinLectures/13158&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary>레이아웃 만들기
by boostcourse</summary></entry></feed>
