<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.6.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-09-18T15:26:27+09:00</updated><id>http://localhost:4000/</id><title>UUNWON</title><subtitle>Student at Korea Polytechnic University</subtitle><entry><title>[BaekJoon] 11721. Print by ten</title><link href="http://localhost:4000/Baekjoon11721/" rel="alternate" type="text/html" title="[BaekJoon] 11721. Print by ten" /><published>2020-09-18T00:00:00+09:00</published><updated>2020-09-18T00:00:00+09:00</updated><id>http://localhost:4000/Baekjoon11721</id><content type="html" xml:base="http://localhost:4000/Baekjoon11721/">&lt;h2 id=&quot;열-개씩-끊어-출력하기&quot;&gt;열 개씩 끊어 출력하기&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　알파벳 소문자와 대문자로만 이루어진 길이가 N인 단어가 주어진다. 한 줄에 10글자씩 끊어서 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 단어가 주어진다. 단어는 알파벳 소문자와 대문자로만 이루어져 있으며, 길이는 100을 넘지 않는다. 길이가 0인 단어는 주어지지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　입력으로 주어진 단어를 열 개씩 끊어서 한 줄에 하나씩 출력한다. 단어의 길이가 10의 배수가 아닌 경우에는 마지막 줄에는 10개 미만의 글자만 출력할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class NewClass{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　String word = sc.next(); &lt;br /&gt;
　　　　int len = word.length(); &lt;br /&gt;
&lt;br /&gt;
　　　　for(int i = 0;i &amp;lt; len;i++) { &lt;br /&gt;
　　　　　　if(i % 10 == 9) { &lt;br /&gt;
　　　　　　　　System.out.println(word.charAt(i)); &lt;br /&gt;
　　　　　　　　continue; &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　　　System.out.print(word.charAt(i)); &lt;br /&gt;
　　　　} &lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/11721, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>열 개씩 끊어 출력하기
by BaekJoon</summary></entry><entry><title>[BaekJoon] 11720. Sum of Number</title><link href="http://localhost:4000/Baekjoon11720/" rel="alternate" type="text/html" title="[BaekJoon] 11720. Sum of Number" /><published>2020-09-18T00:00:00+09:00</published><updated>2020-09-18T00:00:00+09:00</updated><id>http://localhost:4000/Baekjoon11720</id><content type="html" xml:base="http://localhost:4000/Baekjoon11720/">&lt;h2 id=&quot;숫자의-합&quot;&gt;숫자의 합&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　입력으로 주어진 숫자 N개의 합을 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class NewClass{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　int sum = 0; &lt;br /&gt;
　　　　&lt;br /&gt;
　　　　int count = sc.nextInt(); &lt;br /&gt;
　　　　String num = sc.next(); &lt;br /&gt;
        &lt;br /&gt;
　　　　if(num.length() == count) { &lt;br /&gt;
　　　　　　for(int i = 0;i &amp;lt; count;i++) { &lt;br /&gt;
　　　　　　　　sum += Integer.parseInt(num.substring(i, i+1)); &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　　　System.out.println(sum); &lt;br /&gt;
　　　　} else { &lt;br /&gt;
　　　　　　System.out.println(&quot;out of index&quot;); &lt;br /&gt;
　　　　　　return; &lt;br /&gt;
　　　　} &lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;　💌 string.charAt(i) - ‘0’&lt;br /&gt;
　　: string의 i 위치 char를 아스키 코드를 활용해 int로 변경&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/11720, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>숫자의 합
by BaekJoon</summary></entry><entry><title>[BaekJoon] 1924. 2007</title><link href="http://localhost:4000/2007/" rel="alternate" type="text/html" title="[BaekJoon] 1924. 2007" /><published>2020-09-18T00:00:00+09:00</published><updated>2020-09-18T00:00:00+09:00</updated><id>http://localhost:4000/2007</id><content type="html" xml:base="http://localhost:4000/2007/">&lt;h2 id=&quot;2007년&quot;&gt;2007년&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　오늘은 2007년 1월 1일 월요일이다. 그렇다면 2007년 x월 y일은 무슨 요일일까? 이를 알아내는 프로그램을 작성하시오.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 빈 칸을 사이에 두고 x(1&amp;lt;= x &amp;lt;=12)와 y(1&amp;lt;= y &amp;lt;=31)이 주어진다. 참고로 2007년에는 1, 3, 5, 7, 8, 10, 12월은 31일까지, 4,6,9,11월은 30일까지, 2월은 28일까지 있다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　첫째 줄에 x월 y일이 무슨 요일인지에 따라 SUN, MON, TUE, WED, THU, FRI, SAT중 하나를 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class NewClass { &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　int[] date = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; &lt;br /&gt;
　　　　String[] day = {&quot;SUN&quot;, &quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;}; &lt;br /&gt;
　　　　int result = 0; &lt;br /&gt;
&lt;br /&gt;
　　　　int x = sc.nextInt(); &lt;br /&gt;
　　　　int y = sc.nextInt(); &lt;br /&gt;
　　　　for(int i = 0;i &amp;lt; x - 1;i++) { &lt;br /&gt;
　　　　　　result += date[i]; &lt;br /&gt;
　　　　} result += y; &lt;br /&gt;
&lt;br /&gt;
　　　　int temp = result % day.length; &lt;br /&gt;
　　　　System.out.println(day[temp]); &lt;br /&gt;
&lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/1924, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>2007년
by BaekJoon</summary></entry><entry><title>[BaekJoon] 2557. Hello World</title><link href="http://localhost:4000/BaekJoon2557/" rel="alternate" type="text/html" title="[BaekJoon] 2557. Hello World" /><published>2020-09-17T00:00:00+09:00</published><updated>2020-09-17T00:00:00+09:00</updated><id>http://localhost:4000/BaekJoon2557</id><content type="html" xml:base="http://localhost:4000/BaekJoon2557/">&lt;h2 id=&quot;hello-world&quot;&gt;Hello World&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　Hello World!를 출력하시오.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　없음&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　Hello World!를 출력하시오.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
public class NewClass{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　System.out.println(&quot;Hello World!&quot;); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/2557, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>Hello World
by BaekJoon</summary></entry><entry><title>[BaekJoon] 11718. Print intactly</title><link href="http://localhost:4000/BaekJoon11718/" rel="alternate" type="text/html" title="[BaekJoon] 11718. Print intactly" /><published>2020-09-17T00:00:00+09:00</published><updated>2020-09-17T00:00:00+09:00</updated><id>http://localhost:4000/BaekJoon11718</id><content type="html" xml:base="http://localhost:4000/BaekJoon11718/">&lt;h2 id=&quot;그대로-출력하기&quot;&gt;그대로 출력하기&lt;/h2&gt;
&lt;h4 id=&quot;by-baekjoon&quot;&gt;by BaekJoon&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-problem&quot;&gt;💡 Problem&lt;/h2&gt;
&lt;p&gt;　입력 받은 대로 출력하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;p&gt;　입력이 주어진다. 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. 각 줄은 100글자를 넘지 않으며, 빈 줄은 주어지지 않는다. 또, 각 줄은 공백으로 시작하지 않고, 공백으로 끝나지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;
&lt;p&gt;　입력받은 그대로 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-solving&quot;&gt;🎯 Solving&lt;/h2&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class NewClass{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(System.in); &lt;br /&gt;
　　　　StringBuffer buffer = new StringBuffer(); &lt;br /&gt;
        &lt;br /&gt;
　　　　while(sc.hasNextLine()) { &lt;br /&gt;
　　　　　　buffer.append(sc.nextLine() + '\n'); &lt;br /&gt;
　　　　} &lt;br /&gt;
        &lt;br /&gt;
　　　　System.out.println(buffer); &lt;br /&gt;
　　　　sc.close(); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://www.acmicpc.net/problem/11718, 백준&lt;/p&gt;</content><category term="java" /><category term="code" /><category term="baekjoon" /><summary>그대로 출력하기
by BaekJoon</summary></entry><entry><title>[Jump to Java] Self Number</title><link href="http://localhost:4000/Jump-to-Java3/" rel="alternate" type="text/html" title="[Jump to Java] Self Number" /><published>2020-09-16T00:00:00+09:00</published><updated>2020-09-16T00:00:00+09:00</updated><id>http://localhost:4000/Jump-to-Java3</id><content type="html" xml:base="http://localhost:4000/Jump-to-Java3/">&lt;h2 id=&quot;self-number&quot;&gt;Self Number&lt;/h2&gt;
&lt;h4 id=&quot;by-jump-to-java&quot;&gt;by Jump-to-Java&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;넥슨의 입사 문제,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“어떤 자연수 n이 있을 때, d(n)을 n의 각 자릿수 숫자들과 n 자신을 더한 숫자라고 정의하자. 이때, n을 d(n)의 제네레이터라고 한다. 어떤 숫자들은 하나 이상의 제네레이터를 가지고 있는데, 101의 제네레이터는 91 뿐 아니라 100도 있다. 그런데 반대로 제네레이터가 없는 숫자들도 있으며, 이런 숫자를 인도의 수학자 Kaprekar가 셀프 넘버(self-number)라 이름 붙였다. 예를 들어 1, 3, 5, 7, 9, 20, 31은 셀프 넘버들이다. &lt;strong&gt;1 이상이고 5000보다 작은 모든 셀프 넘버들의 합을 구하라.&lt;/strong&gt;”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://wikidocs.net/238, 점프 투 자바&lt;/p&gt;</content><category term="java" /><category term="code" /><summary>Self Number
by Jump-to-Java</summary></entry><entry><title>[Jump to Java] Multiples of 3 and 5</title><link href="http://localhost:4000/Jump-to-Java2/" rel="alternate" type="text/html" title="[Jump to Java] Multiples of 3 and 5" /><published>2020-09-16T00:00:00+09:00</published><updated>2020-09-16T00:00:00+09:00</updated><id>http://localhost:4000/Jump-to-Java2</id><content type="html" xml:base="http://localhost:4000/Jump-to-Java2/">&lt;h2 id=&quot;multiples-of-3-and-5&quot;&gt;Multiples of 3 and 5&lt;/h2&gt;
&lt;h4 id=&quot;by-jump-to-java&quot;&gt;by Jump-to-Java&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;프로젝트 오일러에서 제공하는 첫번째 퀴즈,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;10 미만의 자연수에서 3과 5의 배수를 구하면 3, 5, 6, 9이다. 이들의 총합은 23이다. 1000미만의 자연수에서 3, 5의 배수의 총합을 구하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p class=&quot;notice&quot;&gt;
public class multiplesof3and5{ &lt;br /&gt;
　　int max; &lt;br /&gt;
    &lt;br /&gt;
　　public multiplesof3and5(int max){ &lt;br /&gt;
　　　　this.max = max; &lt;br /&gt;
　　} &lt;br /&gt;
　　&lt;br /&gt;
　　public int sum(){ &lt;br /&gt;
　　　　int sum = 0; &lt;br /&gt;
　　　　for(int i = 0;i &amp;lt; max;i++){ &lt;br /&gt;
　　　　　　if((i % 3 == 0) || (i % 5) == 0){ &lt;br /&gt;
　　　　　　　　sum += i; &lt;br /&gt;
　　　　　　} &lt;br /&gt;
　　　　} &lt;br /&gt;
　　　　return sum; &lt;br /&gt;
　　} &lt;br /&gt;
    &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　System.out.println(new multiplesof3and5(10).sum()); &lt;br /&gt;
　　　　System.out.println(new multiplesof3and5(1000).sum()); &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://wikidocs.net/237, 점프 투 자바&lt;/p&gt;</content><category term="java" /><category term="code" /><summary>Multiples of 3 and 5
by Jump-to-Java</summary></entry><entry><title>[Jump to Java] Multiplication table</title><link href="http://localhost:4000/Jump-to-Java/" rel="alternate" type="text/html" title="[Jump to Java] Multiplication table" /><published>2020-09-15T00:00:00+09:00</published><updated>2020-09-15T00:00:00+09:00</updated><id>http://localhost:4000/Jump-to-Java</id><content type="html" xml:base="http://localhost:4000/Jump-to-Java/">&lt;h2 id=&quot;multiplication-table&quot;&gt;Multiplication table&lt;/h2&gt;
&lt;h4 id=&quot;by-jump-to-java&quot;&gt;by Jump-to-Java&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;구구단을 구현해보자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p class=&quot;notice&quot;&gt;
import java.util.*; &lt;br /&gt;
&lt;br /&gt;
public class multiplicationTable{ &lt;br /&gt;
　　public static void main(String[] args){ &lt;br /&gt;
　　　　Scanner sc = new Scanner(Sysete.in); &lt;br /&gt;
　　　　int num; &lt;br /&gt;
&lt;br /&gt;
　　　　System.out.println(&quot;원하는 구구단은? &quot;); &lt;br /&gt;
　　　　num = sc.nextInt(); &lt;br /&gt;
&lt;br /&gt;
　　　　for(int i = 0;i &amp;lt; 9;i++){ &lt;br /&gt;
　　　　　　System.out.print((num * (i+1)) + &quot; &quot;); &lt;br /&gt;
　　　　} &lt;br /&gt;
　　} &lt;br /&gt;
}
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;　💌 사이트의 소스에서 &lt;strong&gt;toString()&lt;/strong&gt; 부분을 눈여겨보자. toString이 클래스 내에 선언되면 특별한 의미를 갖게 된다. new 키워드로 생성한 객체를 System.out.println 같은 걸로 출력했을 때 toString 메소드가 구현되어 있을 경우 toString) 메소드를 수행한 결과값을 리턴하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;https://wikidocs.net/236, 점프 투 자바&lt;/p&gt;</content><category term="java" /><category term="code" /><summary>Multiplication table
by Jump-to-Java</summary></entry><entry><title>Android Layout</title><link href="http://localhost:4000/Android-Layout/" rel="alternate" type="text/html" title="Android Layout" /><published>2020-09-03T00:00:00+09:00</published><updated>2020-09-03T00:00:00+09:00</updated><id>http://localhost:4000/Android-Layout</id><content type="html" xml:base="http://localhost:4000/Android-Layout/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;안드로이드-레이아웃&quot;&gt;안드로이드 레이아웃&lt;/h2&gt;

&lt;p&gt;　안드로이드 UI 프로그램에서 화면 구성을 위한 뷰 클래스도 중요하지만, 해당 뷰들을 화면에 어떻게 배치할 것인가도 중요하다. 뷰를 적절하게 배치하는 데 사용하는 레이아웃 클래스를 살펴보자. 레이아웃 클래스는 화면에 출력되는 대상이지만, 자체 UI는 갖지 않는다. 레이아웃 클래스는 Button 같은 뷰들을 자신에게 포함(Add)하고 적절하게 배치해 화면에 한꺼번에 출력한다.&lt;/p&gt;

&lt;p&gt;　레이아웃 클래스마다 포함된 뷰의 정렬 규칙이 다른 것이지, 특정 화면을 특정 레이아웃으로만 구성할 수 있는 건 아니다. 화면을 작성할 때 무조건 특정 레이아웃을 사용해야 완성할 수 있는 경우도 있지만, 대부분 개발자의 선택에 따른다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;레이아웃-종류&quot;&gt;레이아웃 종류&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;LinearLayout&lt;/li&gt;
  &lt;li&gt;RelativeLayout&lt;/li&gt;
  &lt;li&gt;FrameLayout&lt;/li&gt;
  &lt;li&gt;TableLayout&lt;/li&gt;
  &lt;li&gt;GridLayout&lt;/li&gt;
  &lt;li&gt;ConstraintLayout&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-linearlayout&quot;&gt;📱 LinearLayout&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　가장 많이 이용되는 레이아웃 중 하나가 LinearLayout 이다. 이는 해당 레이아웃에 포함된 뷰를 순서대로 가로나 세로 방향으로 나열한다. 따라서 다른 레이아웃에서는 없는 방향을 지정하는 orientation 속성을 제공한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;기본적으로 레이아웃에서 뷰의 위치는 왼쪽 위이다. 뷰의 정렬과 관련된 속성은 &lt;strong&gt;gravity&lt;/strong&gt;(뷰의 내용을 뷰 영역 내 어디에 나타낼지)와 &lt;strong&gt;layout_gravity&lt;/strong&gt;(뷰를 LinearLayout 영역 내 어디에 나타낼지)로 다룰 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;weigh&lt;/strong&gt; 속성은 이용 빈도가 높은 속성이다. 여백과 관련이 있는 속성으로, 레이아웃에 뷰를 배치하다 보면 가로나 세로 방향으로 여백이 발생할 수 있다. 이 여백을 화면에 배치된 뷰들이 확장해서 차지하게 할 때 이용된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-relativelayout&quot;&gt;📲 RelativeLayout&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　RelativeLayout은 화면에 이미 배치된 뷰를 기준으로 다른 뷰의 위치를 지정하는 레이아웃이다. 예를 들어, RelativeLayout에 Button을 포함한 후 다른 Button을 포함하면, 이전 Button 위에 덮어쓰듯이 올라가게 된다. 이때 가로세로 방향의 orientation을 생각할 수 있는데, orientation 속성은 LinearLayout에만 지정할 수 있다. RelativeLatout에서 &lt;strong&gt;상대 위치를 지정하는 속성&lt;/strong&gt;은 다음 4가지가 있다. 이 4가지 속성값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;기준 뷰의 id&lt;/code&gt;이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;android:layout_above: 기준 뷰의 윗부분에 배치 &lt;br /&gt; android:layout_below: 기준 뷰의 아랫부분에 배치 &lt;br /&gt; android: layout_toLeftOf: 기준 뷰의 왼쪽에 배치 &lt;br /&gt; android: layout_toRightOf: 기준 뷰의 오른쪽에 배치&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　위와 같은 속성뿐 아니라, 기준이 되는 뷰와 왼쪽 변을 맞추거나 윗변을 맞추는 등의 작업도 중요하다. 이 부분을 지원하기 위한 속성이 align이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;android:layout_alignTop: 기준 뷰와 윗부분을 정렬 &lt;br /&gt; android:layout_alignBottom: 기준 뷰와 아랫부분을 정렬 &lt;br /&gt; android:layout_alignLeft: 기준 뷰와 왼쪽을 정렬 &lt;br /&gt; android:layout_alignRight: 기준 뷰와 오른쪽을 정렬 &lt;br /&gt; android:layout_alignBaseline: 기준 뷰와 텍스트 기준선을 정렬&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-framelayout&quot;&gt;📳 FrameLayout&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　FrameLayout은 레이아웃에 포함된 뷰들을 같은 영역에 겹쳐서 배치할 때 사용한다. 레이아웃 자체의 특별한 속성은 없다. 이를 이용하는 목적은 대부분 같은 영역에 여러 뷰를 겹치게 한 다음, 한 순간에 하나의 뷰만 보이기 위함이다. 이를 위해 visibility 속성으로 특정 순간에 뷰가 보이거나 보이지 않게 제어하면 된다.&lt;/p&gt;

&lt;p class=&quot;notice_info&quot;&gt;TabHost: 탭 화면은 화면 여러 개를 준비한 다음, 사용자가 버튼을 누를 때 버튼과 연결된 화면을 하나씩 보여주는 형태로 TabHost 클래스를 사용해 작업을 더 쉽게 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-tablelayout&quot;&gt;📴 TableLayout&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　TableLayout은 뷰를 테이블 구조로 나열하는 레이아웃이다. 레이아웃 내에 하나의 뷰가 여러 셀을 차지하게 할 수도 있으며, 여백이 발생할 경우 특정 열(column)을 확장할 수도 있고, 화면 크기를 벗어나는 순간 특정 열을 축소하는 등 다양하게 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-gridlayout&quot;&gt;📱 GridLayout&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　GridLayout은 뷰를 테이블 구조로 나열한다. 이는 뷰가 테이블 구조로 나열된다는 점에서 TableLayout과 유사하고, 뷰가 레이아웃에 포함된 순서대로 가로나 세로 방향으로 나열된다는 점에서 LinearLayout과도 유사하다. 또한, LinearLayout에는 없는 자동 개행 능력도 있어 화면에는 TableLayout처럼 보이기도 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TableLayout이 있는데, GridLayout을 사용하는 이유? &lt;br /&gt; TableLayout은 각 행을 TalbeRow로 묶어주어야 하므로, 셀의 개수를 예상할 수 없거나 가변적일 때는 화면 구성이 복잡해진다. 하지만 GridLayout은 별도로 행을 표현하지 않아도 뷰를 순서대로 포함만 하면 알아서 개행하여 행이 자동으로 표현되므로 편리한 측면이 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;orientation: 뷰의 배치 방향을 지정. 기본값은 가로 방향 &lt;br /&gt; columnCount: 가로 방향일 때 한 줄에 몇 개의 뷰를 나열할 것인지 지정 &lt;br /&gt; rowCount: 세로 방향일 떄 한 줄에 몇 개의 뷰를 나열할 것인지 지정&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-constraintlayout&quot;&gt;📲 ConstraintLayout&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
　ConstraintLayout은 안드로이드 2.3 버전부터는 XML 파일을 만들면 기본으로 지정되는 레이아웃이다. 이는 RelativeLayout과 상당히 유사하다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;상대적 위치 지정: app: layout_constraintLeft_toRightOf &lt;br /&gt; 여백(margin): android:layout_marginStart &lt;br /&gt; 가운데 맞춤과 치우침(bias): app: layout_constraintHorizontal_bias &lt;br /&gt; 비율(ratio): app: layout_constraintDimensionRatio&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;깡쌤의 안드로이드 프로그래밍, 루비페이퍼 &lt;br /&gt;
RelativeLayout: https://recipes4dev.tistory.com/126&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary></summary></entry><entry><title>Android LifeCycle</title><link href="http://localhost:4000/Android-Lifecycle/" rel="alternate" type="text/html" title="Android LifeCycle" /><published>2020-08-28T00:00:00+09:00</published><updated>2020-08-28T00:00:00+09:00</updated><id>http://localhost:4000/Android-Lifecycle</id><content type="html" xml:base="http://localhost:4000/Android-Lifecycle/">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;액티비티-생명주기&quot;&gt;액티비티 생명주기&lt;/h2&gt;

&lt;p&gt;　안드로이드에서 화면이 아닌 액티비티 자체가 어떤 원리로 수행되는지 살펴보자. 액티비티를 실행하는 주체는 안드로이드 시스템이므로 시스템에서 액티비티 생명주기 (life cycle) 을 어떻게 관리하며, 그때 개발자 코드에서 신경 써야 하는 부분은 무엇인지 알아본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;액티비티-상태&quot;&gt;액티비티 상태&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;활성 상태(activity running): 현재 액티비티가 화면을 점유하여 출력되고 있으며 사용자 이벤트 처리가 정상으로 처리되는 상태&lt;/li&gt;
  &lt;li&gt;일시 정지 상태(pause): 현재 액티비티가 일시적으로 사용이 불가능한 상태&lt;/li&gt;
  &lt;li&gt;비활성 상태(stop): 현재 액티비티가 다른 액티비티로 인해 화면이 완벽하게 가려진 상태&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-활성-상태&quot;&gt;👋🏻 활성 상태&lt;/h3&gt;

&lt;p&gt;　액티비티가 사용자 화면에 보이고 있으며 포커스를 가지고 있어 사용자 이벤트에 반응할 수 있는 상태이다. 생성된 액티비티는 onCreate() -&amp;gt; onStart() -&amp;gt; onResume() 함수가 호출되면서 활성 상태가 된다. 일반적으로 setContentView() 함수를 이용해 액티비티 화면을 출력한다고 하지만, 정확하게는 setContentView() 함수가 호출되는 시점이 화면 출력 순간이 아니라, &lt;strong&gt;onResume() 함수까지 실행하고, setContentView() 함수에서 출력한 내용이 화면에 나오는 구조이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　따라서 onResume() 함수가 실행되기까지 setContentView() 함수를 onCreate(), onStart(), onResume() 등 어디선가 호출해 주면 화면에 잘 나온다. 반대로 onResume() 함수가 호출될 때까지 setContentView() 함수가 한 번도 호출되지 않는다면, 화면에 아무것도 나오지 않는다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;-일시-정지-상태&quot;&gt;🤏🏻 일시 정지 상태&lt;/h3&gt;

&lt;p&gt;　일시 정지 상태는 액티비티가 여전히 화면에 보이지만, 포커스를 잃은 상태이다. 대표적인 예시로 다른 액티비티가 화면 전체를 가리지 않고 실행된 때이다. 다른 액티비티가 반투명하게 실행되거나 다이얼로그 스타일로 실행되어 여전히 자신이 화면에 보이지만, 포커스를 잃은 상태이다. 이때, onPause() 함수가 자동으로 호출된다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;-비활성-상태&quot;&gt;👊🏻 비활성 상태&lt;/h3&gt;

&lt;p&gt;　비활성 상태는 다른 액티비티로 인해 화면이 완전히 가려진 상태이다. 보통 다른 액티비티로 화면이 전환되어 안 보이는 경우다. 이때는 onPause() -&amp;gt; onStop() 함수까지 호출된다.&lt;/p&gt;

&lt;p&gt;　화면을 가렸던 액티비티가 뒤로가기 비활성 상태에서 뒤로가기 버튼 등으로 화면을 가렸던 액티비티가 사라지면 다시 활성 상태로 전환되는데, 이때는 onRestart() -&amp;gt; onStart() -&amp;gt; onResume() 함수가 차례로 호출된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;액티비티-상태-저장&quot;&gt;액티비티 상태 저장&lt;/h2&gt;

&lt;p&gt;　액티비티의 상태 관리를 위해 데이터를 저장했다가 복원하는 데 사용되는 함수는 onCreate(), onRestoreInstanceState(), onSaveInstanceState() 이다. 우선 액티비티가 종료되는 상항에 대비해 액티비티의 데이터를 저장해야 한다면 &lt;strong&gt;onSaveInstanceState()&lt;/strong&gt; 함수를 사용한다. 이는 onPause() 함수 호출 후 자동으로 호출되며, 이 함수에서 액티비티의 데이터를 저장한다.&lt;/p&gt;

&lt;p&gt;　저장하는 방법은 매개변수로 전달되는 Bundle을 이용하면 된다. Bundle은 컴포넌트의 데이터를 저장하기 위한 일종의 Map 객체이며, 이 객체에 데이터를 key-value로 담아주면 내부적으로 파일로 저장해줌으로써 액티비티가 종료되더라도 데이터는 유실되지 않는다. 이렇게 저장한 데이터를 액티비티가 다시 시작되는 시점에 가져와서 이용할 수 있다. 이 작업에는 onCreate()와 onRestoreInstanceState() 함수를 이용한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;reference&quot;&gt;REFERENCE&lt;/h4&gt;
&lt;p class=&quot;notice&quot;&gt;깡쌤의 안드로이드 프로그래밍, 루비페이퍼 &lt;br /&gt;&lt;/p&gt;</content><category term="android" /><category term="java" /><category term="kotlin" /><summary></summary></entry></feed>
